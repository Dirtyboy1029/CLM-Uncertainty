{"code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n \t*lenp = 3;\n \tfid->udf.block = location.logicalBlockNum;\n \tfid->udf.partref = location.partitionReferenceNum;\n \tfid->udf.generation = inode->i_generation;\n \tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\treturn type;\n}", "target": 1}
{"code": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n    if (loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n \tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n \t\treturn NULL;\n \t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n \tfree(rundir);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n   tBTM_LE_PENC_KEYS le_key;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);\n   STREAM_TO_UINT16(le_key.ediv, p);\n  STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);\n  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);\n  le_key.sec_level = p_cb->sec_level;\n  le_key.key_size = p_cb->loc_enc_size;\n if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&\n (p_cb->loc_auth_req & SMP_AUTH_BOND))\n    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,\n (tBTM_LE_KEY_VALUE*)&le_key, true);\n  smp_key_distribution(p_cb, NULL);\n}", "target": 1}
{"code": "libxlDomainEventHandler(void *data, libxl_event *event)\n{\n    libxlDriverPrivate *driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    virDomainObj *vm = NULL;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    VIR_DEBUG(\"Received libxl event '%d' for domid '%d'\", event->type, event->domid);\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto cleanup;\n    }\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto cleanup;\n    vm = virDomainObjListFindByID(driver->domains, event->domid);\n    if (!vm) {\n        goto cleanup;\n    }\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {\n        struct libxlEventHandlerThreadInfo *shutdown_info = NULL;\n        virThread thread;\n        g_autofree char *name = NULL;\n        shutdown_info = g_new0(struct libxlEventHandlerThreadInfo, 1);\n        shutdown_info->driver = driver;\n        shutdown_info->vm = vm;\n        shutdown_info->event = (libxl_event *)event;\n        name = g_strdup_printf(\"ev-%d\", event->domid);\n        if (virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                name, false, shutdown_info) < 0) {\n            VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n            VIR_FREE(shutdown_info);\n            goto cleanup;\n        }\n        return;\n    } else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        libxlDomainHandleDeath(driver, vm);\n    }\n cleanup:\n    virDomainObjEndAPI(&vm);\n    cfg = libxlDriverConfigGet(driver);\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n}", "target": 1}
{"code": "static int __init lp_setup (char *str)\n{\n\tstatic int parport_ptr;\n\tint x;\n\tif (get_option(&str, &x)) {\n\t\tif (x == 0) {\n\t\t\tparport_nr[0] = LP_PARPORT_OFF;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"auto\")) {\n\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t} else if (!strcmp(str, \"none\")) {\n\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t} else if (!strcmp(str, \"reset\")) {\n\t\treset = 1;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n\tint count, i;\n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\tif (!device)\n\t\treturn -EINVAL;\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tprintk(KERN_INFO PREFIX \"SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\thc->ec, hc->offset, hc->query_bit);\n\treturn 0;\n}", "target": 1}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n \t\t\tgoto Efault;\n \t}\n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "static int ms_init_ff(struct hid_device *hdev)\n{\n\tstruct hid_input *hidinput = list_entry(hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn 0;\n\tms->hdev = hdev;\n\tINIT_WORK(&ms->ff_worker, ms_ff_worker);\n\tms->output_report_dmabuf = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\tsizeof(struct xb1s_ff_report),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (ms->output_report_dmabuf == NULL)\n\t\treturn -ENOMEM;\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, ms_play_effect);\n}", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "flatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n      if (val && val[0] != 0)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}", "target": 1}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n     st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n     size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n         int ret;\n         st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": " static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n\treturn true;\n }", "target": 1}
{"code": "Try<JWT, JWTError> JWT::parse(const string& token, const string& secret)\n{\n  const vector<string> components = strings::split(token, \".\");\n  if (components.size() != 3) {\n    return JWTError(\n        \"Expected 3 components in token, got \" + stringify(components.size()),\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<JWT::Header> header = parse_header(components[0]);\n  if (header.isError()) {\n    return JWTError(header.error(), JWTError::Type::INVALID_TOKEN);\n  }\n  if (header->alg != JWT::Alg::HS256) {\n    return JWTError(\n        \"Token 'alg' value \\\"\" + stringify(header->alg) +\n        \"\\\" does not match, expected \\\"HS256\\\"\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<JSON::Object> payload = parse_payload(components[1]);\n  if (payload.isError()) {\n    return JWTError(payload.error(), JWTError::Type::INVALID_TOKEN);\n  }\n  const Try<string> signature = base64::decode_url_safe(components[2]);\n  if (signature.isError()) {\n    return JWTError(\n        \"Failed to base64url-decode token signature: \" + signature.error(),\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<string> hmac = generate_hmac_sha256(\n      components[0] + \".\" + components[1],\n      secret);\n  if (hmac.isError()) {\n    return JWTError(\n        \"Failed to generate HMAC signature: \" + hmac.error(),\n        JWTError::Type::UNKNOWN);\n  }\n  const bool valid = hmac.get() == signature.get();\n  if (!valid) {\n    return JWTError(\n        \"Token signature does not match\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n  return JWT(header.get(), payload.get(), signature.get());\n}", "target": 1}
{"code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\tif (code_new == clear_code) {\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\t} else if (code_new == ctx->eoi_code) {\n\t\treturn LZW_EOI_CODE;\n\t} else if (code_new > current_entry) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new < current_entry) {\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "target": 1}
{"code": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(false),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {};", "target": 1}
{"code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n    size = (Py_ssize_t) ysize * stride;\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n    im->destroy = mapping_destroy_buffer;\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n    return PyImagingNew(im);\n}", "target": 1}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n \t\tif (args->flags & ATTR_CREATE)\n \t\t\treturn retval;\n \t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n \t}\n \tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& gradient = ctx->input(0);\n    const Tensor& input = ctx->input(1);\n    Tensor* input_backprop = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, input.shape(), &input_backprop));\n    OP_REQUIRES(\n        ctx, input.IsSameSize(gradient),\n        errors::InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    const Tensor& input_min_tensor = ctx->input(2);\n    const Tensor& input_max_tensor = ctx->input(3);\n    if (axis_ != -1) {\n      OP_REQUIRES(\n          ctx, input_min_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n                                  \" was \", input_min_tensor.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n                                  \" was \", input_max_tensor.dim_size(0)));\n    }\n    TensorShape min_max_shape(input_min_tensor.shape());\n    Tensor* input_min_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n    Tensor* input_max_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n        input.template flat<T>(), input_min_tensor.scalar<T>(),\n        input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n        input_min_backprop->template scalar<T>(),\n        input_max_backprop->template scalar<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        &input_min_tensor, &input_max_tensor,\n        input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input_min_backprop->template flat<T>(),\n        input_max_backprop->template flat<T>());\n    }\n  }", "target": 1}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "static void ssdp_recv(int sd)\n{\n \tssize_t len;\n \tstruct sockaddr sa;\n \tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n \tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n \tif (len > 0) {\n\t\tbuf[len] = 0;\n \t\tif (sa.sa_family != AF_INET)\n \t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tfbdev = to_au1100fb_device(fbi);\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }", "target": 1}
{"code": "process_form_int(struct parsed_tag *tag, int fid)\n{\n    char *p, *q, *r, *s, *tg, *n;\n    p = \"get\";\n    parsedtag_get_value(tag, ATTR_METHOD, &p);\n    q = \"!CURRENT_URL!\";\n    parsedtag_get_value(tag, ATTR_ACTION, &q);\n    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);\n    r = NULL;\n#ifdef USE_M17N\n    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))\n\tr = check_accept_charset(r);\n    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))\n\tr = check_charset(r);\n#endif\n    s = NULL;\n    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);\n    tg = NULL;\n    parsedtag_get_value(tag, ATTR_TARGET, &tg);\n    n = NULL;\n    parsedtag_get_value(tag, ATTR_NAME, &n);\n    if (fid < 0) {\n\tform_max++;\n\tform_sp++;\n\tfid = form_max;\n    }\n    else {\t\t\t\n\tif (form_max < fid)\n\t    form_max = fid;\n\tform_sp = fid;\n    }\n    if (forms_size == 0) {\n\tforms_size = INITIAL_FORM_SIZE;\n\tforms = New_N(FormList *, forms_size);\n\tform_stack = NewAtom_N(int, forms_size);\n    }\n    else if (forms_size <= form_max) {\n\tforms_size += form_max;\n\tforms = New_Reuse(FormList *, forms, forms_size);\n\tform_stack = New_Reuse(int, form_stack, forms_size);\n    }\n    form_stack[form_sp] = fid;\n    if (w3m_halfdump) {\n\tStr tmp = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\t  fid, html_quote(q), html_quote(p));\n\tif (s)\n\t    Strcat(tmp, Sprintf(\" enctype=\\\"%s\\\"\", html_quote(s)));\n\tif (tg)\n\t    Strcat(tmp, Sprintf(\" target=\\\"%s\\\"\", html_quote(tg)));\n\tif (n)\n\t    Strcat(tmp, Sprintf(\" name=\\\"%s\\\"\", html_quote(n)));\n#ifdef USE_M17N\n\tif (r)\n\t    Strcat(tmp, Sprintf(\" accept-charset=\\\"%s\\\"\", html_quote(r)));\n#endif\n\tStrcat_charp(tmp, \">\");\n\treturn tmp;\n    }\n    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);\n    return NULL;\n}", "target": 1}
{"code": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"generic DVB-USB module\";\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n}", "target": 1}
{"code": "XML_GetBuffer(XML_Parser parser, int len)\n{\n  switch (ps_parsing) {\n  case XML_SUSPENDED:\n    errorCode = XML_ERROR_SUSPENDED;\n    return NULL;\n  case XML_FINISHED:\n    errorCode = XML_ERROR_FINISHED;\n    return NULL;\n  default: ;\n  }\n  if (len > bufferLim - bufferEnd) {\n    int neededSize = len + (int)(bufferEnd - bufferPtr);\n#ifdef XML_CONTEXT_BYTES\n    int keep = (int)(bufferPtr - buffer);\n    if (keep > XML_CONTEXT_BYTES)\n      keep = XML_CONTEXT_BYTES;\n    neededSize += keep;\n#endif  \n    if (neededSize  <= bufferLim - buffer) {\n#ifdef XML_CONTEXT_BYTES\n      if (keep < bufferPtr - buffer) {\n        int offset = (int)(bufferPtr - buffer) - keep;\n        memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);\n        bufferEnd -= offset;\n        bufferPtr -= offset;\n      }\n#else\n      memmove(buffer, bufferPtr, bufferEnd - bufferPtr);\n      bufferEnd = buffer + (bufferEnd - bufferPtr);\n      bufferPtr = buffer;\n#endif  \n    }\n    else {\n      char *newBuf;\n      int bufferSize = (int)(bufferLim - bufferPtr);\n      if (bufferSize == 0)\n        bufferSize = INIT_BUFFER_SIZE;\n      do {\n        bufferSize *= 2;\n      } while (bufferSize < neededSize);\n      newBuf = (char *)MALLOC(bufferSize);\n      if (newBuf == 0) {\n        errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      bufferLim = newBuf + bufferSize;\n#ifdef XML_CONTEXT_BYTES\n      if (bufferPtr) {\n        int keep = (int)(bufferPtr - buffer);\n        if (keep > XML_CONTEXT_BYTES)\n          keep = XML_CONTEXT_BYTES;\n        memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);\n        FREE(buffer);\n        buffer = newBuf;\n        bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;\n        bufferPtr = buffer + keep;\n      }\n      else {\n        bufferEnd = newBuf + (bufferEnd - bufferPtr);\n        bufferPtr = buffer = newBuf;\n      }\n#else\n      if (bufferPtr) {\n        memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);\n        FREE(buffer);\n      }\n      bufferEnd = newBuf + (bufferEnd - bufferPtr);\n      bufferPtr = buffer = newBuf;\n#endif  \n    }\n    eventPtr = eventEndPtr = NULL;\n    positionPtr = NULL;\n  }\n  return bufferEnd;\n}", "target": 1}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 1}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n   size_t a_len = a.nlimbs;\n   size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n   if (c_ptr != NULL)\n     {\n       char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}", "target": 1}
{"code": "decrypt(MPI output, MPI a, MPI b, ELG_secret_key *skey )\n{\n    MPI t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n    mpi_normalize (a);\n    mpi_normalize (b);\n    mpi_powm( t1, a, skey->x, skey->p );\n    mpi_invm( t1, t1, skey->p );\n    mpi_mulm( output, b, t1, skey->p );\n#if 0\n    if( DBG_CIPHER ) {\n\tlog_mpidump(\"elg decrypted x= \", skey->x);\n\tlog_mpidump(\"elg decrypted p= \", skey->p);\n\tlog_mpidump(\"elg decrypted a= \", a);\n\tlog_mpidump(\"elg decrypted b= \", b);\n\tlog_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n    mpi_free(t1);\n}", "target": 1}
{"code": " status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  \n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  \n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  \n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  \n case 40: \n break;\n default:\n            ALOGE(\"Unrecognized NAL unit type.\");\n return ERROR_MALFORMED;\n }\n if (err != OK) {\n return err;\n }\n    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);\n    buffer->setInt32Data(nalUnitType);\n    mNalUnits.push(buffer);\n return OK;\n}", "target": 1}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": " DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)\n    : AbstractMetadataProvider(e),\n       m_validate(XMLHelper::getAttrBool(e, false, validate)),\n         m_id(XMLHelper::getAttrString(e, \"Dynamic\", id)),\n         m_lock(RWLock::create()),\n        m_refreshDelayFactor(0.75),\n        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),\n        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),\n        m_shutdown(false),\n        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),\n        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),\n         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)\n {\n     if (m_minCacheDuration > m_maxCacheDuration) {\n        Category::getInstance(SAML_LOGCAT \".MetadataProvider.Dynamic\").error(\n             \"minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it\"\n             );\n         m_minCacheDuration = m_maxCacheDuration;\n    }\n    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;\n    if (delay && *delay) {\n        auto_ptr_char temp(delay);\n        m_refreshDelayFactor = atof(temp.get());\n        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {\n            Category::getInstance(SAML_LOGCAT \".MetadataProvider.Dynamic\").error(\n                \"invalid refreshDelayFactor setting, using default\"\n                );\n            m_refreshDelayFactor = 0.75;\n        }\n    }\n    if (m_cleanupInterval > 0) {\n        if (m_cleanupTimeout < 0)\n            m_cleanupTimeout = 0;\n        m_cleanup_wait = CondWait::create();\n        m_cleanup_thread = Thread::create(&cleanup_fn, this);\n    }\n}", "target": 1}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n \tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n \tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n \tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n \t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n \t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n \t\treturn -1;\n \t}\n \t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}", "target": 1}
{"code": "static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tgoto copy_rest;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "nbd_unlocked_opt_go (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_go (h, &c);\n  if (r == -1)\n    return r;\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \"server replied with error to opt_go request\");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n {\n \tunsigned int u = 0;\n \tLineContribType *res;\n\tint overflow_error = 0;\n \tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n \tif (!res) {\n \t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n \t\treturn NULL;\n \t}\n \tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n \t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n \t\t\t\tgdFree(res->ContribRow[i].Weights);\n \t\t\t}\n \t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_in: \",\n                                        tensor_in.DebugString()));\n    OP_REQUIRES(context, tensor_out.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_out: \",\n                                        tensor_out.DebugString()));\n    OP_REQUIRES(\n        context, out_grad_backprop.NumElements() > 0,\n        errors::InvalidArgument(\"received empty tensor out_grad_backprop: \",\n                                out_grad_backprop.DebugString()));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n   mrb_value value;\n   fiber_check_cfunc(mrb, c);\n  if (resume && c->status == MRB_FIBER_TRANSFERRED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n   }\n  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n   }\n  if (c->status == MRB_FIBER_TERMINATED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n   }\n  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  if (c->status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n    if (len >= c->stend - c->stack) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"too many arguments to fiber\");\n    }\n     b = c->stack+1;\n     e = b + len;\n     while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n   else {\n     value = fiber_result(mrb, a, len);\n   }\n  fiber_switch_context(mrb, c);\n   if (vmexec) {\n     c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "static void do_tx_packet(lan9118_state *s)\n{\n    int n;\n    uint32_t status;\n    if (s->phy_control & 0x4000)  {\n        lan9118_receive(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    } else {\n        qemu_send_packet(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    }\n    s->txp->fifo_used = 0;\n    if (s->tx_status_fifo_used == 512) {\n        return;\n    }\n    status = s->txp->cmd_b & 0xffff0000u;\n    DPRINTF(\"Sent packet tag:%04x len %d\\n\", status >> 16, s->txp->len);\n    n = (s->tx_status_fifo_head + s->tx_status_fifo_used) & 511;\n    s->tx_status_fifo[n] = status;\n    s->tx_status_fifo_used++;\n    if (s->tx_status_fifo_used == 512) {\n        s->int_sts |= TSFF_INT;\n    }\n}", "target": 1}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n \tu_int length = h->len;\n \tif_printer printer;\n \tconst pktap_header_t *hdr;\n \tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n \t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n \tcase PKT_REC_PACKET:\n \t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n \t\t} else {\n \t\t\tif (!ndo->ndo_eflag)\n \t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n {\n \tif (tl1 > l2)\n \t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                 goto invalid;\n             break;\n         }\n         c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n    if (*bp != '\\r')\n         goto invalid;\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n    if (*bp != '\\n')\n         goto invalid;\n     bp++;\n     len--;\n     *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n     return (too_large ? -3 : result);\n trunc:\n     return (-2);\n invalid:\n     return (-5);\n }", "target": 1}
{"code": "verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)\n{\n\tint flags = 0;\n\tchar *fp;\n\tfp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);\n\tdebug(\"Server host key: %s %s\", key_type(host_key), fp);\n\tfree(fp);\n\tif (!key_is_cert(host_key) && options.verify_host_key_dns &&\n\t    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {\n\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t    flags & DNS_VERIFY_SECURE)\n\t\t\t\treturn 0;\n\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t} else {\n\t\t\t\twarn_changed_key(host_key);\n\t\t\t\terror(\"Update the SSHFP RR in DNS with the new \"\n\t\t\t\t    \"host key to get rid of this message.\");\n\t\t\t}\n\t\t}\n\t}\n\treturn check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n}", "target": 1}
{"code": "void Document::open()\n{\n    ASSERT(!importLoader());\n    if (m_frame) {\n        if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {\n            if (parser->isParsing()) {\n                if (parser->isExecutingScript())\n                    return;\n                if (!parser->wasCreatedByScript() && parser->hasInsertionPoint())\n                    return;\n            }\n        }\n        if (m_frame->loader().provisionalDocumentLoader())\n            m_frame->loader().stopAllLoaders();\n    }\n    removeAllEventListenersRecursively();\n    implicitOpen(ForceSynchronousParsing);\n    if (ScriptableDocumentParser* parser = scriptableDocumentParser())\n        parser->setWasCreatedByScript(true);\n     if (m_frame)\n         m_frame->loader().didExplicitOpen();\n    if (m_loadEventProgress != LoadEventInProgress && m_loadEventProgress != UnloadEventInProgress)\n         m_loadEventProgress = LoadEventNotRun;\n }", "target": 1}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "static int date_from_ISO8601 (const char *text, time_t * value) {\n   struct tm tm;\n   int n;\n   int i;\n   char buf[30];\n\tif (strchr (text, '-')) {\n\t\tchar *p = (char *) text, *p2 = buf;\n\t\twhile (p && *p) {\n\t\t\tif (*p != '-') {\n\t\t\t\t*p2 = *p;\n\t\t\t\tp2++;\n\t\t\t\tif (p2-buf >= sizeof(buf)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t\ttext = buf;\n\t}\n   tm.tm_isdst = -1;\n#define XMLRPC_IS_NUMBER(x) if (x < '0' || x > '9') return -1;\n   n = 1000;\n   tm.tm_year = 0;\n   for(i = 0; i < 4; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_year += (text[i]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_mon = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mon += (text[i+4]-'0')*n;\n      n /= 10;\n   }\n   tm.tm_mon --;\n   n = 10;\n   tm.tm_mday = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mday += (text[i+6]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_hour = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_hour += (text[i+9]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_min = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_min += (text[i+12]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_sec = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_sec += (text[i+15]-'0')*n;\n      n /= 10;\n   }\n   tm.tm_year -= 1900;\n   *value = mkgmtime(&tm);\n   return 0;\n}", "target": 1}
{"code": "void PageFormAnalyserLogger::Flush() {\n  std::string text;\n  for (ConsoleLevel level : {kError, kWarning, kVerbose}) {\n    for (LogEntry& entry : node_buffer_[level]) {\n       text.clear();\n       text += \"[DOM] \";\n       text += entry.message;\n      for (unsigned i = 0; i < entry.nodes.size(); ++i)\n        text += \" %o\";\n       blink::WebConsoleMessage message(level, blink::WebString::FromUTF8(text));\n      message.nodes = std::move(entry.nodes);  \n       frame_->AddMessageToConsole(message);\n     }\n   }\n  node_buffer_.clear();\n}", "target": 1}
{"code": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}", "target": 1}
{"code": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n     return 0;\n }", "target": 1}
{"code": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) {\n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 1}
{"code": "int32_t ByteArray::Get(int32_t index) {\n  return InternalGet(index) & 0xff;\n}", "target": 1}
{"code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                           \"Control character detected in URL.\");\n             return HTTP_BAD_REQUEST;\n         }\n     }\n     return OK;\n}", "target": 1}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n \ttu = file->private_data;\n \tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n \tspin_lock_irq(&tu->qlock);\n \twhile ((long)count - result >= unit) {\n \t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n \t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n \t\t\tspin_unlock_irq(&tu->qlock);\n \t\t\tschedule();\n \t\t\tspin_lock_irq(&tu->qlock);\n \t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n \t\ttu->qused--;\n \t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->tread) {\n \t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_read)))\n \t\t\t\terr = -EFAULT;\n \t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n \t\tspin_lock_irq(&tu->qlock);\n \t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n \t}\n  _error:\n \tspin_unlock_irq(&tu->qlock);\n \treturn result > 0 ? result : err;\n }", "target": 1}
{"code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      if (dim.value().isConstant(1)) continue;\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}", "target": 1}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n   GimpImage           *image;\n   GimpImage           *loaded_image;\n   GimpPlugInProcedure *proc;\n  gchar               *filename;\n   GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                          use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n   file = g_file_new_for_path (filename);\n   g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n    smp_wmb();\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "int ssl3_do_change_cipher_spec(SSL *s)\n\t{\n\tint i;\n\tconst char *sender;\n\tint slen;\n\tif (s->state & SSL_ST_ACCEPT)\n\t\ti=SSL3_CHANGE_CIPHER_SERVER_READ;\n\telse\n\t\ti=SSL3_CHANGE_CIPHER_CLIENT_READ;\n\tif (s->s3->tmp.key_block == NULL)\n\t\t{\n\t\tif (s->session == NULL) \n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\treturn (0);\n\t\t\t}\n\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\tif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\n\t\t}\n\tif (!s->method->ssl3_enc->change_cipher_state(s,i))\n\t\treturn(0);\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\t&(s->s3->finish_dgst1),\n\t\t&(s->s3->finish_dgst2),\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\treturn(1);\n\t}", "target": 1}
{"code": " int BrowserNonClientFrameViewAura::NonClientTopBorderHeight(\n     bool force_restored) const {\n   if (frame()->widget_delegate() &&\n       frame()->widget_delegate()->ShouldShowWindowTitle()) {\n     return close_button_->bounds().bottom();\n   }\n  if (!frame()->IsMaximized() || force_restored)\n    return kTabstripTopSpacingRestored;\n  return kTabstripTopSpacingMaximized;\n }", "target": 1}
{"code": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n    if (item_num > 65536) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": " void WebPageSerializerImpl::openTagToString(Element* element,\n                                             SerializeDomParam* param)\n {\n    bool needSkip;\n    StringBuilder result;\n    result.append(preActionBeforeSerializeOpenTag(element, param, &needSkip));\n    if (needSkip)\n        return;\n    result.append('<');\n    result.append(element->nodeName().lower());\n    AttributeCollection attributes = element->attributes();\n    AttributeCollection::iterator end = attributes.end();\n    for (AttributeCollection::iterator it = attributes.begin(); it != end; ++it) {\n        result.append(' ');\n        result.append(it->name().toString());\n        result.appendLiteral(\"=\\\"\");\n        if (!it->value().isEmpty()) {\n            const String& attrValue = it->value();\n            const QualifiedName& attrName = it->name();\n             if (element->hasLegalLinkAttribute(attrName)) {\n                 if (attrValue.startsWith(\"javascript:\", TextCaseInsensitive)) {\n                    result.append(attrValue);\n                 } else {\n                     WebLocalFrameImpl* subFrame = WebLocalFrameImpl::fromFrameOwnerElement(element);\n                    String completeURL = subFrame ? subFrame->frame()->document()->url() :\n                                                    param->document->completeURL(attrValue);\n                    if (m_localLinks.contains(completeURL)) {\n                        if (!param->directoryName.isEmpty()) {\n                            result.appendLiteral(\"./\");\n                             result.append(param->directoryName);\n                             result.append('/');\n                         }\n                        result.append(m_localLinks.get(completeURL));\n                     } else {\n                        result.append(completeURL);\n                     }\n                 }\n             } else {\n                if (param->isHTMLDocument)\n                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));\n                else\n                    result.append(m_xmlEntities.convertEntitiesInString(attrValue));\n            }\n        }\n        result.append('\\\"');\n    }\n    String addedContents = postActionAfterSerializeOpenTag(element, param);\n    if (element->hasChildren() || param->haveAddedContentsBeforeEnd)\n        result.append('>');\n    result.append(addedContents);\n    saveHTMLContentToBuffer(result.toString(), param);\n}", "target": 1}
{"code": "static ExprList *exprListAppendList(\n  Parse *pParse,          \n  ExprList *pList,        \n  ExprList *pAppend,      \n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \tdev = file->private_data;\n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n \t}\n \tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n \tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n }", "target": 1}
{"code": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n\t       IOBUF a, size_t *ret_len )\n{\n    int zrc;\n    int rc=0;\n    size_t n;\n    int nread, count;\n    int refill = !zs->avail_in;\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n\t    if( nread == -1 ) nread = 0;\n\t    n += nread;\n\t    if( nread < count && zfx->algo == 1 ) {\n\t\t*(zfx->inbuf + n) = 0xFF; \n\t\tzfx->algo1hack = 1;\n\t\tn++;\n\t    }\n\t    zs->avail_in = n;\n\t}\n\trefill = 1;\n\tif( DBG_FILTER )\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; \n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n\t}\n    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );\n    *ret_len = zfx->outbufsize - zs->avail_out;\n    if( DBG_FILTER )\n\tlog_debug(\"do_uncompress: returning %u bytes (%u ignored)\\n\",\n                  (unsigned int)*ret_len, (unsigned int)zs->avail_in );\n    return rc;\n}", "target": 1}
{"code": "static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t   gfp_t gfp)\n{\n\tstruct sctp_chunkhdr *chunk_hdr;\n\tstruct sctp_chunk *retval;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tskb = alloc_skb(SCTP_PAD4(sizeof(*chunk_hdr) + paylen), gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\tchunk_hdr = (struct sctp_chunkhdr *)skb_put(skb, sizeof(*chunk_hdr));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(*chunk_hdr));\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(*chunk_hdr);\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\treturn retval;\nnodata:\n\treturn NULL;\n}", "target": 1}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": " PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n \t\treturn;\n \t}\n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \tRETURN_LONG((zend_long) sb.st_dev);\n }", "target": 1}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n   if (array->items == NULL)\n   {\n    count = yr_max(64, (index + 1) * 2);\n     array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n   else if (index >= array->items->count)\n   {\n     count = array->items->count * 2;\n     array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n         array->items,\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n             parse_profile_level_id(s, h264_data, value);\n     } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n         int ret;\n        if (value[strlen(value) - 1] == ',') {\n             av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n             return 0;\n         }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool TabsCaptureVisibleTabFunction::RunImpl() {\n  PrefService* service = profile()->GetPrefs();\n  if (service->GetBoolean(prefs::kDisableScreenshots)) {\n    error_ = keys::kScreenshotsDisabled;\n    return false;\n  }\n  WebContents* web_contents = NULL;\n  if (!GetTabToCapture(&web_contents))\n    return false;\n  image_format_ = FORMAT_JPEG;  \n  image_quality_ = kDefaultQuality;  \n  if (HasOptionalArgument(1)) {\n    DictionaryValue* options = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n    if (options->HasKey(keys::kFormatKey)) {\n      std::string format;\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetString(keys::kFormatKey, &format));\n      if (format == keys::kFormatValueJpeg) {\n        image_format_ = FORMAT_JPEG;\n      } else if (format == keys::kFormatValuePng) {\n        image_format_ = FORMAT_PNG;\n      } else {\n        EXTENSION_FUNCTION_VALIDATE(0);\n      }\n    }\n    if (options->HasKey(keys::kQualityKey)) {\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetInteger(keys::kQualityKey, &image_quality_));\n     }\n   }\n  if (!GetExtension()->CanCaptureVisiblePage(\n        web_contents->GetURL(),\n        SessionID::IdForTab(web_contents),\n        &error_)) {\n     return false;\n   }\n  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  content::RenderWidgetHostView* view = render_view_host->GetView();\n  if (!view) {\n    error_ = keys::kInternalVisibleTabCaptureError;\n    return false;\n  }\n  render_view_host->CopyFromBackingStore(\n      gfx::Rect(),\n      view->GetViewBounds().size(),\n      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,\n                 this));\n  return true;\n}", "target": 1}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\t\tkfree(sband->channels);\n\t}\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}", "target": 1}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n \tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n     }\n    if (data_end - data < 3)\n         return -1;\n    data++;\n     for (;;) {\n        int size = bytestream_get_be16(&data);\n         if (!size)\n             break;\n        if (size < 0 || size >= data_end - data)\n             return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n             return -1;\n        data += len;\n     }\n     return -1;\n }", "target": 1}
{"code": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}", "target": 1}
{"code": "function_call(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    fiddle_generic retval;\n    fiddle_generic *generic_args;\n    void **values;\n    VALUE cfunc, types, cPointer;\n    int i;\n    cfunc    = rb_iv_get(self, \"@ptr\");\n    types    = rb_iv_get(self, \"@args\");\n    cPointer = rb_const_get(mFiddle, rb_intern(\"Pointer\"));\n    if(argc != RARRAY_LENINT(types)) {\n\trb_raise(rb_eArgError, \"wrong number of arguments (%d for %d)\",\n\t\targc, RARRAY_LENINT(types));\n    }\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    values = xcalloc((size_t)argc + 1, (size_t)sizeof(void *));\n    generic_args = xcalloc((size_t)argc, (size_t)sizeof(fiddle_generic));\n    for (i = 0; i < argc; i++) {\n\tVALUE type = RARRAY_PTR(types)[i];\n\tVALUE src = argv[i];\n\tif(NUM2INT(type) == TYPE_VOIDP) {\n\t    if(NIL_P(src)) {\n\t\tsrc = INT2FIX(0);\n\t    } else if(cPointer != CLASS_OF(src)) {\n\t\tsrc = rb_funcall(cPointer, rb_intern(\"[]\"), 1, src);\n\t    }\n\t    src = rb_Integer(src);\n\t}\n\tVALUE2GENERIC(NUM2INT(type), src, &generic_args[i]);\n\tvalues[i] = (void *)&generic_args[i];\n    }\n    values[argc] = NULL;\n    ffi_call(cif, NUM2PTR(rb_Integer(cfunc)), &retval, values);\n    rb_funcall(mFiddle, rb_intern(\"last_error=\"), 1, INT2NUM(errno));\n#if defined(_WIN32)\n    rb_funcall(mFiddle, rb_intern(\"win32_last_error=\"), 1, INT2NUM(errno));\n#endif\n    xfree(values);\n    xfree(generic_args);\n    return GENERIC2VALUE(rb_iv_get(self, \"@return_type\"), retval);\n}", "target": 1}
{"code": " dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n {\n #ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n \tif (poke_int3_handler(regs))\n \t\treturn;\n \tist_enter(regs);\n \tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n \t\t\tSIGTRAP) == NOTIFY_STOP)\n \t\tgoto exit;\n\tdebug_stack_usage_inc();\n \tcond_local_irq_enable(regs);\n \tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n \tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\n exit:\n \tist_exit(regs);\n }", "target": 1}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n \t\tpktinfo->ipi_ifindex = 0;\n \t\tpktinfo->ipi_spec_dst.s_addr = 0;\n \t}\n\tskb_dst_drop(skb);\n }", "target": 1}
{"code": "int DCTStream::getChars(int nChars, unsigned char *buffer)\n{\n    for (int i = 0; i < nChars;) {\n        if (current == limit) {\n            if (!readLine())\n                return i;\n        }\n        int left = limit - current;\n        if (nChars < left)\n            left = nChars;\n        memcpy(buffer + i, current, left);\n        current += left;\n        i += left;\n    }\n    return nChars;\n}", "target": 1}
{"code": "static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\tmp_save_irq(&mp_irq);\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n \tconst char *msg;\n \tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n \t\t}\n \t\tsec.level = rfcomm_pi(sk)->sec_level;\n \t\tlen = min_t(unsigned int, len, sizeof(sec));\n \t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}", "target": 1}
{"code": " static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n   int i=0;\n   int foundit=0;\n   FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n   for(;;){\n     temp[i]=fgetc(fp);    \n     if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    int32 num_elements = c->input(1).scalar<int32>()();\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "void removeAllDOMObjects()\n{\n     DOMDataStore& store = DOMData::getCurrentStore();\n     v8::HandleScope scope;\n    if (isMainThread()) {\n        DOMData::removeObjectsFromWrapperMap<Node>(&store, store.domNodeMap());\n        DOMData::removeObjectsFromWrapperMap<Node>(&store, store.activeDomNodeMap());\n    }\n     DOMData::removeObjectsFromWrapperMap<void>(&store, store.domObjectMap());\n }", "target": 1}
{"code": " int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n \t\t const void *data, size_t datalen)\n {\n \tif (*(unsigned char *)data > 1)\n \t\treturn -ENOTSUPP;\n \treturn 1;\n}", "target": 1}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    int chr = *scanner->curptr;\n    if (!chr) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n    ++scanner->curptr;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}", "target": 1}
{"code": "void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {\n  DCHECK(submission->method() == FormSubmission::PostMethod ||\n         submission->method() == FormSubmission::GetMethod);\n  DCHECK(submission->data());\n  DCHECK(submission->form());\n  if (submission->action().isEmpty())\n    return;\n  if (document().isSandboxed(SandboxForms)) {\n    document().addConsoleMessage(ConsoleMessage::create(\n        SecurityMessageSource, ErrorMessageLevel,\n        \"Blocked form submission to '\" + submission->action().elidedString() +\n            \"' because the form's frame is sandboxed and the 'allow-forms' \"\n            \"permission is not set.\"));\n     return;\n   }\n   if (protocolIsJavaScript(submission->action())) {\n    if (!document().contentSecurityPolicy()->allowFormAction(\n            submission->action()))\n      return;\n     document().frame()->script().executeScriptIfJavaScriptURL(\n         submission->action(), this);\n     return;\n  }\n  Frame* targetFrame = document().frame()->findFrameForNavigation(\n      submission->target(), *document().frame());\n  if (!targetFrame) {\n    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&\n        !UserGestureIndicator::utilizeUserGesture())\n      return;\n    targetFrame = document().frame();\n  } else {\n    submission->clearTarget();\n  }\n  if (!targetFrame->host())\n    return;\n  UseCounter::count(document(), UseCounter::FormsSubmitted);\n  if (MixedContentChecker::isMixedFormAction(document().frame(),\n                                             submission->action()))\n    UseCounter::count(document().frame(),\n                      UseCounter::MixedContentFormsSubmitted);\n  if (targetFrame->isLocalFrame()) {\n    toLocalFrame(targetFrame)\n        ->navigationScheduler()\n        .scheduleFormSubmission(&document(), submission);\n  } else {\n    FrameLoadRequest frameLoadRequest =\n        submission->createFrameLoadRequest(&document());\n    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);\n  }\n}", "target": 1}
{"code": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; \n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; \n\tXMP_IO* file = handler->parent->ioRef;\n \tthis->oldPos = file->Offset();\n \tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;\n \tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}", "target": 1}
{"code": " _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }", "target": 1}
{"code": "resp_new (const char *head)\n{\n  const char *hdr;\n  int count, size;\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n  if (*head == '\\0')\n    {\n      return resp;\n    }\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n      do\n        {\n          const char *end = strchr (hdr, '\\n');\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n        }\n      while (*hdr == ' ' || *hdr == '\\t');\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n  return resp;\n}", "target": 1}
{"code": "Status ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return errors::Internal(\"Node \", node.name(), \" is not a Reshape node\");\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return errors::Internal(\"Node \", node.name(), \" has shape \",\n                            new_shape->DebugString(),\n                            \" which is not a constant\");\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return errors::Internal(\"Could not evaluate node \", node.name());\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return errors::Internal(\"Node \", node.name(), \" has no properties\");\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with invalid dtype\");\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with shape \",\n                            shape.DebugString(), \" which is not fully defined\");\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\tskb_pull(skb, ROSE_MIN_LEN);\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \tif (srose != NULL) {\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 1}
{"code": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n    set_pixel_conversion(vs);\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}", "target": 1}
{"code": "bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n    ResourceLoader* loader,\n    net::AuthChallengeInfo* auth_info) {\n  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))\n    return false;\n  if (!auth_info->is_proxy) {\n    HttpAuthResourceType resource_type =\n        HttpAuthResourceTypeOf(loader->request());\n    UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\",\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        uid_t session_uid = session_info_uid_for_session(session_info, agent_data->session);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid) ||\n            (pid_uid.uid != 0 && pid_uid.uid != session_uid)) {\n            syslog(LOG_ERR, \"UID mismatch: UID=%u PID=%u suid=%u\", pid_uid.uid,\n                   pid_uid.pid, session_uid);\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc(length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n \tif (nlmsg_len(nlh) < sizeof(*req))\n \t\treturn -EINVAL;\n \thndl = sock_diag_lock_handler(req->sdiag_family);\n \tif (hndl == NULL)\n \t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 1}
{"code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n    trace_usb_xhci_exit();\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n    }\n    usb_bus_release(&xhci->bus);\n}", "target": 1}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    int    channel_count;\n    if (fgets (header, MAX_CHARS_IN_ROW, fp) == NULL ||\n        header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII_GRAY &&\n         header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW_GRAY &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    if (img->type == PIXMAP_RAW_GRAY || img->type == PIXMAP_ASCII_GRAY)\n      channel_count = CHANNEL_COUNT_GRAY;\n    else\n      channel_count = CHANNEL_COUNT;\n    while((fgets (header, MAX_CHARS_IN_ROW, fp)) && (header[0] == '#'))\n      ;\n    errno = 0;\n    img->width = strtol (header, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading width: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: width is negative\");\n        return FALSE;\n      }\n    img->height = strtol (ptr, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading height: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: height is negative\");\n        return FALSE;\n      }\n    if (fgets (header, MAX_CHARS_IN_ROW, fp))\n      maxval = strtol (header, &ptr, 10);\n    else\n      maxval = 0;\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->channels = channel_count;\n    img->numsamples = img->width * img->height * channel_count;\n    return TRUE;\n}", "target": 1}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType SetQuantumDepth(const Image *image,\n  QuantumInfo *quantum_info,const size_t depth)\n{\n  size_t\n    extent,\n    quantum;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickSignature);\n  quantum_info->depth=depth;\n  if (quantum_info->format == FloatingPointQuantumFormat)\n    {\n      if (quantum_info->depth > 32)\n        quantum_info->depth=64;\n      else\n        if (quantum_info->depth > 16)\n          quantum_info->depth=32;\n        else\n          quantum_info->depth=16;\n    }\n  if (quantum_info->pixels != (unsigned char **) NULL)\n     DestroyQuantumPixels(quantum_info);\n   quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;\n   extent=image->columns*quantum;\n  if (quantum != (extent/image->columns))\n     return(MagickFalse);\n   return(AcquireQuantumPixels(quantum_info,extent));\n }", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 1}
{"code": "static inline void authenticate_post(void)\n{\n\tchar buffer[MAX_AUTHENTICATION_POST_BYTES];\n\tint len;\n\topen_auth_filter(\"authenticate-post\");\n\tlen = ctx.env.content_length;\n\tif (len > MAX_AUTHENTICATION_POST_BYTES)\n\t\tlen = MAX_AUTHENTICATION_POST_BYTES;\n\tif (read(STDIN_FILENO, buffer, len) < 0)\n\t\tdie_errno(\"Could not read POST from stdin\");\n\tif (write(STDOUT_FILENO, buffer, len) < 0)\n\t\tdie_errno(\"Could not write POST to stdout\");\n\tcgit_close_filter(ctx.cfg.auth_filter);\n\texit(0);\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)\n{\n\tstruct evbuffer_chain *chain, *tmp;\n\tconst unsigned char *data = data_in;\n\tsize_t remain, to_alloc;\n\tint result = -1;\n\tEVBUFFER_LOCK(buf);\n\tif (buf->freeze_end) {\n\t\tgoto done;\n\t}\n\tchain = buf->last;\n\tif (chain == NULL) {\n\t\tchain = evbuffer_chain_new(datlen);\n\t\tif (!chain)\n\t\t\tgoto done;\n\t\tevbuffer_chain_insert(buf, chain);\n\t}\n\tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n\t\tremain = (size_t)(chain->buffer_len - chain->misalign - chain->off);\n\t\tif (remain >= datlen) {\n\t\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t\t    data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t} else if (!CHAIN_PINNED(chain) &&\n\t\t    evbuffer_chain_should_realign(chain, datlen)) {\n\t\t\tevbuffer_chain_align(chain);\n\t\t\tmemcpy(chain->buffer + chain->off, data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tremain = 0;\n\t}\n\tto_alloc = chain->buffer_len;\n\tif (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)\n\t\tto_alloc <<= 1;\n\tif (datlen > to_alloc)\n\t\tto_alloc = datlen;\n\ttmp = evbuffer_chain_new(to_alloc);\n\tif (tmp == NULL)\n\t\tgoto done;\n\tif (remain) {\n\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t    data, remain);\n\t\tchain->off += remain;\n\t\tbuf->total_len += remain;\n\t\tbuf->n_add_for_cb += remain;\n\t}\n\tdata += remain;\n\tdatlen -= remain;\n\tmemcpy(tmp->buffer, data, datlen);\n\ttmp->off = datlen;\n\tevbuffer_chain_insert(buf, tmp);\n\tbuf->n_add_for_cb += datlen;\nout:\n\tevbuffer_invoke_callbacks_(buf);\n\tresult = 0;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}", "target": 1}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n        ptr += ((-ptr) % alignment);\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n        return (void*)ptr;\n    }\n    return base;\n}", "target": 1}
{"code": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n        jsR_savescope(J, scope);\n        if (n > F->numparams) {\n               js_pop(J, F->numparams - n);\n                n = F->numparams;\n        }\n        for (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    *base64,\n    message[MaxTextExtent];\n  const MagickInfo\n    *magick_info;\n  ExceptionInfo\n    *exception;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=(&image->exception);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MaxTextExtent);\n   magick_info=GetMagickInfo(write_info->magick,exception);\n   if ((magick_info == (const MagickInfo *) NULL) ||\n       (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n   (void) CopyMagickString(image->filename,write_info->filename,MaxTextExtent);\n   blob_length=2048;\n   write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MaxTextExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "bool NavigationController::RendererDidNavigate(\n    const ViewHostMsg_FrameNavigate_Params& params,\n    int extra_invalidate_flags,\n    LoadCommittedDetails* details) {\n  if (GetLastCommittedEntry()) {\n    details->previous_url = GetLastCommittedEntry()->url();\n    details->previous_entry_index = last_committed_entry_index();\n  } else {\n    details->previous_url = GURL();\n    details->previous_entry_index = -1;\n  }\n  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {\n    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);\n    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());\n    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);\n  }\n  details->is_in_page = IsURLInPageNavigation(params.url);\n  details->type = ClassifyNavigation(params);\n  switch (details->type) {\n    case NavigationType::NEW_PAGE:\n      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));\n      break;\n    case NavigationType::EXISTING_PAGE:\n      RendererDidNavigateToExistingPage(params);\n      break;\n    case NavigationType::SAME_PAGE:\n      RendererDidNavigateToSamePage(params);\n      break;\n    case NavigationType::IN_PAGE:\n      RendererDidNavigateInPage(params, &(details->did_replace_entry));\n      break;\n    case NavigationType::NEW_SUBFRAME:\n      RendererDidNavigateNewSubframe(params);\n      break;\n    case NavigationType::AUTO_SUBFRAME:\n      if (!RendererDidNavigateAutoSubframe(params))\n         return false;\n       break;\n     case NavigationType::NAV_IGNORE:\n       return false;\n     default:\n       NOTREACHED();\n  }\n  DCHECK(!params.content_state.empty());\n  NavigationEntry* active_entry = GetActiveEntry();\n  active_entry->set_content_state(params.content_state);\n  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());\n  details->is_auto = (PageTransition::IsRedirect(params.transition) &&\n                      !pending_entry()) ||\n      params.gesture == NavigationGestureAuto;\n  details->entry = active_entry;\n  details->is_main_frame = PageTransition::IsMainFrame(params.transition);\n  details->serialized_security_info = params.security_info;\n  details->http_status_code = params.http_status_code;\n  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);\n  return true;\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\terr = ARCHIVE_OK;\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t__archive_read_consume(a, lha->header_size - 2);\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n \tlha->compsize -= extdsize - 2;\n \tif (sum_calculated != headersum) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 1}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": "xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}", "target": 1}
{"code": "static int asf_build_simple_index(AVFormatContext *s, int stream_index)\n{\n    ff_asf_guid g;\n    ASFContext *asf     = s->priv_data;\n    int64_t current_pos = avio_tell(s->pb);\n    int64_t ret;\n    if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {\n        return ret;\n    }\n    if ((ret = ff_get_guid(s->pb, &g)) < 0)\n        goto end;\n    while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {\n        int64_t gsize = avio_rl64(s->pb);\n        if (gsize < 24 || avio_feof(s->pb)) {\n            goto end;\n        }\n        avio_skip(s->pb, gsize - 24);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n    }\n    {\n        int64_t itime, last_pos = -1;\n        int pct, ict;\n        int i;\n        int64_t av_unused gsize = avio_rl64(s->pb);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n        itime = avio_rl64(s->pb);\n        pct   = avio_rl32(s->pb);\n        ict   = avio_rl32(s->pb);\n        av_log(s, AV_LOG_DEBUG,\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n        for (i = 0; i < ict; i++) {\n            int pktnum        = avio_rl32(s->pb);\n            int pktct         = avio_rl16(s->pb);\n            int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n            if (pos != last_pos) {\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n                       pktnum, pktct, index_pts);\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n                last_pos = pos;\n            }\n        }\n        asf->index_read = ict > 1;\n    }\nend:\n    avio_seek(s->pb, current_pos, SEEK_SET);\n    return ret;\n}", "target": 1}
{"code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if (s->ti_size > 0) {\n             s->ti_size--;\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n                qemu_log_mask(LOG_UNIMP,\n                              \"esp: PIO data read not implemented\\n\");\n                s->rregs[ESP_FIFO] = 0;\n            } else {\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            }\n             esp_raise_irq(s);\n         }\n        if (s->ti_size == 0) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n        return old_val;\n    case ESP_TCHI:\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }", "target": 1}
{"code": "            Status readUTF8String( StringData* out ) {\n                int sz;\n                if ( !readNumber<int>( &sz ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                if ( out ) {\n                    *out = StringData( _buffer + _position, sz );\n                }\n                if ( !skip( sz - 1 ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                char c;\n                if ( !readNumber<char>( &c ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                if ( c != 0 )\n                    return Status( ErrorCodes::InvalidBSON, \"not null terminate string\" );\n                return Status::OK();\n            }", "target": 1}
{"code": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value)\n {\n    if (*pStackPtr >= CDL_STACK_SIZE)\n         return EAS_ERROR_FILE_FORMAT;\n     *pStackPtr = *pStackPtr + 1;\n    pStack[*pStackPtr] = value;\n return EAS_SUCCESS;\n}", "target": 1}
{"code": "defaults (void)\n{\n  char *tmp;\n  xzero (opt);\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n  opt.remove_listing = true;\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n  opt.regex_type = regex_type_posix;\n  opt.max_redirect = 20;\n  opt.waitretry = 10;\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n  opt.warc_maxsize = 0; \n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \treturn datagrams;\n}", "target": 1}
{"code": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tkfree(clt);\n}", "target": 1}
{"code": "static int identity_count(void *v, const char *key, const char *val)\n{\n    int *count = v;\n    *count += strlen(key) * 3 + strlen(val) * 3 + 1;\n    return 1;\n}", "target": 1}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "static int spawn_https_helper_openssl(const char *host, unsigned port)\n{\n\tchar *allocated = NULL;\n\tchar *servername;\n\tint sp[2];\n\tint pid;\n\tIF_FEATURE_WGET_HTTPS(volatile int child_failed = 0;)\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)\n\t\tbb_simple_perror_msg_and_die(\"socketpair\");\n\tif (!strchr(host, ':'))\n\t\thost = allocated = xasprintf(\"%s:%u\", host, port);\n\tservername = xstrdup(host);\n\tstrrchr(servername, ':')[0] = '\\0';\n\tfflush_all();\n\tpid = xvfork();\n\tif (pid == 0) {\n\t\tchar *argv[8];\n\t\tclose(sp[0]);\n\t\txmove_fd(sp[1], 0);\n\t\txdup2(0, 1);\n\t\txmove_fd(2, 3);\n\t\txopen(\"/dev/null\", O_RDWR);\n\t\tmemset(&argv, 0, sizeof(argv));\n\t\targv[0] = (char*)\"openssl\";\n\t\targv[1] = (char*)\"s_client\";\n\t\targv[2] = (char*)\"-quiet\";\n\t\targv[3] = (char*)\"-connect\";\n\t\targv[4] = (char*)host;\n\t\tif (!is_ip_address(servername)) {\n\t\t\targv[5] = (char*)\"-servername\";\n\t\t\targv[6] = (char*)servername;\n\t\t}\n\t\tBB_EXECVP(argv[0], argv);\n\t\txmove_fd(3, 2);\n# if ENABLE_FEATURE_WGET_HTTPS\n\t\tchild_failed = 1;\n\t\txfunc_die();\n# else\n\t\tbb_perror_msg_and_die(\"can't execute '%s'\", argv[0]);\n# endif\n\t}\n\tfree(servername);\n\tfree(allocated);\n\tclose(sp[1]);\n# if ENABLE_FEATURE_WGET_HTTPS\n\tif (child_failed) {\n\t\tclose(sp[0]);\n\t\treturn -1;\n\t}\n# endif\n\treturn sp[0];\n}", "target": 1}
{"code": "static int getnum (lua_State *L, const char **fmt, int df) {\n   if (!isdigit(**fmt))  \n     return df;  \n   else {\n     int a = 0;\n     do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n     return a;\n  }\n}", "target": 1}
{"code": "void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)\n{\n    attributes->usage = (audio_usage_t) parcel.readInt32();\n    attributes->content_type = (audio_content_type_t) parcel.readInt32();\n    attributes->source = (audio_source_t) parcel.readInt32();\n    attributes->flags = (audio_flags_mask_t) parcel.readInt32();\n const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);\n if (hasFlattenedTag) {\n String16 tags = parcel.readString16();\n ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());\n if (realTagSize <= 0) {\n            strcpy(attributes->tags, \"\");\n } else {\n             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?\n                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;\n            utf16_to_utf8(tags.string(), tagSize, attributes->tags);\n         }\n     } else {\n         ALOGE(\"unmarshallAudioAttributes() received unflattened tags, ignoring tag values\");\n        strcpy(attributes->tags, \"\");\n }\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}", "target": 1}
{"code": "static int binder_thread_release(struct binder_proc *proc,\n\t\t\t\t struct binder_thread *thread)\n{\n\tstruct binder_transaction *t;\n\tstruct binder_transaction *send_reply = NULL;\n\tint active_transactions = 0;\n\tstruct binder_transaction *last_t = NULL;\n\tbinder_inner_proc_lock(thread->proc);\n\tproc->tmp_ref++;\n\tatomic_inc(&thread->tmp_ref);\n\trb_erase(&thread->rb_node, &proc->threads);\n\tt = thread->transaction_stack;\n\tif (t) {\n\t\tspin_lock(&t->lock);\n\t\tif (t->to_thread == thread)\n\t\t\tsend_reply = t;\n\t}\n\tthread->is_dead = true;\n\twhile (t) {\n\t\tlast_t = t;\n\t\tactive_transactions++;\n\t\tbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\n\t\t\t     \"release %d:%d transaction %d %s, still active\\n\",\n\t\t\t      proc->pid, thread->pid,\n\t\t\t     t->debug_id,\n\t\t\t     (t->to_thread == thread) ? \"in\" : \"out\");\n\t\tif (t->to_thread == thread) {\n\t\t\tt->to_proc = NULL;\n\t\t\tt->to_thread = NULL;\n\t\t\tif (t->buffer) {\n\t\t\t\tt->buffer->transaction = NULL;\n\t\t\t\tt->buffer = NULL;\n\t\t\t}\n\t\t\tt = t->to_parent;\n\t\t} else if (t->from == thread) {\n\t\t\tt->from = NULL;\n\t\t\tt = t->from_parent;\n\t\t} else\n\t\t\tBUG();\n\t\tspin_unlock(&last_t->lock);\n\t\tif (t)\n\t\t\tspin_lock(&t->lock);\n\t}\n\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&\n\t    waitqueue_active(&thread->wait)) {\n\t\twake_up_poll(&thread->wait, EPOLLHUP | POLLFREE);\n\t}\n\tbinder_inner_proc_unlock(thread->proc);\n\tif (send_reply)\n\t\tbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\n\tbinder_release_work(proc, &thread->todo);\n\tbinder_thread_dec_tmpref(thread);\n\treturn active_transactions;\n}", "target": 1}
{"code": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    entry = entry->next();\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}", "target": 1}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n \tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n \tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n \tif( !load->real ) {\n \t\tif( !(load->real = vips_foreign_load_temp( load )) )\n \t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n \t\tg_object_set_qdata( G_OBJECT( load->real ), \n \t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n \t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\treturn 0;\n}", "target": 1}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n     (void) cs;\n     PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n         PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}", "target": 1}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n    dt_size += 10000;\n    dt_size *= 2;\n     fdt = g_malloc0(dt_size);\n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\nfail:\n    g_free(fdt);\n    return NULL;\n}", "target": 1}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": " static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n \tOPCODE_DESC *opcode_desc;\n \tut16 ins = (buf[1] << 8) | buf[0];\n \tint fail;\n \tchar *t;\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\top->addr = addr;\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\nINVALID_OP:\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\tr_strbuf_set (&op->esil, \"1,$\");\n\treturn NULL;\n}", "target": 1}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n \tu_char buf[1024];\n \tsize_t len;\n \tstruct stat st;\n\tint r;\n \tif (fstat(fd, &st) < 0)\n \t\treturn SSH_ERR_SYSTEM_ERROR;\n \tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n \t    st.st_size > MAX_KEY_FILE_SIZE)\n \t\treturn SSH_ERR_INVALID_FORMAT;\n \tfor (;;) {\n \t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n \t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n \t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat<int64>()(0);\n    int num_values = values.NumElements();\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n    const auto indices_values = indices.matrix<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 1}
{"code": " void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n    if (toHTMLElement(this)->highestAncestor() != formRoot)\n        setForm(0);\n }", "target": 1}
{"code": " HarfBuzzShaperBase::HarfBuzzShaperBase(const Font* font, const TextRun& run)\n     : m_font(font)\n     , m_run(run)\n     , m_wordSpacingAdjustment(font->wordSpacing())\n     , m_letterSpacing(font->letterSpacing())\n {\n }", "target": 1}
{"code": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}", "target": 1}
{"code": "  Statement_Ptr Expand::operator()(Declaration_Ptr d)\n  {\n    Block_Obj ab = d->block();\n    String_Obj old_p = d->property();\n    Expression_Obj prop = old_p->perform(&eval);\n    String_Obj new_p = Cast<String>(prop);\n    if (!new_p) {\n      std::string str(prop->to_string(ctx.c_options));\n      new_p = SASS_MEMORY_NEW(String_Constant, old_p->pstate(), str);\n    }\n    Expression_Obj value = d->value()->perform(&eval);\n    Block_Obj bb = ab ? operator()(ab) : NULL;\n    if (!bb) {\n      if (!value || (value->is_invisible() && !d->is_important())) return 0;\n    }\n    Declaration_Ptr decl = SASS_MEMORY_NEW(Declaration,\n                                        d->pstate(),\n                                        new_p,\n                                        value,\n                                        d->is_important(),\n                                        d->is_custom_property(),\n                                        bb);\n    decl->tabs(d->tabs());\n    return decl;\n  }", "target": 1}
{"code": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\tkfree(dev);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n \ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n \t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n \t\t\t\tbreak;\n \t\tcase 2:\n \t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n \t\t\tbreak;\n \t\tcase 5:\n \t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n \t\t\t\t\t\t    pc->lengthComponentIdent,\n \t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n \t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n \t}\n \tif (p > to + 1)\n \t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": " rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \trs_filter_graph_helper(str, filter);\n \tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n \t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n \t\tg_warning(\"Calling gnome-open failed.\");\n \tg_string_free(str, TRUE);\n }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 1}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "int ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}", "target": 1}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n     i = 0;\n     while (i < length) {\n         tlv = cp + i;\n         type = (uint8_t)tlv[0];\n         optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n         ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n         ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n         switch (type) {\n         case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 1}
{"code": "ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n \t\t       sta->sta.addr, sta->sta.aid, ac);\n \t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n \t\t\tpurge_old_ps_buffers(tx->local);\n \t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n \t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n \t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n \t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n \t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n \t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n \t\tif (!timer_pending(&local->sta_cleanup))\n \t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\t\tsta_info_recalc_tim(sta);\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\treturn TX_CONTINUE;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n  if ((columns == 0) || (rows == 0))\n    ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename);\n  image->columns=columns;\n  image->rows=rows;\n  if ((image->depth == 0) || (image->depth > (8*sizeof(MagickSizeType))))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,exception));\n}", "target": 1}
{"code": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n  operations_.emplace(id, std::move(operation));\n   return id;\n }", "target": 1}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n    src_x = av_clip(src_x, -16, s->width); \n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n    if (s->unrestricted_mv) {\n        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                     s->linesize, s->linesize,\n                                     9, 9,\n                                     src_x, src_y, s->h_edge_pos,\n                                     s->v_edge_pos);\n            src = s->sc.edge_emu_buffer;\n            emu = 1;\n        }\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }", "target": 1}
{"code": "MagickExport MagickBooleanType SubstituteString(char **string,\n  const char *search,const char *replace)\n{\n  MagickBooleanType\n    status;\n  register char\n    *p;\n  size_t\n    extent,\n    replace_extent,\n    search_extent;\n  ssize_t\n    offset;\n  status=MagickFalse;\n  search_extent=0,\n  replace_extent=0;\n  for (p=strchr(*string,*search); p != (char *) NULL; p=strchr(p+1,*search))\n  {\n    if (search_extent == 0)\n      search_extent=strlen(search);\n    if (strncmp(p,search,search_extent) != 0)\n      continue;\n    status=MagickTrue;\n    if (replace_extent == 0)\n      replace_extent=strlen(replace);\n    if (replace_extent > search_extent)\n      {\n        offset=(ssize_t) (p-(*string));\n        extent=strlen(*string)+replace_extent-search_extent+1;\n        *string=(char *) ResizeQuantumMemory(*string,extent+MagickPathExtent,\n          sizeof(*p));\n        if (*string == (char *) NULL)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireString\");\n        p=(*string)+offset;\n      }\n    if (search_extent != replace_extent)\n      (void) memmove(p+replace_extent,p+search_extent,\n        strlen(p+search_extent)+1);\n    (void) memcpy(p,replace,replace_extent);\n    p+=replace_extent-1;\n  }\n  return(status);\n}", "target": 1}
{"code": "ProcPutImage(ClientPtr client)\n{\n    GC *pGC;\n    DrawablePtr pDraw;\n    long length;                \n    long lengthProto;           \n    char *tmpImage;\n    REQUEST(xPutImageReq);\n    REQUEST_AT_LEAST_SIZE(xPutImageReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    if (stuff->format == XYBitmap) {\n        if ((stuff->depth != 1) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n    }\n    else if (stuff->format == XYPixmap) {\n        if ((pDraw->depth != stuff->depth) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n        length *= stuff->depth;\n    }\n    else if (stuff->format == ZPixmap) {\n        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))\n            return BadMatch;\n        length = PixmapBytePad(stuff->width, stuff->depth);\n    }\n    else {\n        client->errorValue = stuff->format;\n        return BadValue;\n    }\n     tmpImage = (char *) &stuff[1];\n     lengthProto = length;\n    if (lengthProto >= (INT32_MAX / stuff->height))\n         return BadLength;\n     if ((bytes_to_int32(lengthProto * stuff->height) +\n         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)\n        return BadLength;\n    ReformatImage(tmpImage, lengthProto * stuff->height,\n                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,\n                  ClientOrder(client));\n    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,\n                           stuff->width, stuff->height,\n                           stuff->leftPad, stuff->format, tmpImage);\n    return Success;\n}", "target": 1}
{"code": " ScopedSharedBufferHandle WrapSharedMemoryHandle(\n     const base::SharedMemoryHandle& memory_handle,\n     size_t size,\n    bool read_only) {\n   if (!memory_handle.IsValid())\n     return ScopedSharedBufferHandle();\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n  platform_handle.type = kPlatformSharedBufferHandleType;\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  platform_handle.value =\n      static_cast<uint64_t>(memory_handle.GetMemoryObject());\n#else\n  platform_handle.value =\n      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());\n#endif\n   MojoPlatformSharedBufferHandleFlags flags =\n       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n  if (read_only)\n    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n   MojoSharedBufferGuid guid;\n   guid.high = memory_handle.GetGUID().GetHighForSerialization();\n  guid.low = memory_handle.GetGUID().GetLowForSerialization();\n  MojoHandle mojo_handle;\n  MojoResult result = MojoWrapPlatformSharedBufferHandle(\n      &platform_handle, size, &guid, flags, &mojo_handle);\n  CHECK_EQ(result, MOJO_RESULT_OK);\n   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));\n }", "target": 1}
{"code": " search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n \tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n \tstruct search_domain *dom;\n \tfor (dom = state->head; dom; dom = dom->next) {\n \t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n {\n \tstruct mount *tree;\n \tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n \tnamespace_unlock();\n \tif (IS_ERR(tree))\n \t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n     const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n  if (policy_to_inherit) {\n    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else if (frame_) {\n    Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                  : frame_->Client()->Opener();\n    if (inherit_from && frame_ != inherit_from) {\n      DCHECK(inherit_from->GetSecurityContext() &&\n             inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n      policy_to_inherit =\n          inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n      if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n          url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")) {\n        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n      }\n    }\n  }\n   if (policy_to_inherit && IsPluginDocument())\n     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n  GetContentSecurityPolicy()->BindToExecutionContext(this);\n }", "target": 1}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": " static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n \t\t\trdesc[106] == 0x03) {\n \t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n \t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\tzzip_file_close (file);\n    }\n}", "target": 1}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n \tint status = BLKIF_RSP_OKAY;\n \tstruct block_device *bdev = blkif->vbd.bdev;\n \tunsigned long secure;\n \tblkif->st_ds_req++;\n \txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n \terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n \t\t\t\t   req->u.discard.nr_sectors,\n \t\t\t\t   GFP_KERNEL, secure);\n \tif (err == -EOPNOTSUPP) {\n \t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n \t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }", "target": 1}
{"code": "void WavOutFile::write(const float *buffer, int numElems)\n{\n    int numBytes;\n    int bytesPerSample;\n    if (numElems == 0) return;\n    bytesPerSample = header.format.bits_per_sample / 8;\n    numBytes = numElems * bytesPerSample;\n    short *temp = (short*)getConvBuffer(numBytes);\n    switch (bytesPerSample)\n    {\n        case 1:\n        {\n            unsigned char *temp2 = (unsigned char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\n            }\n            break;\n        }\n        case 2:\n        {\n            short *temp2 = (short *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\n                temp2[i] = _swap16(value);\n            }\n            break;\n        }\n        case 3:\n        {\n            char *temp2 = (char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\n                *((int*)temp2) = _swap32(value);\n                temp2 += 3;\n            }\n            break;\n        }\n        case 4:\n        {\n            int *temp2 = (int *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\n                temp2[i] = _swap32(value);\n            }\n            break;\n        }\n        default:\n            assert(false);\n    }\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\n    if (res != numBytes) \n    {\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\n    }\n    bytesWritten += numBytes;\n}", "target": 1}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 1}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n   if(!scratch || data->set.crlf) {\n     oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n     if(!newscratch) {\n       failf(data, \"Failed to alloc scratch buffer!\");\n       return CURLE_OUT_OF_MEMORY;\n     }\n   }\n   eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n \t\treturn NULL;\n \t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n \t\tdprintk(\"%s: layout type %d not supported\\n\",\n \t\t\t__func__, layout_type);\n \t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "static int manager_dispatch_notify_fd(sd_event_source *source, int fd, uint32_t revents, void *userdata) {\n        Manager *m = userdata;\n        ssize_t n;\n        assert(m);\n        assert(m->notify_fd == fd);\n        if (revents != EPOLLIN) {\n                log_warning(\"Got unexpected poll event for notify fd.\");\n                return 0;\n        }\n        for (;;) {\n                char buf[4096];\n                struct iovec iovec = {\n                        .iov_base = buf,\n                        .iov_len = sizeof(buf)-1,\n                };\n                union {\n                        struct cmsghdr cmsghdr;\n                        uint8_t buf[CMSG_SPACE(sizeof(struct ucred))];\n                } control = {};\n                struct msghdr msghdr = {\n                        .msg_iov = &iovec,\n                        .msg_iovlen = 1,\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                };\n                struct ucred *ucred;\n                Unit *u;\n                _cleanup_strv_free_ char **tags = NULL;\n                n = recvmsg(m->notify_fd, &msghdr, MSG_DONTWAIT);\n                if (n <= 0) {\n                        if (n == 0)\n                                return -EIO;\n                        if (errno == EAGAIN || errno == EINTR)\n                                break;\n                        return -errno;\n                }\n                if (msghdr.msg_controllen < CMSG_LEN(sizeof(struct ucred)) ||\n                    control.cmsghdr.cmsg_level != SOL_SOCKET ||\n                    control.cmsghdr.cmsg_type != SCM_CREDENTIALS ||\n                    control.cmsghdr.cmsg_len != CMSG_LEN(sizeof(struct ucred))) {\n                        log_warning(\"Received notify message without credentials. Ignoring.\");\n                        continue;\n                }\n                ucred = (struct ucred*) CMSG_DATA(&control.cmsghdr);\n                u = hashmap_get(m->watch_pids, LONG_TO_PTR(ucred->pid));\n                if (!u) {\n                        u = manager_get_unit_by_pid(m, ucred->pid);\n                        if (!u) {\n                                log_warning(\"Cannot find unit for notify message of PID \"PID_FMT\".\", ucred->pid);\n                                continue;\n                        }\n                }\n                assert((size_t) n < sizeof(buf));\n                buf[n] = 0;\n                tags = strv_split(buf, \"\\n\\r\");\n                if (!tags)\n                        return log_oom();\n                log_debug_unit(u->id, \"Got notification message for unit %s\", u->id);\n                if (UNIT_VTABLE(u)->notify_message)\n                        UNIT_VTABLE(u)->notify_message(u, ucred->pid, tags);\n        }\n        return 0;\n}", "target": 1}
{"code": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "_gnutls_ecc_ansi_x963_export (gnutls_ecc_curve_t curve, bigint_t x, bigint_t y,\n                              gnutls_datum_t * out)\n{\n  int numlen = gnutls_ecc_curve_get_size (curve);\n  int byte_size, ret;\n  size_t size;\n  if (numlen == 0)\n    return gnutls_assert_val (GNUTLS_E_INVALID_REQUEST);\n  out->size = 1 + 2 * numlen;\n  out->data = gnutls_malloc (out->size);\n  if (out->data == NULL)\n    return gnutls_assert_val (GNUTLS_E_MEMORY_ERROR);\n  memset (out->data, 0, out->size);\n  out->data[0] = 0x04;\n  byte_size = (_gnutls_mpi_get_nbits (x) + 7) / 8;\n  size = out->size - (1 + (numlen - byte_size));\n  ret = _gnutls_mpi_print (x, &out->data[1 + (numlen - byte_size)], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  byte_size = (_gnutls_mpi_get_nbits (y) + 7) / 8;\n  size = out->size - (1 + (numlen + numlen - byte_size));\n  ret =\n    _gnutls_mpi_print (y, &out->data[1 + numlen + numlen - byte_size], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  return 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n \tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n \t\treturn rdesc;\n \tfor (i = 0; i < *rsize - 4; i++)\n \t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n \t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}", "target": 1}
{"code": " static void numtostr(js_State *J, const char *fmt, int w, double n)\n {\n\tchar buf[32], *e;\n \tsprintf(buf, fmt, w, n);\n \te = strchr(buf, 'e');\n \tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& indices = ctx->input(0);\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& dense_shape = ctx->input(2);\n    const Tensor& size_t = ctx->input(3);\n    const auto weights = ctx->input(4).flat<T>();\n    const int64_t weights_size = weights.size();\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    bool is_1d = dense_shape.NumElements() == 1;\n    Tensor* out_t;\n    functor::SetZeroFunctor<Device, T> fill;\n    if (is_1d) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({size}), &out_t));\n      auto out = out_t->flat<T>();\n      fill(ctx->eigen_device<Device>(), out);\n      if (binary_output_) {\n        OP_REQUIRES_OK(ctx,\n                       functor::BincountFunctor<Device, Tidx, T, true>::Compute(\n                           ctx, values, weights, out, size));\n      } else {\n        OP_REQUIRES_OK(\n            ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(\n                     ctx, values, weights, out, size));\n      }\n    } else {\n      const auto shape = dense_shape.flat<int64_t>();\n      const int64_t num_rows = shape(0);\n      OP_REQUIRES_OK(\n          ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n      const auto out = out_t->matrix<T>();\n      fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n      const auto indices_mat = indices.matrix<int64_t>();\n      for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {\n        const int64_t batch = indices_mat(i, 0);\n        const Tidx bin = values(i);\n        if (bin < size) {\n          if (binary_output_) {\n            out(batch, bin) = T(1);\n          } else {\n            if (weights_size) {\n              out(batch, bin) += weights(i);\n            } else {\n              out(batch, bin) += T(1);\n            }\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "Strgrow(Str x)\n {\n     char *old = x->ptr;\n     int newlen;\n    newlen = x->length * 6 / 5;\n    if (newlen == x->length)\n \tnewlen += 2;\n     x->ptr = GC_MALLOC_ATOMIC(newlen);\n     x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_nowhitespace));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": "static void fix_hostname(struct SessionHandle *data,\n                         struct connectdata *conn, struct hostname *host)\n{\n  size_t len;\n#ifndef USE_LIBIDN\n  (void)data;\n  (void)conn;\n#elif defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void)conn;\n#endif\n  host->dispname = host->name;\n  len = strlen(host->name);\n  if(host->name[len-1] == '.')\n    host->name[len-1]=0;\n  if(!is_ASCII_name(host->name)) {\n#ifdef USE_LIBIDN\n  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {\n    char *ace_hostname = NULL;\n    int rc = idna_to_ascii_lz(host->name, &ace_hostname, 0);\n    infof (data, \"Input domain encoded as `%s'\\n\",\n           stringprep_locale_charset ());\n    if(rc != IDNA_SUCCESS)\n      infof(data, \"Failed to convert %s to ACE; %s\\n\",\n            host->name, Curl_idn_strerror(conn, rc));\n    else {\n      (void)tld_check_name(data, ace_hostname);\n      host->encalloc = ace_hostname;\n      host->name = host->encalloc;\n    }\n  }\n#elif defined(USE_WIN32_IDN)\n    char *ace_hostname = NULL;\n    int rc = curl_win32_idn_to_ascii(host->name, &ace_hostname);\n    if(rc == 0)\n      infof(data, \"Failed to convert %s to ACE;\\n\",\n            host->name);\n    else {\n      host->encalloc = ace_hostname;\n      host->name = host->encalloc;\n    }\n#else\n    infof(data, \"IDN support not present, can't parse Unicode domains\\n\");\n#endif\n  }\n}", "target": 1}
{"code": " static bool parse_reconnect(struct pool *pool, json_t *val)\n {\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n \tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect forbidden, aborting.\");\n \t\treturn false;\n \t}\n\tmemset(address, 0, 255);\n \turl = (char *)json_string_value(json_array_get(val, 0));\n \tif (!url)\n \t\turl = pool->sockaddr_url;\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n      if ( coverage )\n      {\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n    if (data == NULL) {\n        return -1;\n    }\n    if (buffer->used + len < len) {\n        return -1;\n    }\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}", "target": 1}
{"code": "  void UrlParser::parse(char ch)\n  {\n    switch(_state)\n    {\n      case state_0:\n        if (ch == '=')\n          _state = state_value;\n        else if (ch == '&')\n          ;\n        else if (ch == '%')\n          _state = state_keyesc;\n        else\n        {\n          _key = ch;\n          _state = state_key;\n        }\n        break;\n      case state_key:\n        if (ch == '=')\n          _state = state_value;\n        else if (ch == '&')\n        {\n          _q.add(_key);\n          _key.clear();\n          _state = state_0;\n        }\n        else if (ch == '%')\n          _state = state_keyesc;\n        else\n          _key += ch;\n        break;\n      case state_value:\n        if (ch == '%')\n          _state = state_valueesc;\n        else if (ch == '&')\n        {\n          _q.add(_key, _value);\n          _key.clear();\n          _value.clear();\n          _state = state_0;\n        }\n        else if (ch == '+')\n          _value += ' ';\n        else\n          _value += ch;\n        break;\n      case state_keyesc:\n      case state_valueesc:\n        if (ch >= '0' && ch <= '9')\n        {\n          ++_cnt;\n          _v = (_v << 4) + (ch - '0');\n        }\n        else if (ch >= 'a' && ch <= 'f')\n        {\n          ++_cnt;\n          _v = (_v << 4) + (ch - 'a' + 10);\n        }\n        else if (ch >= 'A' && ch <= 'F')\n        {\n          ++_cnt;\n          _v = (_v << 4) + (ch - 'A' + 10);\n        }\n        else\n        {\n          if (_cnt == 0)\n          {\n            if (_state == state_keyesc)\n              _state = state_key;\n            else\n              _state = state_value;\n            parse('%');\n          }\n          else\n          {\n            if (_state == state_keyesc)\n            {\n              _key += static_cast<char>(_v);\n              _state = state_key;\n            }\n            else\n            {\n              _value += static_cast<char>(_v);\n              _state = state_value;\n            }\n            _cnt = 0;\n            _v = 0;\n          }\n          parse(ch);\n          break;\n        }\n        if (_cnt >= 2)\n        {\n          if (_state == state_keyesc)\n          {\n            _key += static_cast<char>(_v);\n            _state = state_key;\n          }\n          else\n          {\n            _value += static_cast<char>(_v);\n            _state = state_value;\n          }\n          _cnt = 0;\n          _v = 0;\n        }\n        break;\n    }\n  }", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 1}
{"code": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tint ret;\n\tif (unlikely(!out->f_op || !out->f_op->splice_write))\n\t\treturn -EINVAL;\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\tret = rw_verify_area(WRITE, out, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n \t\t\tsscanf(szV, \"%x\", &v);\n \t\t\tvalue[i] = v;\n \t\t\ti++;\n \t\t}\n \t}\n \tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void AXTree::PopulateOrderedSetItems(const AXNode* ordered_set,\n                                     const AXNode* local_parent,\n                                     std::vector<const AXNode*>& items,\n                                     bool node_is_radio_button) const {\n  if (!(ordered_set == local_parent)) {\n    if (local_parent->data().role == ordered_set->data().role)\n      return;\n  }\n   for (int i = 0; i < local_parent->child_count(); ++i) {\n     const AXNode* child = local_parent->GetUnignoredChildAtIndex(i);\n     if (node_is_radio_button &&\n         child->data().role == ax::mojom::Role::kRadioButton)\n      items.push_back(child);\n    if (!node_is_radio_button && child->SetRoleMatchesItemRole(ordered_set))\n      items.push_back(child);\n    if (child->data().role == ax::mojom::Role::kGenericContainer ||\n        child->data().role == ax::mojom::Role::kIgnored) {\n      PopulateOrderedSetItems(ordered_set, child, items, node_is_radio_button);\n    }\n  }\n}", "target": 1}
{"code": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                if (len + sumresidue < CSUM_CHUNK) {\n                        memcpy(md.buffer + sumresidue, p, len);\n                        sumresidue += len;\n\t\t}\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "decode_bits_in_field(const guint bit_offset, const gint no_of_bits, const guint64 value)\n{\n\tguint64 mask = 0,tmp;\n\tchar *str;\n\tint bit, str_p = 0;\n\tint i;\n\tmask = 1;\n\tmask = mask << (no_of_bits-1);\n\tstr=(char *)wmem_alloc0(wmem_packet_scope(), 256+64);\n\tfor(bit=0;bit<((int)(bit_offset&0x07));bit++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tstr[str_p] = '.';\n\t\tstr_p++;\n\t}\n\tfor(i=0;i<no_of_bits;i++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tif(bit&&(!(bit%8))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tbit++;\n\t\ttmp = value & mask;\n\t\tif(tmp != 0){\n\t\t\tstr[str_p] = '1';\n\t\t\tstr_p++;\n\t\t} else {\n\t\t\tstr[str_p] = '0';\n\t\t\tstr_p++;\n\t\t}\n\t\tmask = mask>>1;\n\t}\n\tfor(;bit%8;bit++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tstr[str_p] = '.';\n\t\tstr_p++;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n \t\tret = PTR_ERR(keyring);\n \t\tgoto error2;\n \t} else if (keyring == new->session_keyring) {\n \t\tret = 0;\n \t\tgoto error2;\n \t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n \t\t\tgoto out;\n \t\t}\n \t\tret = -EIO;\n \t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n \t\tif (bh) {\n \t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 1}
{"code": " static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n }", "target": 1}
{"code": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int fd, ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n       if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n                return \"no secrets file\";\n       if (do_fstat(fd, &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n \t\t}\n \t}\n \tif (table->total == table->max) {\n \t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1}
{"code": "long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n long len;\n  id = ReadID(pReader, pos, len);\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n  pos += len; \n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n  size = ReadUInt(pReader, pos, len);\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n  pos += len; \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n   return 0;  \n}", "target": 1}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "static int date_from_ISO8601 (const char *text, time_t * value) {\n   struct tm tm;\n * Begin Time Functions *\n ***********************/\n static int date_from_ISO8601 (const char *text, time_t * value) {\n    struct tm tm;\n    int n;\n    int i;\n       char buf[18];\n        if (strchr (text, '-')) {\n                char *p = (char *) text, *p2 = buf;\n   }\n                        if (*p != '-') {\n                                *p2 = *p;\n                                p2++;\n                        }\n                        p++;\n                }\n   }", "target": 1}
{"code": "set_file_metadata (const char *origin_url, const char *referrer_url, FILE *fp)\n{\n  int retval = -1;\n  if (!origin_url || !fp)\n    return retval;\n  retval = write_xattr_metadata (\"user.xdg.origin.url\", escnonprint_uri (origin_url), fp);\n  if ((!retval) && referrer_url)\n    retval = write_xattr_metadata (\"user.xdg.referrer.url\", escnonprint_uri (referrer_url), fp);\n  return retval;\n}", "target": 1}
{"code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\tparent = me->real_parent;\n\tret = -EPERM;\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\toldcred = parent->replacement_session_keyring;\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n#else \n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif \n}", "target": 1}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "pullf_read_max(PullFilter *pf, int len, uint8 **data_p, uint8 *tmpbuf)\n{\n\tint\t\t\tres,\n\t\t\t\ttotal;\n\tuint8\t   *tmp;\n\tres = pullf_read(pf, len, data_p);\n\tif (res <= 0 || res == len)\n\t\treturn res;\n\tmemcpy(tmpbuf, *data_p, res);\n\t*data_p = tmpbuf;\n\tlen -= res;\n\ttotal = res;\n\twhile (len > 0)\n\t{\n\t\tres = pullf_read(pf, len, &tmp);\n\t\tif (res < 0)\n\t\t{\n\t\t\tpx_memset(tmpbuf, 0, total);\n\t\t\treturn res;\n\t\t}\n\t\tif (res == 0)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuf + total, tmp, res);\n\t\ttotal += res;\n\t}\n\treturn total;\n}", "target": 1}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t\n    int\t\tprefixcnt)\t\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n     while ( strncmp( file, \"./\", 2 ) == 0 )\n \t(void) memmove( file, file + 2, strlen( file ) - 1 );\n     while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n     for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime\n\t\t\t)\n{\n    UINT16  highBytes;\n    crypt_uword_t       *msw = &prime->d[prime->size - 1];\n#define MASK (MAX_CRYPT_UWORD >> (RADIX_BITS - 16))\n    highBytes = *msw >> (RADIX_BITS - 16);\n    highBytes = ((UINT32)highBytes * (UINT32)0x4AFB) >> 16;\n    highBytes += 0xB505;\n    *msw = ((crypt_uword_t)(highBytes) << (RADIX_BITS - 16)) + (*msw & MASK);\n    prime->d[0] |= 1;\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n \t\terror = add_push_report_pkt(push, pkt);\n \t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 1}
{"code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n     p->pci_dev = pci_dev;\n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n    *pkt = p;\n}", "target": 1}
{"code": "windows_icon_typefind (GstTypeFind * find, gpointer user_data)\n{\n  const guint8 *data;\n  gint64 datalen;\n  guint16 type, nimages;\n  gint32 size, offset;\n  datalen = gst_type_find_get_length (find);\n  if ((data = gst_type_find_peek (find, 0, 6)) == NULL)\n    return;\n  if (GST_READ_UINT16_LE (data) != 0)\n    return;\n  type = GST_READ_UINT16_LE (data + 2);\n  if (type != 1 && type != 2)\n    return;\n  nimages = GST_READ_UINT16_LE (data + 4);\n  if (nimages == 0)             \n    return;\n  if (data[6 + 3] != 0)\n    return;\n  if (type == 1) {\n    guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);\n    if (planes > 1)\n      return;\n  }\n  size = GST_READ_UINT32_LE (data + 6 + 8);\n  offset = GST_READ_UINT32_LE (data + 6 + 12);\n  if (offset < 0 || size <= 0 || size >= datalen || offset >= datalen\n      || size + offset > datalen)\n    return;\n  gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,\n      \"image/x-icon\", NULL);\n}", "target": 1}
{"code": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tbuf[buf_size - 1] = '\\0';\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tseq = file->private_data;\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\treturn nbytes;\n}", "target": 1}
{"code": "int main()\n{\n   initialize_environment();\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n   return 0;\n}", "target": 1}
{"code": "  tt_cmap8_validate( FT_Byte*      table,\n                     FT_Validator  valid )\n  {\n    FT_Byte*   p = table + 4;\n    FT_Byte*   is32;\n    FT_UInt32  length;\n    FT_UInt32  num_groups;\n    if ( table + 16 + 8192 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n    length = TT_NEXT_ULONG( p );\n    if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )\n      FT_INVALID_TOO_SHORT;\n    is32       = table + 12;\n     p          = is32  + 8192;          \n     num_groups = TT_NEXT_ULONG( p );\n    if ( p + num_groups * 12 > valid->limit )\n       FT_INVALID_TOO_SHORT;\n      FT_UInt32  n, start, end, start_id, count, last = 0;\n      for ( n = 0; n < num_groups; n++ )\n      {\n        FT_UInt   hi, lo;\n        start    = TT_NEXT_ULONG( p );\n        end      = TT_NEXT_ULONG( p );\n        start_id = TT_NEXT_ULONG( p );\n        if ( start > end )\n          FT_INVALID_DATA;\n        if ( n > 0 && start <= last )\n          FT_INVALID_DATA;\n         if ( valid->level >= FT_VALIDATE_TIGHT )\n         {\n          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )\n             FT_INVALID_GLYPH_ID;\n           count = (FT_UInt32)( end - start + 1 );\n            {\n              hi = (FT_UInt)( start >> 16 );\n              lo = (FT_UInt)( start & 0xFFFFU );\n              if ( (is32[hi >> 3] & ( 0x80 >> ( hi & 7 ) ) ) == 0 )\n                FT_INVALID_DATA;\n              if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) == 0 )\n                FT_INVALID_DATA;\n            }\n          }\n          else\n          {\n            if ( end & ~0xFFFFU )\n              FT_INVALID_DATA;\n            for ( ; count > 0; count--, start++ )\n            {\n              lo = (FT_UInt)( start & 0xFFFFU );\n              if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) != 0 )\n                FT_INVALID_DATA;\n            }\n          }\n        }\n        last = end;\n      }", "target": 1}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n \tdevinfo.version_code = COMEDI_VERSION_CODE;\n \tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n \tif (read_subdev)\n \t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n {\n\tif (caplen <= 1) { \n \t\tND_PRINT((ndo, \"|OSI\"));\n \t\treturn;\n \t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n \tcase NLPID_CLNP:\n \t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n \tcase NLPID_ISIS:\n \t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n \t\tif (!ndo->ndo_eflag)\n \t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n \t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \t}\n }", "target": 1}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "void BaseAudioContext::Initialize() {\n  if (IsDestinationInitialized())\n    return;\n  FFTFrame::Initialize();\n  audio_worklet_ = AudioWorklet::Create(this);\n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n     listener_ = AudioListener::Create(*this);\n  }\n}", "target": 1}
{"code": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 1}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n \t\tnode = blk->bp->b_addr;\n \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n \t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n \t\t\tbreak;\n \t\tblk->hashval = lasthash;\n \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }", "target": 1}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n \tstruct inode *inode = page->mapping->host;\n \tstruct buffer_head *bh = NULL;\n \tunsigned char *symlink;\n\tint err = -EIO;\n \tunsigned char *p = kmap(page);\n \tstruct udf_inode_info *iinfo;\n \tuint32_t pos;\n \tiinfo = UDF_I(inode);\n \tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n \t} else {\n \t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n \t\tsymlink = bh->b_data;\n \t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n \tunlock_page(page);\n \treturn 0;\nout:\n \tup_read(&iinfo->i_data_sem);\n \tSetPageError(page);\n \tkunmap(page);\n \tunlock_page(page);\n \treturn err;\n}", "target": 1}
{"code": "int RGWPostObj_ObjStore_S3::get_tags()\n{\n  string tags_str;\n  if (part_str(parts, \"tagging\", &tags_str)) {\n    RGWObjTagsXMLParser parser;\n    if (!parser.init()){\n      ldout(s->cct, 0) << \"Couldn't init RGWObjTags XML parser\" << dendl;\n      err_msg = \"Server couldn't process the request\";\n      return -EINVAL; \n    }\n    if (!parser.parse(tags_str.c_str(), tags_str.size(), 1)) {\n      ldout(s->cct,0 ) << \"Invalid Tagging XML\" << dendl;\n      err_msg = \"Invalid Tagging XML\";\n      return -EINVAL;\n    }\n    RGWObjTagSet_S3 *obj_tags_s3;\n    RGWObjTagging_S3 *tagging;\n    tagging = static_cast<RGWObjTagging_S3 *>(parser.find_first(\"Tagging\"));\n    obj_tags_s3 = static_cast<RGWObjTagSet_S3 *>(tagging->find_first(\"TagSet\"));\n    if(!obj_tags_s3){\n      return -ERR_MALFORMED_XML;\n    }\n    RGWObjTags obj_tags;\n    int r = obj_tags_s3->rebuild(obj_tags);\n    if (r < 0)\n      return r;\n    bufferlist tags_bl;\n    obj_tags.encode(tags_bl);\n    ldout(s->cct, 20) << \"Read \" << obj_tags.count() << \"tags\" << dendl;\n    attrs[RGW_ATTR_TAGS] = tags_bl;\n  }\n  return 0;\n}", "target": 1}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data = OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            lp++;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}", "target": 1}
{"code": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\tBUG_ON(sig == -1);\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\tdo_notify_pidfd(tsk);\n\tif (sig != SIGCHLD) {\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn autoreap;\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void __reg_assign_32_into_64(struct bpf_reg_state *reg)\n{\n\treg->umin_value = reg->u32_min_value;\n\treg->umax_value = reg->u32_max_value;\n\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)\n\t\treg->smax_value = reg->s32_max_value;\n\telse\n\t\treg->smax_value = U32_MAX;\n\tif (reg->s32_min_value >= 0)\n\t\treg->smin_value = reg->s32_min_value;\n\telse\n\t\treg->smin_value = 0;\n}", "target": 1}
{"code": "bool EmbFile::save2(FILE *f) {\n  int c;\n  m_objStr.streamReset();\n  while ((c = m_objStr.streamGetChar()) != EOF) {\n    fputc(c, f);\n  }\n  return true;\n}", "target": 1}
{"code": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\n err_reg_dev:\n \tipip6_dev_free(sitn->fb_tunnel_dev);\n err_alloc_dev:\n \treturn err;\n }", "target": 1}
{"code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\txsave = &fpu->state.xsave;\n\tfpu__activate_fpstate_write(fpu);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n \t}\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\treturn ret;\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n \t\tskb_queue_walk(queue, skb) {\n \t\t\t*peeked = skb->peeked;\n \t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n \t\t\t\t\t*off -= skb->len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n {\n \tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n \tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n \treturn false;\n }", "target": 1}
{"code": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n                BIO *dcont, BIO *out, unsigned int flags)\n{\n    int r;\n    BIO *cont;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\n        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n        return 0;\n    }\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (flags & CMS_DEBUG_DECRYPT)\n         cms->d.envelopedData->encryptedContentInfo->debug = 1;\n     else\n         cms->d.envelopedData->encryptedContentInfo->debug = 0;\n     if (!pk && !cert && !dcont && !out)\n         return 1;\n     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n    r = cms_copy_content(out, cont, flags);\n    do_free_upto(cont, dcont);\n    return r;\n}", "target": 1}
{"code": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\treceive_packet(c->node, &outpkt);\n}", "target": 1}
{"code": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\tiph = ip_hdr(skb);\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 1}
{"code": " int perf_config(config_fn_t fn, void *data)\n {\n \tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n \tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n \t\tfree(user_config);\n \t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n \tif (found == 0)\n \t\treturn -1;\n \treturn ret;\n}", "target": 1}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  std::string uname;\n  lwp_read(fin, uname);\n  if (uname.length() > 0) {\n    struct passwd *pw = getpwnam(uname.c_str());\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}", "target": 1}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "gxps_fonts_new_font_face (GXPSArchive *zip,\n\t\t\t  const gchar *font_uri,\n\t\t\t  GError     **error)\n{\n\tGHashTable        *ft_cache;\n\tFtFontFace         ft_face;\n\tFtFontFace        *ft_font_face;\n\tFT_Face            face;\n\tcairo_font_face_t *font_face;\n\tguchar            *font_data;\n\tgsize              font_data_len;\n\tgboolean           res;\n\tres = gxps_archive_read_entry (zip, font_uri,\n\t\t\t\t       &font_data, &font_data_len,\n\t\t\t\t       error);\n\tif (!res) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_SOURCE_NOT_FOUND,\n\t\t\t     \"Font source %s not found in archive\",\n\t\t\t     font_uri);\n\t\treturn NULL;\n\t}\n\tft_face.font_data = font_data;\n\tft_face.font_data_len = (gssize)font_data_len;\n\tft_cache = get_ft_font_face_cache ();\n\tfont_face = g_hash_table_lookup (ft_cache, &ft_face);\n\tif (font_face) {\n\t\tg_free (font_data);\n\t\treturn font_face;\n\t}\n\tif (!gxps_fonts_new_ft_face (font_uri, font_data, font_data_len, &face)) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_FONT,\n\t\t\t     \"Failed to load font %s\", font_uri);\n\t\tg_free (font_data);\n\t\treturn NULL;\n\t}\n\tfont_face = cairo_ft_font_face_create_for_ft_face (face, 0);\n\tif (cairo_font_face_set_user_data (font_face,\n\t\t\t\t\t   &ft_cairo_key,\n\t\t\t\t\t   face,\n\t\t\t\t\t   (cairo_destroy_func_t) FT_Done_Face)) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_FONT,\n\t\t\t     \"Failed to load font %s: %s\",\n\t\t\t     font_uri,\n\t\t\t     cairo_status_to_string (cairo_font_face_status (font_face)));\n\t\tcairo_font_face_destroy (font_face);\n\t\tFT_Done_Face (face);\n\t\treturn NULL;\n\t}\n\tft_font_face = ft_font_face_new (font_data, (gssize)font_data_len);\n\tg_hash_table_insert (ft_cache, ft_font_face, font_face);\n\treturn font_face;\n}", "target": 1}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n \t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n \t}\n \treturn change;\n }", "target": 1}
{"code": " dwarf_elf_object_access_load_section(void* obj_in,\n     Dwarf_Half section_index,\n    Dwarf_Small** section_data,\n    int* error)\n{\n    dwarf_elf_object_access_internals_t*obj =\n        (dwarf_elf_object_access_internals_t*)obj_in;\n    if (section_index == 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n    {\n        Elf_Scn *scn = 0;\n        Elf_Data *data = 0;\n        scn = elf_getscn(obj->elf, section_index);\n        if (scn == NULL) {\n            *error = DW_DLE_MDE;\n            return DW_DLV_ERROR;\n        }\n        data = elf_getdata(scn, NULL);\n        if (data == NULL) {\n             *error = DW_DLE_MDE;\n             return DW_DLV_ERROR;\n         }\n         *section_data = data->d_buf;\n     }\n     return DW_DLV_OK;\n}", "target": 1}
{"code": "bool OutOfProcessInstance::Init(uint32_t argc,\n                                 const char* argn[],\n                                 const char* argv[]) {\n   pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);\n  std::string document_url = document_url_var.is_string() ?\n      document_url_var.AsString() : std::string();\n   std::string extension_url = std::string(kChromeExtension);\n  bool in_extension =\n      !document_url.compare(0, extension_url.size(), extension_url);\n  if (in_extension) {\n    for (uint32_t i = 0; i < argc; ++i) {\n      if (strcmp(argn[i], \"full-frame\") == 0) {\n        full_ = true;\n        break;\n      }\n     }\n   }\n  if (full_)\n    SetPluginToHandleFindRequests();\n  pp::VarDictionary translated_strings;\n  translated_strings.Set(kType, kJSSetTranslatedStringsType);\n  translated_strings.Set(kJSGetPasswordString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));\n  translated_strings.Set(kJSLoadingString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));\n  translated_strings.Set(kJSLoadFailedString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));\n  PostMessage(translated_strings);\n  text_input_.reset(new pp::TextInput_Dev(this));\n  const char* stream_url = nullptr;\n  const char* original_url = nullptr;\n  const char* headers = nullptr;\n  bool is_material = false;\n  for (uint32_t i = 0; i < argc; ++i) {\n    if (strcmp(argn[i], \"src\") == 0)\n      original_url = argv[i];\n    else if (strcmp(argn[i], \"stream-url\") == 0)\n      stream_url = argv[i];\n    else if (strcmp(argn[i], \"headers\") == 0)\n      headers = argv[i];\n    else if (strcmp(argn[i], \"is-material\") == 0)\n      is_material = true;\n    else if (strcmp(argn[i], \"top-toolbar-height\") == 0)\n      base::StringToInt(argv[i], &top_toolbar_height_);\n  }\n  if (is_material)\n    background_color_ = kBackgroundColorMaterial;\n  else\n    background_color_ = kBackgroundColor;\n  if (!original_url)\n    return false;\n  if (!stream_url)\n    stream_url = original_url;\n  if (IsPrintPreviewUrl(original_url))\n    return true;\n  LoadUrl(stream_url);\n  url_ = original_url;\n  return engine_->New(original_url, headers);\n}", "target": 1}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "void SyncManager::SyncInternal::OnIPAddressChanged() {\n  DVLOG(1) << \"IP address change detected\";\n  if (!observing_ip_address_changes_) {\n    DVLOG(1) << \"IP address change dropped.\";\n     return;\n   }\n#if defined (OS_CHROMEOS)\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&SyncInternal::OnIPAddressChangedImpl,\n                 weak_ptr_factory_.GetWeakPtr()),\n      kChromeOSNetworkChangeReactionDelayHackMsec);\n#else\n   OnIPAddressChangedImpl();\n#endif  \n }", "target": 1}
{"code": "equal_h (const struct ecc_modulo *p,\n\t const mp_limb_t *x1, const mp_limb_t *z1,\n\t const mp_limb_t *x2, const mp_limb_t *z2,\n\t mp_limb_t *scratch)\n{\n#define t0 scratch\n#define t1 (scratch + p->size)\n  ecc_mod_mul (p, t0, x1, z2, t0);\n  if (mpn_cmp (t0, p->m, p->size) >= 0)\n    mpn_sub_n (t0, t0, p->m, p->size);\n  ecc_mod_mul (p, t1, x2, z1, t1);\n  if (mpn_cmp (t1, p->m, p->size) >= 0)\n    mpn_sub_n (t1, t1, p->m, p->size);\n  return mpn_cmp (t0, t1, p->size) == 0;\n#undef t0\n#undef t1\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n \t\tconst URI_CHAR * const value = queryList->value;\n \t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n \t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n \t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n \t\tif (dest == NULL) {\n \t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 1}
{"code": "static void TIFFGetProfiles(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  uint32\n    length;\n  unsigned char\n    *profile;\n  length=0;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      if (TIFFIsByteSwapped(tiff) != 0)\n        TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n      (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      if (strstr((char *) profile,\"dc:format=\\\"image/dng\\\"\") != (char *) NULL)\n        (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n \t    && !vendor_intel(ctxt))\n \t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n \tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n \tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n \t\tcs.d = 0;\n \t\tcs.l = 1;\n \t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n \tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n \treturn X86EMUL_CONTINUE;\n }", "target": 1}
{"code": " static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)\n {\n    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));\n     if (p_buf) {\n         UINT8* pbuf_data;\n        p_buf->len = len;\n        p_buf->offset = BTA_HH_MIN_OFFSET;\n        pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;\n        memcpy(pbuf_data, data, len);\n }\n return p_buf;\n}", "target": 1}
{"code": "utf8_str (const gchar *utf8,\n          gchar       *buf)\n{\n  char_str (g_utf8_get_char (utf8), buf);\n  return buf;\n}", "target": 1}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 1}
{"code": "bool FontData::Bound(int32_t offset, int32_t length) {\n  if (offset + length > Size() || offset < 0 || length < 0)\n    return false;\n  bound_offset_ += offset;\n  bound_length_ = length;\n  return true;\n}", "target": 1}
{"code": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    \n        c->ach = 0;\n        return 0;\n    }\n    smpls =  as_pack[1] & 0x3f;       \n    freq  = (as_pack[4] >> 3) & 0x07; \n     stype = (as_pack[3] & 0x1f);      \n     quant =  as_pack[4] & 0x07;       \n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }", "target": 1}
{"code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc)\n{\n    kdc_realm_t         *newrealm;\n    kdc_realm_t **kdc_realmlist = handle->kdc_realmlist;\n    int kdc_numrealms = handle->kdc_numrealms;\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(handle, sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            return NULL;\n        else\n            return newrealm;\n    }\n    else\n        return kdc_realmlist[0];\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n \tif (skb->ip_summed != CHECKSUM_COMPLETE)\n \t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n \tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n }", "target": 1}
{"code": "static int bus_socket_make_message(sd_bus *bus, size_t size) {\n        sd_bus_message *t;\n        void *b;\n        int r;\n        assert(bus);\n        assert(bus->rbuffer_size >= size);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        if (bus->rbuffer_size > size) {\n                b = memdup((const uint8_t*) bus->rbuffer + size,\n                           bus->rbuffer_size - size);\n                if (!b)\n                        return -ENOMEM;\n        } else\n                b = NULL;\n        r = bus_message_from_malloc(bus,\n                                    bus->rbuffer, size,\n                                    bus->fds, bus->n_fds,\n                                    NULL,\n                                    &t);\n        if (r < 0) {\n                free(b);\n                return r;\n        }\n        bus->rbuffer = b;\n        bus->rbuffer_size -= size;\n        bus->fds = NULL;\n        bus->n_fds = 0;\n        bus->rqueue[bus->rqueue_size++] = t;\n        return 1;\n}", "target": 1}
{"code": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}", "target": 1}
{"code": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        return NULL;\n    }\n    fh = gfh->fh;\n    if (gfh->state == RW_STATE_WRITING) {\n        int ret = fflush(fh);\n        if (ret == EOF) {\n            error_setg_errno(errp, errno, \"failed to flush file\");\n            return NULL;\n        }\n        gfh->state = RW_STATE_NEW;\n    }\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n        gfh->state = RW_STATE_READING;\n    }\n    g_free(buf);\n    clearerr(fh);\n    return read_data;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args)\n{\n    ImagingDecoderObject* decoder;\n    char* mode;\n    char* rawmode;\n    char* compname;\n    int compression;\n    int fp;\n    if (! PyArg_ParseTuple(args, \"sssi\", &mode, &rawmode, &compname, &fp))\n        return NULL;\n    TRACE((\"new tiff decoder %s\\n\", compname));\n    if (strcasecmp(compname, \"tiff_ccitt\") == 0) {\n        compression = COMPRESSION_CCITTRLE;\n    } else if (strcasecmp(compname, \"group3\") == 0) {\n        compression = COMPRESSION_CCITTFAX3;\n    } else if (strcasecmp(compname, \"group4\") == 0) {\n        compression = COMPRESSION_CCITTFAX4;\n    } else if (strcasecmp(compname, \"tiff_raw_16\") == 0) {\n        compression = COMPRESSION_CCITTRLEW;\n    } else {\n        PyErr_SetString(PyExc_ValueError, \"unknown compession\");\n        return NULL;\n    }\n    decoder = PyImaging_DecoderNew(sizeof(TIFFSTATE));\n    if (decoder == NULL)\n        return NULL;\n    if (get_unpacker(decoder, mode, rawmode) < 0)\n        return NULL;\n    if (! ImagingLibTiffInit(&decoder->state, compression, fp)) {\n        Py_DECREF(decoder);\n        PyErr_SetString(PyExc_RuntimeError, \"tiff codec initialization failed\");\n        return NULL;\n    }\n    decoder->decode  = ImagingLibTiffDecode;\n    return (PyObject*) decoder;\n}", "target": 1}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 1}
{"code": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++)\n            if (p[x] != 0)\n                return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tu8 *buf = state->buf;\n\tu8 *b;\n\tint ret;\n\tstruct ir_raw_event ev;\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 1)\n\t\treturn 0; \n\tb = buf+1;\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(b, ret, deb_rc);\n#endif\n\tev.pulse = 0;\n\twhile (1) {\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (*b * FIRMWARE_CLOCK_DIVISOR * FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\tb++;\n\t\tif (*b == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tir_raw_event_handle(d->rc_dev);\n\treturn 1;\n}", "target": 1}
{"code": "search_memslots(struct kvm_memslots *slots, gfn_t gfn)\n{\n\tint start = 0, end = slots->used_slots;\n\tint slot = atomic_read(&slots->lru_slot);\n\tstruct kvm_memory_slot *memslots = slots->memslots;\n\tif (gfn >= memslots[slot].base_gfn &&\n\t    gfn < memslots[slot].base_gfn + memslots[slot].npages)\n\t\treturn &memslots[slot];\n\twhile (start < end) {\n\t\tslot = start + (end - start) / 2;\n\t\tif (gfn >= memslots[slot].base_gfn)\n\t\t\tend = slot;\n\t\telse\n\t\t\tstart = slot + 1;\n\t}\n\tif (gfn >= memslots[start].base_gfn &&\n\t    gfn < memslots[start].base_gfn + memslots[start].npages) {\n\t\tatomic_set(&slots->lru_slot, start);\n\t\treturn &memslots[start];\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\tperf_read_regs(regs);\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n \t\t\tif (is_limited_pmc(i + 1))\n \t\t\t\tcontinue;\n \t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n \t\t\t\twrite_pmc(i + 1, 0);\n \t\t}\n \t}\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}", "target": 1}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n {\n \tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "PHPAPI char *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = strlen(str);\n\tchar *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tTSRMLS_FETCH();\n\tcmd = safe_emalloc(4, l, 3); \n#ifdef PHP_WIN32\n\tcmd[y++] = '\"';\n#else\n\tcmd[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(cmd + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\t\tcmd[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tcmd[y++] = '\\'';\n\t\t\tcmd[y++] = '\\\\';\n\t\t\tcmd[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tcmd[y++] = str[x];\n                }\n        }\n #ifdef PHP_WIN32\n        cmd[y++] = '\"';\n #else\n        cmd[y++] = '\\'';\n\treturn cmd;\n}", "target": 1}
{"code": "static void _ewk_frame_smart_del(Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET(ewkFrame, smartData);\n    if (smartData) {\n         if (smartData->frame) {\n             WebCore::FrameLoaderClientEfl* flc = _ewk_frame_loader_efl_get(smartData->frame);\n             flc->setWebFrame(0);\n            smartData->frame->loader()->detachFromParent();\n            smartData->frame->loader()->cancelAndClear();\n             smartData->frame = 0;\n         }\n        eina_stringshare_del(smartData->title);\n        eina_stringshare_del(smartData->uri);\n        eina_stringshare_del(smartData->name);\n    }\n    _parent_sc.del(ewkFrame);\n}", "target": 1}
{"code": " void DelegatedFrameHost::CopyFromCompositingSurface(\n     const gfx::Rect& src_subrect,\n    const gfx::Size& dst_size,\n     const base::Callback<void(bool, const SkBitmap&)>& callback,\n     const SkColorType color_type) {\n  bool format_support = ((color_type == kRGB_565_SkColorType) ||\n                         (color_type == kN32_SkColorType));\n  DCHECK(format_support);\n  if (!CanCopyToBitmap()) {\n    callback.Run(false, SkBitmap());\n     return;\n   }\n  const gfx::Size& dst_size_in_pixel =\n      client_->ConvertViewSizeToPixel(dst_size);\n   scoped_ptr<cc::CopyOutputRequest> request =\n       cc::CopyOutputRequest::CreateRequest(base::Bind(\n           &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,\n          dst_size_in_pixel,\n           color_type,\n           callback));\n  gfx::Rect src_subrect_in_pixel =\n      ConvertRectToPixel(client_->CurrentDeviceScaleFactor(), src_subrect);\n  request->set_area(src_subrect_in_pixel);\n   client_->RequestCopyOfOutput(request.Pass());\n }", "target": 1}
{"code": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; \n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\tif (!mu_channels)\n\t\treturn 0;\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; \n\treturn mu_channels;\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n\tuint8 *data, *bmpdata;\n\tint i;\n\tin_uint16_le(s, num_updates);\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\t\tDEBUG((\"BITMAP_UPDATE(l=%d,t=%d,r=%d,b=%d,w=%d,h=%d,Bpp=%d,cmp=%d)\\n\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress));\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG_RDP5((\"Failed to decompress data\\n\"));\n\t\t}\n\t\txfree(bmpdata);\n\t}\n}", "target": 1}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }", "target": 1}
{"code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n \t\ttu->tstamp = *tstamp;\n \tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n \t\treturn;\n \tr1.event = event;\n \tr1.tstamp = *tstamp;\n \tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 1}
{"code": "static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tcount -= len;\n\t\t\tif (count > 0)\n\t\t\t\tgoto copy_rest;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "bool AsyncPixelTransfersCompletedQuery::End(\n    base::subtle::Atomic32 submit_count) {\n  AsyncMemoryParams mem_params;\n  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());\n  if (!buffer.shared_memory)\n    return false;\n  mem_params.shared_memory = buffer.shared_memory;\n   mem_params.shm_size = buffer.size;\n   mem_params.shm_data_offset = shm_offset();\n   mem_params.shm_data_size = sizeof(QuerySync);\n   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);\n  manager()->decoder()->GetAsyncPixelTransferManager()\n      ->AsyncNotifyCompletion(mem_params, observer_);\n  return AddToPendingTransferQueue(submit_count);\n}", "target": 1}
{"code": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)\n {\n   MagickPixelPacket\n     **pixels;\n  register ssize_t\n    i,\n     j;\n   size_t\n     number_threads;\n   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (MagickPixelPacket **) NULL)\n     return((MagickPixelPacket **) NULL);\n   (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   for (i=0; i < (ssize_t) number_threads; i++)\n   {\n    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,\n       sizeof(**pixels));\n     if (pixels[i] == (MagickPixelPacket *) NULL)\n       return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n      GetMagickPixelPacket(image,&pixels[i][j]);\n   }\n   return(pixels);\n }", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n \tif (!port)\n \t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n }", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": " choose_filters(struct archive_read *a)\n {\n\tint number_bidders, i, bid, best_bid;\n \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n \tstruct archive_read_filter *filter;\n \tssize_t avail;\n \tint r;\n\tfor (;;) {\n \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n \t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n \t\t\treturn (ARCHIVE_FATAL);\n \t\t}\n \t}\n }", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": " status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\",\n            mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    len = (len > SIZE - 1) ? SIZE - 1 : len;\n    write(fd, buffer, len);\n return mHardware->dump(fd, args);\n}", "target": 1}
{"code": "static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {\n        const char *v;\n        assert(handle);\n        assert(key);\n        v = pam_getenv(handle, key);\n        if (!isempty(v))\n                return v;\n        v = getenv(key);\n        if (!isempty(v))\n                return v;\n        return fallback;\n}", "target": 1}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 1}
{"code": "scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(\n    const VideoFrame* const src_frame,\n    const VideoFrameLayout& dst_layout) {\n  LOG_ASSERT(src_frame->IsMappable());\n  LOG_ASSERT(src_frame->format() == dst_layout.format());\n  auto dst_frame = VideoFrame::CreateFrameWithLayout(\n      dst_layout, src_frame->visible_rect(), src_frame->natural_size(),\n      src_frame->timestamp(), false );\n  if (!dst_frame) {\n    LOG(ERROR) << \"Failed to create VideoFrame\";\n    return nullptr;\n  }\n  const size_t num_planes = VideoFrame::NumPlanes(dst_layout.format());\n   LOG_ASSERT(dst_layout.planes().size() == num_planes);\n   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);\n   for (size_t i = 0; i < num_planes; ++i) {\n     libyuv::CopyPlane(\n         src_frame->data(i), src_frame->layout().planes()[i].stride,\n         dst_frame->data(i), dst_frame->layout().planes()[i].stride,\n        VideoFrame::Columns(i, dst_frame->format(),\n                            dst_frame->natural_size().width()),\n        VideoFrame::Rows(i, dst_frame->format(),\n                         dst_frame->natural_size().height()));\n   }\n   return dst_frame;\n}", "target": 1}
{"code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\tif (len == 255) {\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tcdk_free(buf);\n\t\t\treturn CDK_Inv_Packet;\n\t\t}\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\tif (*p != 1) {\t\t\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp++;\n\tlen--;\n\tif (len >= pktlen) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Out_Of_Core;\n\t}\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n}", "target": 1}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n \t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 1}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}", "target": 1}
{"code": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n \t\tminfo.fport = inc->i_hdr.h_dport;\n \t}\n \trds_info_copy(iter, &minfo, sizeof(minfo));\n }", "target": 1}
{"code": "compute_tag(dns_name_t *name, dns_rdata_dnskey_t *dnskey, isc_mem_t *mctx,\n\t    dns_keytag_t *tag)\n{\n\tisc_result_t result;\n\tdns_rdata_t rdata = DNS_RDATA_INIT;\n\tunsigned char data[4096];\n\tisc_buffer_t buffer;\n\tdst_key_t *dstkey = NULL;\n\tisc_buffer_init(&buffer, data, sizeof(data));\n\tdns_rdata_fromstruct(&rdata, dnskey->common.rdclass,\n\t\t\t     dns_rdatatype_dnskey, dnskey, &buffer);\n\tresult = dns_dnssec_keyfromrdata(name, &rdata, mctx, &dstkey);\n\tif (result == ISC_R_SUCCESS)\n\t\t*tag = dst_key_id(dstkey);\n\tdst_key_free(&dstkey);\n\treturn (result);\n}", "target": 1}
{"code": "static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\tbuf->addr = addr;\n\t\tbuf->len = pbuf->len;\n\t\tbuf->bid = bid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tif (!*head) {\n\t\t\tINIT_LIST_HEAD(&buf->list);\n\t\t\t*head = buf;\n\t\t} else {\n\t\t\tlist_add_tail(&buf->list, &(*head)->list);\n\t\t}\n\t}\n\treturn i ? i : -ENOMEM;\n}", "target": 1}
{"code": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t}\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}", "target": 1}
{"code": "urnParseReply(const char *inbuf, const HttpRequestMethod& m)\n{\n    char *buf = xstrdup(inbuf);\n    char *token;\n    url_entry *list;\n    url_entry *old;\n    int n = 32;\n    int i = 0;\n    debugs(52, 3, \"urnParseReply\");\n    list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n    for (token = strtok(buf, crlf); token; token = strtok(NULL, crlf)) {\n        debugs(52, 3, \"urnParseReply: got '\" << token << \"'\");\n        if (i == n) {\n            old = list;\n            n <<= 2;\n            list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n            memcpy(list, old, i * sizeof(*list));\n            safe_free(old);\n        }\n        AnyP::Uri uri;\n        if (!uri.parse(m, SBuf(token)) || !*uri.host())\n            continue;\n#if USE_ICMP\n        list[i].rtt = netdbHostRtt(uri.host());\n        if (0 == list[i].rtt) {\n            debugs(52, 3, \"Pinging \" << uri.host());\n            netdbPingSite(uri.host());\n        }\n#else\n        list[i].rtt = 0;\n#endif\n        list[i].url = xstrdup(uri.absolute().c_str());\n        list[i].host = xstrdup(uri.host());\n        list[i].flags.cached = storeGetPublic(list[i].url, m) ? 1 : 0;\n        ++i;\n    }\n    debugs(52, 3, \"urnParseReply: Found \" << i << \" URLs\");\n    return list;\n}", "target": 1}
{"code": "static int b_unpack (lua_State *L) {\n  Header h;\n   const char *fmt = luaL_checkstring(L, 1);\n   size_t ld;\n   const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n   int n = 0;  \n   defaultoptions(&h);\n   while (*fmt) {\n     int opt = *fmt++;\n     size_t size = optsize(L, opt, &fmt);\n     pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n     luaL_checkstack(L, 2, \"too many results\");\n     switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  \n  return n + 1;\n}", "target": 1}
{"code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\tmutex_lock(&econet_mutex);\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\tmutex_unlock(&econet_mutex);\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *image)\n {\n   PixelChannels\n     **pixels;\n   register ssize_t\n     i;\n   size_t\n     number_threads;\n   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (PixelChannels **) NULL)\n     return((PixelChannels **) NULL);\n   (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     register ssize_t\n       j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,\n      sizeof(**pixels));\n     if (pixels[i] == (PixelChannels *) NULL)\n       return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n     {\n       register ssize_t\n         k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 1}
{"code": "xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                const xmlChar *URI, int line, int nsNr, int tlen) {\n    const xmlChar *name;\n    GROW;\n    if ((RAW != '<') || (NXT(1) != '/')) {\n\txmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n\treturn;\n    }\n    SKIP(2);\n    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n        if (ctxt->input->cur[tlen] == '>') {\n\t    ctxt->input->cur += tlen + 1;\n\t    ctxt->input->col += tlen + 1;\n\t    goto done;\n\t}\n\tctxt->input->cur += tlen;\n\tctxt->input->col += tlen;\n\tname = (xmlChar*)1;\n    } else {\n\tif (prefix == NULL)\n\t    name = xmlParseNameAndCompare(ctxt, ctxt->name);\n\telse\n\t    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);\n    }\n    GROW;\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n    SKIP_BLANKS;\n    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {\n\txmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n    } else\n\tNEXT1;\n    if (name != (xmlChar*)1) {\n        if (name == NULL) name = BAD_CAST \"unparseable\";\n        if ((line == 0) && (ctxt->node != NULL))\n            line = ctxt->node->line;\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n\t\t     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n\t\t                ctxt->name, line, name);\n    }\ndone:\n    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t(!ctxt->disableSAX))\n\tctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);\n    spacePop(ctxt);\n    if (nsNr != 0)\n\tnsPop(ctxt, nsNr);\n    return;\n}", "target": 1}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n     if (oldcode == -1) {\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 1}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "static PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\nGETCHARINC(c, cc);\nlgb = UCD_GRAPHBREAK(c);\nwhile (cc < end_subject)\n  {\n  c = *cc;\n  rgb = UCD_GRAPHBREAK(c);\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0) break;\n  if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator) break;\n      ricount++;\n      }\n    if ((ricount & 1) != 0) break;  \n    }\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n  cc++;\n  }\nreturn cc;\n}", "target": 1}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "request_rec *h2_request_create_rec(const h2_request *req, conn_rec *c)\n{\n    int access_status = HTTP_OK;    \n    const char *rpath;\n    const char *s;\n#if AP_MODULE_MAGIC_AT_LEAST(20150222, 13)\n    request_rec *r = ap_create_request(c);\n#else\n    request_rec *r = my_ap_create_request(c);\n#endif\n    r->headers_in = apr_table_clone(r->pool, req->headers);\n    ap_run_pre_read_request(r, c);\n    r->request_time = req->request_time;\n    r->method = req->method;\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n    rpath = (req->path ? req->path : \"\");\n    ap_parse_uri(r, rpath);\n    r->protocol = (char*)\"HTTP/2.0\";\n    r->proto_num = HTTP_VERSION(2, 0);\n    r->the_request = apr_psprintf(r->pool, \"%s %s %s\", \n                                  r->method, rpath, r->protocol);\n    r->hostname = NULL;\n    ap_update_vhost_from_headers(r);\n    r->per_dir_config = r->server->lookup_defaults;\n    s = apr_table_get(r->headers_in, \"Expect\");\n    if (s && s[0]) {\n        if (ap_cstr_casecmp(s, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            r->status = HTTP_EXPECTATION_FAILED;\n            ap_send_error_response(r, 0);\n        }\n    }\n    ap_add_input_filter_handle(ap_http_input_filter_handle,\n                               NULL, r, r->connection);\n    if (access_status != HTTP_OK\n        || (access_status = ap_run_post_read_request(r))) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03367)\n                      \"h2_request: access_status=%d, request_create failed\",\n                      access_status);\n        ap_die(access_status, r);\n        ap_update_child_status(c->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        r = NULL;\n        goto traceout;\n    }\n    AP_READ_REQUEST_SUCCESS((uintptr_t)r, (char *)r->method, \n                            (char *)r->uri, (char *)r->server->defn_name, \n                            r->status);\n    return r;\ntraceout:\n    AP_READ_REQUEST_FAILURE((uintptr_t)r);\n    return r;\n}", "target": 1}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 1}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, const ASN1_IA5STRING *email)\n{\n    char *emtmp;\n    if (email->type != V_ASN1_IA5STRING)\n        return 1;\n    if (!email->data || !email->length)\n        return 1;\n    if (*sk == NULL)\n        *sk = sk_OPENSSL_STRING_new(sk_strcmp);\n    if (*sk == NULL)\n        return 0;\n    if (sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1)\n        return 1;\n    emtmp = OPENSSL_strdup((char *)email->data);\n    if (emtmp == NULL || !sk_OPENSSL_STRING_push(*sk, emtmp)) {\n        OPENSSL_free(emtmp);    \n        X509_email_free(*sk);\n        *sk = NULL;\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "void simplestring_addn(simplestring* target, const char* source, int add_len) {\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n      if(target->len + add_len + 1 > target->size) {\n         int newsize = target->len + add_len + 1;\n         int incr = target->size * 2;\n         newsize = newsize - (newsize % incr) + incr;\n         target->str = (char*)realloc(target->str, newsize);\n         target->size = target->str ? newsize : 0;\n      }\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; \n      }\n   }\n}", "target": 1}
{"code": "static int gaff_init(struct hid_device *hid)\n{\n\tstruct gaff_device *gaff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct list_head *report_ptr = report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport_ptr = report_ptr->next;\n\treport = list_entry(report_ptr, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 6) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tgaff = kzalloc(sizeof(struct gaff_device), GFP_KERNEL);\n\tif (!gaff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, gaff, hid_gaff_play);\n\tif (error) {\n\t\tkfree(gaff);\n\t\treturn error;\n\t}\n\tgaff->report = report;\n\tgaff->report->field[0]->value[0] = 0x51;\n\tgaff->report->field[0]->value[1] = 0x00;\n\tgaff->report->field[0]->value[2] = 0x00;\n\tgaff->report->field[0]->value[3] = 0x00;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\tgaff->report->field[0]->value[0] = 0xfa;\n\tgaff->report->field[0]->value[1] = 0xfe;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for GreenAsia 0x12 devices by Lukasz Lubojanski <lukasz@lubojanski.info>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n \t\t} else {\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n \t\t}\n \t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n \t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\tif (addr) {\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "bool TextAutosizer::processSubtree(RenderObject* layoutRoot)\n{\n    if (!m_document->settings() || !m_document->settings()->textAutosizingEnabled() || layoutRoot->view()->printing() || !m_document->page())\n        return false;\n    Frame* mainFrame = m_document->page()->mainFrame();\n    TextAutosizingWindowInfo windowInfo;\n     windowInfo.windowSize = m_document->settings()->textAutosizingWindowSizeOverride();\n     if (windowInfo.windowSize.isEmpty()) {\n         bool includeScrollbars = !InspectorInstrumentation::shouldApplyScreenWidthOverride(mainFrame);\n        windowInfo.windowSize = mainFrame->view()->visibleContentRect(includeScrollbars).size(); \n     }\n    windowInfo.minLayoutSize = mainFrame->view()->layoutSize();\n    for (Frame* frame = m_document->frame(); frame; frame = frame->tree()->parent()) {\n        if (!frame->view()->isInChildFrameWithFrameFlattening())\n            windowInfo.minLayoutSize = windowInfo.minLayoutSize.shrunkTo(frame->view()->layoutSize());\n    }\n    RenderBlock* container = layoutRoot->isRenderBlock() ? toRenderBlock(layoutRoot) : layoutRoot->containingBlock();\n    while (container && !isAutosizingContainer(container))\n        container = container->containingBlock();\n    RenderBlock* cluster = container;\n    while (cluster && (!isAutosizingContainer(cluster) || !isAutosizingCluster(cluster)))\n        cluster = cluster->containingBlock();\n    processCluster(cluster, container, layoutRoot, windowInfo);\n    return true;\n}", "target": 1}
{"code": "static int ldb_lock_backend_callback(struct ldb_request *req,\n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\ttalloc_free(lock_context);\n\t\treturn ret;\n\t}\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}", "target": 1}
{"code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\tread_lock(&tasklist_lock);\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}", "target": 1}
{"code": " static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n {\n \tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n }", "target": 1}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                   int64_t count, Error **errp)\n{\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    HANDLE fh;\n    bool is_ok;\n    DWORD read_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64\n                   \"' is invalid for argument count\", count);\n        return NULL;\n    }\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n    if (!is_ok) {\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = (size_t)read_count;\n        read_data->eof = read_count == 0;\n        if (read_count != 0) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n    }\n    g_free(buf);\n    return read_data;\n}", "target": 1}
{"code": "mail_parser_run (EMailParser *parser,\n                 EMailPartList *part_list,\n                 GCancellable *cancellable)\n{\n\tEMailExtensionRegistry *reg;\n\tCamelMimeMessage *message;\n\tEMailPart *mail_part;\n\tGQueue *parsers;\n\tGQueue mail_part_queue = G_QUEUE_INIT;\n\tGList *iter;\n\tGString *part_id;\n\tif (cancellable)\n\t\tg_object_ref (cancellable);\n\telse\n\t\tcancellable = g_cancellable_new ();\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_insert (parser->priv->ongoing_part_lists, cancellable, part_list);\n\tg_mutex_unlock (&parser->priv->mutex);\n\tmessage = e_mail_part_list_get_message (part_list);\n\treg = e_mail_parser_get_extension_registry (parser);\n\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\treg, \"application/vnd.evolution.message\");\n\tif (parsers == NULL)\n\t\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\t\treg, \"message\n\tg_return_if_fail (parsers != NULL);\n\tpart_id = g_string_new (\".message\");\n\tmail_part = e_mail_part_new (CAMEL_MIME_PART (message), \".message\");\n\te_mail_part_list_add_part (part_list, mail_part);\n\tg_object_unref (mail_part);\n\tfor (iter = parsers->head; iter; iter = iter->next) {\n\t\tEMailParserExtension *extension;\n\t\tgboolean message_handled;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\textension = iter->data;\n\t\tif (!extension)\n\t\t\tcontinue;\n\t\tmessage_handled = e_mail_parser_extension_parse (\n\t\t\textension, parser,\n\t\t\tCAMEL_MIME_PART (message),\n\t\t\tpart_id, cancellable, &mail_part_queue);\n\t\tif (message_handled)\n\t\t\tbreak;\n\t}\n\twhile (!g_queue_is_empty (&mail_part_queue)) {\n\t\tmail_part = g_queue_pop_head (&mail_part_queue);\n\t\te_mail_part_list_add_part (part_list, mail_part);\n\t\tg_object_unref (mail_part);\n\t}\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_remove (parser->priv->ongoing_part_lists, cancellable);\n\tg_mutex_unlock (&parser->priv->mutex);\n\tg_clear_object (&cancellable);\n\tg_string_free (part_id, TRUE);\n}", "target": 1}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static int ssd0323_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->cmd_len = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 8; i++)\n        s->cmd_data[i] = qemu_get_be32(f);\n    s->row = qemu_get_be32(f);\n    s->row_start = qemu_get_be32(f);\n    s->row_end = qemu_get_be32(f);\n    s->col = qemu_get_be32(f);\n    s->col_start = qemu_get_be32(f);\n    s->col_end = qemu_get_be32(f);\n    s->redraw = qemu_get_be32(f);\n    s->remap = qemu_get_be32(f);\n    s->mode = qemu_get_be32(f);\n    qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": " LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n \tif(!file) return 0;\n \tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n \t}\n\tretval = (int)tmpretval;\n \tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n \t}\n\topenmpt_free_string(str);\n\treturn retval;\n }", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n \tdefault:\n \t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "plan_a (char const *filename)\n{\n  char const *s;\n  char const *lim;\n  char const **ptr;\n  char *buffer;\n  lin iline;\n  size_t size = instat.st_size;\n  if (! (size == instat.st_size\n\t && (buffer = malloc (size ? size : (size_t) 1))))\n    return false;\n  if (size)\n     {\n       if (S_ISREG (instat.st_mode))\n         {\n\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);\n \t  size_t buffered = 0, n;\n \t  if (ifd < 0)\n \t    pfatal (\"can't open file %s\", quotearg (filename));\n\t\t  size = buffered;\n\t\t  break;\n\t\t}\n\t      if (n == (size_t) -1)\n\t\t{\n\t\t  close (ifd);\n\t\t  free (buffer);\n\t\t  return false;\n\t\t}\n\t      buffered += n;\n\t    }\n\t  if (close (ifd) != 0)\n\t    read_fatal ();\n\t}", "target": 1}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n \t\t\tstrcpy(buf, \"????\");\n \t\t\tbreak;\n \t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n \t\te = e->next;\n \t}\n \tline[strlen(line)-1] = 0; \n \treturn line;\n }", "target": 1}
{"code": " int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n {\n \tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n \t\t\tgoto unmap_pages;\n \t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n \treturn 0;\n unmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n \treturn r;\n }", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }", "target": 1}
{"code": "int X509_aux_print(BIO *out, X509 *x, int indent)\n{\n    char oidstr[80], first;\n    STACK_OF(ASN1_OBJECT) *trust, *reject;\n    const unsigned char *alias, *keyid;\n    int keyidlen;\n    int i;\n    if (X509_trusted(x) == 0)\n        return 1;\n    trust = X509_get0_trust_objects(x);\n    reject = X509_get0_reject_objects(x);\n    if (trust) {\n        first = 1;\n        BIO_printf(out, \"%*sTrusted Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(trust, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Trusted Uses.\\n\", indent, \"\");\n    if (reject) {\n        first = 1;\n        BIO_printf(out, \"%*sRejected Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(reject, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Rejected Uses.\\n\", indent, \"\");\n    alias = X509_alias_get0(x, NULL);\n    if (alias)\n        BIO_printf(out, \"%*sAlias: %s\\n\", indent, \"\", alias);\n    keyid = X509_keyid_get0(x, &keyidlen);\n    if (keyid) {\n        BIO_printf(out, \"%*sKey Id: \", indent, \"\");\n        for (i = 0; i < keyidlen; i++)\n            BIO_printf(out, \"%s%02X\", i ? \":\" : \"\", keyid[i]);\n        BIO_write(out, \"\\n\", 1);\n    }\n    return 1;\n}", "target": 1}
{"code": "static void addECSOption(char* packet, const size_t& packetSize, uint16_t* len, const ComboAddress& remote, int stamp)\n{\n  string EDNSRR;\n  struct dnsheader* dh = (struct dnsheader*) packet;\n  EDNSSubnetOpts eso;\n  if(stamp < 0)\n    eso.source = Netmask(remote);\n  else {\n    ComboAddress stamped(remote);\n    *((char*)&stamped.sin4.sin_addr.s_addr)=stamp;\n    eso.source = Netmask(stamped);\n  }\n  string optRData=makeEDNSSubnetOptsString(eso);\n  string record;\n  generateEDNSOption(EDNSOptionCode::ECS, optRData, record);\n  generateOptRR(record, EDNSRR);\n  uint16_t arcount = ntohs(dh->arcount);\n  if (packetSize - *len > EDNSRR.size()) {\n    arcount++;\n    dh->arcount = htons(arcount);\n    memcpy(packet + *len, EDNSRR.c_str(), EDNSRR.size());\n    *len += EDNSRR.size();\n  }\n}", "target": 1}
{"code": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}", "target": 1}
{"code": " status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"ProCamera2Client[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n    mFrameProcessor->dump(fd, args);\n return dumpDevice(fd, args);\n}", "target": 1}
{"code": "process_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "target": 1}
{"code": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \tBT_DBG(\"\");\n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdown_write(&bnep_session_sem);\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\ts = netdev_priv(dev);\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tbnep_set_default_proto_filter(s);\n#endif\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\t__bnep_link_session(s);\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}", "target": 1}
{"code": "bool GetURLRowForAutocompleteMatch(Profile* profile,\n                                   const AutocompleteMatch& match,\n                                   history::URLRow* url_row) {\n  DCHECK(url_row);\n  HistoryService* history_service =\n      profile->GetHistoryService(Profile::EXPLICIT_ACCESS);\n  if (!history_service)\n    return false;\n  history::URLDatabase* url_db = history_service->InMemoryDatabase();\n  return url_db && (url_db->GetRowForURL(match.destination_url, url_row) != 0);\n}", "target": 1}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n                     xmlEntityPtr ent, size_t replacement)\n{\n    size_t consumed = 0;\n    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n        return (0);\n    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n        return (1);\n    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t(ent->content != NULL) && (ent->checked == 0)) {\n\tunsigned long oldnbent = ctxt->nbentities;\n\txmlChar *rep;\n\tent->checked = 1;\n\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\tent->checked = (ctxt->nbentities - oldnbent + 1) * 2;\n\tif (rep != NULL) {\n\t    if (xmlStrchr(rep, '<'))\n\t\tent->checked |= 1;\n\t    xmlFree(rep);\n\t    rep = NULL;\n\t}\n    }\n    if (replacement != 0) {\n\tif (replacement < XML_MAX_TEXT_LENGTH)\n\t    return(0);\n        if (ctxt->input != NULL) {\n\t    consumed = ctxt->input->consumed +\n\t               (ctxt->input->cur - ctxt->input->base);\n\t}\n        consumed += ctxt->sizeentities;\n        if (replacement < XML_PARSER_NON_LINEAR * consumed)\n\t    return(0);\n    } else if (size != 0) {\n        if (size < XML_PARSER_BIG_ENTITY)\n\t    return(0);\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n\t    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n            return (0);\n    } else if (ent != NULL) {\n        size = ent->checked / 2;\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n            return (0);\n    } else {\n\tif (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&\n\t     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||\n\t    (ctxt->nbentities <= 10000))\n\t    return (0);\n    }\n    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n    return (1);\n}", "target": 1}
{"code": " header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n {\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n \t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n \t\t\treturn count ;\n \t\t\t} ;\n\t\tpsf->headend += count ;\n \t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n \treturn bytes ;\n } ", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n {\n\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }", "target": 1}
{"code": " static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n \t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n \t\trdesc[30] = 0x0c;\n \t}\n\treturn rdesc;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n  entry->seekable_stream=MagickTrue;\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 1}
{"code": "static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\t*status = 0;\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\tif (val >= 8)\t\t\t\t\n\t\t*status |= FE_HAS_LOCK;\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\treturn val;\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    FilePathValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n \tpch->ppp = NULL;\n \tpch->chan = chan;\n\tpch->chan_net = net;\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n \tkfree(priv->ctrl.fname);\n \tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n \tif (p->fname) {\n \t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n \t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n \t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n  if (stl->error) return;\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 1}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 1}
{"code": "LogFilePrep(const char *fname, const char *backup, const char *idstring)\n{\n    char *logFileName = NULL;\n    if (asprintf(&logFileName, fname, idstring) == -1)\n        FatalError(\"Cannot allocate space for the log file name\\n\");\n    if (backup && *backup) {\n        struct stat buf;\n        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {\n            char *suffix;\n            char *oldLog;\n            if ((asprintf(&suffix, backup, idstring) == -1) ||\n                (asprintf(&oldLog, \"%s%s\", logFileName, suffix) == -1)) {\n                FatalError(\"Cannot allocate space for the log file name\\n\");\n            }\n            free(suffix);\n            if (rename(logFileName, oldLog) == -1) {\n                FatalError(\"Cannot move old log file \\\"%s\\\" to \\\"%s\\\"\\n\",\n                           logFileName, oldLog);\n            }\n            free(oldLog);\n        }\n    }\n    else {\n        if (remove(logFileName) != 0 && errno != ENOENT) {\n            FatalError(\"Cannot remove old log file \\\"%s\\\": %s\\n\",\n                       logFileName, strerror(errno));\n        }\n    }\n    return logFileName;\n}", "target": 1}
{"code": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }", "target": 1}
{"code": "void AudioOutputSpeech::addFrameToBuffer(const QByteArray &qbaPacket, unsigned int iSeq) {\n\tQMutexLocker lock(&qmJitter);\n\tif (qbaPacket.size() < 2)\n\t\treturn;\n\tPacketDataStream pds(qbaPacket);\n\tpds.next();\n\tint samples = 0;\n\tif (umtType == MessageHandler::UDPVoiceOpus) {\n\t\tint size;\n\t\tpds >> size;\n\t\tsize &= 0x1fff;\n\t\tconst QByteArray &qba = pds.dataBlock(size);\n\t\tconst unsigned char *packet = reinterpret_cast<const unsigned char*>(qba.constData());\n#ifdef USE_OPUS\n\t\tint frames = opus_packet_get_nb_frames(packet, size);\n\t\tsamples = frames * opus_packet_get_samples_per_frame(packet, SAMPLE_RATE);\n#else\n\t\treturn;\n#endif\n\t\tQ_ASSERT(samples % iFrameSize == 0);\n\t} else {\n\t\tunsigned int header = 0;\n\t\tdo {\n\t\t\theader = static_cast<unsigned char>(pds.next());\n\t\t\tsamples += iFrameSize;\n\t\t\tpds.skip(header & 0x7f);\n\t\t} while ((header & 0x80) && pds.isValid());\n\t}\n\tif (pds.isValid()) {\n\t\tJitterBufferPacket jbp;\n\t\tjbp.data = const_cast<char *>(qbaPacket.constData());\n\t\tjbp.len = qbaPacket.size();\n\t\tjbp.span = samples;\n\t\tjbp.timestamp = iFrameSize * iSeq;\n#ifdef REPORT_JITTER\n\t\tif (g.s.bUsage && (umtType != MessageHandler::UDPVoiceSpeex) && p && ! p->qsHash.isEmpty() && (p->qlTiming.count() < 3000)) {\n\t\t\tQMutexLocker qml(& p->qmTiming);\n\t\t\tClientUser::JitterRecord jr;\n\t\t\tjr.iSequence = iSeq;\n\t\t\tjr.iFrames = frames;\n\t\t\tjr.uiElapsed = p->tTiming.restart();\n\t\t\tif (! p->qlTiming.isEmpty()) {\n\t\t\t\tjr.iFrames -= p->iFrames;\n\t\t\t\tjr.iSequence -= p->iSequence + p->iFrames;\n\t\t\t}\n\t\t\tp->iFrames = frames;\n\t\t\tp->iSequence = iSeq;\n\t\t\tp->qlTiming.append(jr);\n\t\t}\n#endif\n\t\tjitter_buffer_put(jbJitter, &jbp);\n\t}\n}", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int dwc3_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct property_entry *p = (struct property_entry *)id->driver_data;\n\tstruct dwc3_pci\t\t*dwc;\n\tstruct resource\t\tres[2];\n\tint\t\t\tret;\n\tstruct device\t\t*dev = &pci->dev;\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpci_set_master(pci);\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\tdwc->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!dwc->dwc3)\n\t\treturn -ENOMEM;\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= \"dwc_usb3\";\n\tres[0].flags\t= IORESOURCE_MEM;\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= \"dwc_usb3\";\n\tres[1].flags\t= IORESOURCE_IRQ;\n\tret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\tdwc->pci = pci;\n\tdwc->dwc3->dev.parent = dev;\n\tACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\n\tret = platform_device_add_properties(dwc->dwc3, p);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = dwc3_pci_quirks(dwc);\n\tif (ret)\n\t\tgoto err;\n\tret = platform_device_add(dwc->dwc3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\tdevice_init_wakeup(dev, true);\n\tpci_set_drvdata(pci, dwc);\n\tpm_runtime_put(dev);\n#ifdef CONFIG_PM\n\tINIT_WORK(&dwc->wakeup_work, dwc3_pci_resume_work);\n#endif\n\treturn 0;\nerr:\n\tplatform_device_put(dwc->dwc3);\n\treturn ret;\n}", "target": 1}
{"code": "void InputConnectionImpl::CommitText(const base::string16& text,\n                                     int new_cursor_pos) {\n  StartStateUpdateTimer();\n  std::string error;\n  if (!ime_engine_->ClearComposition(input_context_id_, &error))\n    LOG(ERROR) << \"ClearComposition failed: error=\\\"\" << error << \"\\\"\";\n  if (IsControlChar(text)) {\n    SendControlKeyEvent(text);\n    return;\n  }\n   if (!ime_engine_->CommitText(input_context_id_,\n                                base::UTF16ToUTF8(text).c_str(), &error))\n     LOG(ERROR) << \"CommitText failed: error=\\\"\" << error << \"\\\"\";\n }", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n\tassert(m->buf_);\n \tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0 || (!src->trueColor && bgcolor >= gdMaxColors)) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 1}
{"code": " bool HTMLFormElement::prepareForSubmission(Event* event)\n {\n     Frame* frame = document().frame();\n     if (m_isSubmittingOrPreparingForSubmission || !frame)\n         return m_isSubmittingOrPreparingForSubmission;\n    m_isSubmittingOrPreparingForSubmission = true;\n    m_shouldSubmit = false;\n    if (!validateInteractively(event)) {\n        m_isSubmittingOrPreparingForSubmission = false;\n        return false;\n    }\n    StringPairVector controlNamesAndValues;\n    getTextFieldValues(controlNamesAndValues);\n    RefPtr<FormState> formState = FormState::create(this, controlNamesAndValues, &document(), NotSubmittedByJavaScript);\n    frame->loader()->client()->dispatchWillSendSubmitEvent(formState.release());\n    if (dispatchEvent(Event::createCancelableBubble(eventNames().submitEvent)))\n        m_shouldSubmit = true;\n    m_isSubmittingOrPreparingForSubmission = false;\n    if (m_shouldSubmit)\n        submit(event, true, true, NotSubmittedByJavaScript);\n    return m_shouldSubmit;\n}", "target": 1}
{"code": "create_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n   cairo_surface_t *surface;\n  static cairo_user_data_key_t key;\n   int j;\n  cairo_pixels = (guchar *)g_malloc (4 * width * height);\n  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,\n\t\t\t\t\t\t CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, 4 * width);\n  cairo_surface_set_user_data (surface, &key,\n\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);\n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n#else\t  \n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n     }\n     data += rowstride;\n    cairo_pixels += 4 * width;\n   }\n   return surface;\n}", "target": 1}
{"code": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\tt->tcm_handle = f->handle;\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\trta->rta_len = skb->tail - b;\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}", "target": 1}
{"code": "walk_string(fz_context *ctx, int uni, int remove, editable_str *str)\n {\n        int rune;\n       if (str->utf8 == NULL)\n                return;\n        do\n\t{\n\t\tchar *s = &str->utf8[str->pos];\n\t\tsize_t len;\n\t\tint n = fz_chartorune(&rune, s);\n\t\tif (rune == uni)\n\t\t{\n\t\t\tstr->pos += n;\n\t\t}\n\t\telse if (uni == 32) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (rune == 32) {\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr->pos = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (remove)\n\t\t{\n\t\t\tlen = strlen(s+n);\n\t\t\tmemmove(s, s+n, len+1);\n\t\t\tstr->edited = 1;\n\t\t}\n\t}\n\twhile (rune != uni);\n}", "target": 1}
{"code": " crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n     crm_client_t *client = NULL;\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n     }\n     if (gid_cluster == 0) {\n        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n         }\n     }\n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; \n        if(uid_client == 0 || uid_server == 0) { \n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n         crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n     crm_client_init();\n    client = calloc(1, sizeof(crm_client_t));\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n    client->id = crm_generate_uuid();\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\tstring->space = 1;\n       else\n\tstring->space *= 2;\n      if (string->space < 0)\n \t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n \t}\n     }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct can_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n#define cgw_hops(skb) ((skb)->csum_start)\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\tif (cgw_hops(skb) >= max_hops) {\n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\tnskb->dev = gwj->dst.dev;\n\tcf = (struct can_frame *)nskb->data;\n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\tif (modidx) {\n\t\tif (gwj->mod.csumfunc.crc8)\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\t\tif (gwj->mod.csumfunc.xor)\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n}", "target": 1}
{"code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n    size_t maxBytesPerLine = 0;\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n    return maxBytesPerLine;\n}", "target": 1}
{"code": "   PowerPopupView() {\n     SetHorizontalAlignment(ALIGN_RIGHT);\n     UpdateText();\n   }", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n \tstruct sockaddr_llc sllc;\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n \tmemset(&sllc, 0, sizeof(sllc));\n \tlock_sock(sk);\n \tif (sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n \tif (peer) {\n \t\trc = -ENOTCONN;\n \t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\tndtmsg = NLMSG_DATA(nlh);\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\nnlmsg_failure:\n\treturn -1;\n}", "target": 1}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n     }\n }", "target": 1}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){\n  char *zText = 0;\n  RtreeNode node;\n  Rtree tree;\n  int ii;\n  UNUSED_PARAMETER(nArg);\n  memset(&node, 0, sizeof(RtreeNode));\n  memset(&tree, 0, sizeof(Rtree));\n  tree.nDim = (u8)sqlite3_value_int(apArg[0]);\n  tree.nDim2 = tree.nDim*2;\n  tree.nBytesPerCell = 8 + 8 * tree.nDim;\n  node.zData = (u8 *)sqlite3_value_blob(apArg[1]);\n  for(ii=0; ii<NCELL(&node); ii++){\n    char zCell[512];\n    int nCell = 0;\n    RtreeCell cell;\n    int jj;\n    nodeGetCell(&tree, &node, ii, &cell);\n    sqlite3_snprintf(512-nCell,&zCell[nCell],\"%lld\", cell.iRowid);\n    nCell = (int)strlen(zCell);\n    for(jj=0; jj<tree.nDim2; jj++){\n#ifndef SQLITE_RTREE_INT_ONLY\n      sqlite3_snprintf(512-nCell,&zCell[nCell], \" %g\",\n                       (double)cell.aCoord[jj].f);\n#else\n      sqlite3_snprintf(512-nCell,&zCell[nCell], \" %d\",\n                       cell.aCoord[jj].i);\n#endif\n      nCell = (int)strlen(zCell);\n    }\n    if( zText ){\n      char *zTextNew = sqlite3_mprintf(\"%s {%s}\", zText, zCell);\n      sqlite3_free(zText);\n      zText = zTextNew;\n    }else{\n      zText = sqlite3_mprintf(\"{%s}\", zCell);\n    }\n  }\n  sqlite3_result_text(ctx, zText, -1, sqlite3_free);\n}", "target": 1}
{"code": "crypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc;\n    char *cp;\n    struct crypt_data data;\n    data.initialized = 0;\n    cp = crypt_r(userpwd, dbpwd, &data);\n    if (cp) {\n        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n    } else {\n        rc = -1;\n    }\n    return rc;\n}", "target": 1}
{"code": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n \tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\tJAS_DBGLOG(100, (\"jas_image_readcmpt(%p, %d, %ld, %ld, %ld, %ld, %p)\\n\",\n\t  image, cmptno, JAS_CAST(long, x), JAS_CAST(long, y),\n\t  JAS_CAST(long, width), JAS_CAST(long, height), data));\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n \t\t\ts->append_char(s, c);\n \t\t}\n \t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n }", "target": 1}
{"code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }", "target": 1}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "  Compound_Selector_Ptr Simple_Selector::unify_with(Compound_Selector_Ptr rhs)\n  {\n    for (size_t i = 0, L = rhs->length(); i < L; ++i)\n    { if (to_string() == rhs->at(i)->to_string()) return rhs; }\n    size_t i, L;\n    bool found = false;\n    if (typeid(*this) == typeid(Pseudo_Selector) || typeid(*this) == typeid(Wrapped_Selector))\n    {\n      for (i = 0, L = rhs->length(); i < L; ++i)\n      {\n        if ((Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i])) && (*rhs)[L-1]->is_pseudo_element())\n        { found = true; break; }\n      }\n    }\n    else\n    {\n      for (i = 0, L = rhs->length(); i < L; ++i)\n      {\n        if (Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i]))\n        { found = true; break; }\n      }\n    }\n    if (!found)\n    {\n      rhs->append(this);\n      return rhs;\n    }\n    rhs->elements().insert(rhs->elements().begin() + i, this);\n    return rhs;\n  }", "target": 1}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void imap_parser_save_arg(struct imap_parser *parser,\n\t\t\t\t const unsigned char *data, size_t size)\n{\n\tstruct imap_arg *arg;\n\tchar *str;\n\targ = imap_arg_create(parser);\n\tswitch (parser->cur_type) {\n\tcase ARG_PARSE_ATOM:\n\tcase ARG_PARSE_TEXT:\n\t\tif (size == 3 && i_memcasecmp(data, \"NIL\", 3) == 0) {\n\t\t\targ->type = IMAP_ARG_NIL;\n\t\t} else {\n\t\t\targ->type = IMAP_ARG_ATOM;\n\t\t}\n\t\targ->_data.str = imap_parser_strdup(parser, data, size);\n\t\targ->str_len = size;\n\t\tbreak;\n\tcase ARG_PARSE_STRING:\n\t\ti_assert(size > 0);\n\t\targ->type = IMAP_ARG_STRING;\n\t\tstr = p_strndup(parser->pool, data+1, size-1);\n\t\tif (parser->str_first_escape >= 0 &&\n\t\t    (parser->flags & IMAP_PARSE_FLAG_NO_UNESCAPE) == 0) {\n\t\t\t(void)str_unescape(str + parser->str_first_escape-1);\n\t\t}\n\t\targ->_data.str = str;\n\t\targ->str_len = strlen(str);\n\t\tbreak;\n\tcase ARG_PARSE_LITERAL_DATA:\n\t\tif ((parser->flags & IMAP_PARSE_FLAG_LITERAL_SIZE) != 0) {\n\t\t\targ->type = parser->literal_nonsync ?\n\t\t\t\tIMAP_ARG_LITERAL_SIZE_NONSYNC :\n\t\t\t\tIMAP_ARG_LITERAL_SIZE;\n\t\t\targ->_data.literal_size = parser->literal_size;\n\t\t\targ->literal8 = parser->literal8;\n\t\t\tbreak;\n\t\t}\n\tcase ARG_PARSE_LITERAL_DATA_FORCED:\n\t\tif ((parser->flags & IMAP_PARSE_FLAG_LITERAL_TYPE) != 0)\n\t\t\targ->type = IMAP_ARG_LITERAL;\n\t\telse\n\t\t\targ->type = IMAP_ARG_STRING;\n\t\targ->_data.str = imap_parser_strdup(parser, data, size);\n\t\targ->literal8 = parser->literal8;\n\t\targ->str_len = size;\n\t\tbreak;\n\tdefault:\n                i_unreached();\n\t}\n\tparser->cur_type = ARG_PARSE_NONE;\n}", "target": 1}
{"code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}", "target": 1}
{"code": "static int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT |\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tif ((bit_max >> 3) >= bh->b_size)\n\t\treturn -EFSCORRUPTED;\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\tstart = ext4_group_first_block_no(sb, block_group);\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tflex_bg = 1;\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\treturn 0;\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 1000) \n    throw MOADNSException(\"Loop\");\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= frompos-2)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n  }\n}", "target": 1}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n   mrb_get_args(mrb, \"o\", &orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n    return NULL;\n}", "target": 1}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\tsnd_timer_stop(timeri);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}", "target": 1}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error = TT_Err_Ok;\n     FT_UNUSED( error );\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n        if ( runcnt < 1 )\n           goto Exit;\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n        if ( runcnt < 1 )\n           goto Exit;\n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n  Exit:\n    return points;\n  }", "target": 1}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static void SVGStripString(const MagickBooleanType trim,char *message)\n{\n  register char\n    *p,\n    *q;\n  size_t\n    length;\n  assert(message != (char *) NULL);\n  if (*message == '\\0')\n    return;\n  q=message;\n  for (p=message; *p != '\\0'; p++)\n  {\n    if ((*p == '/') && (*(p+1) == '*'))\n      {\n        for ( ; *p != '\\0'; p++)\n          if ((*p == '*') && (*(p+1) == '/'))\n            break;\n        if (*p == '\\0')\n          break;\n        p+=2;\n      }\n    *q++=(*p);\n  }\n  *q='\\0';\n  if (trim != MagickFalse)\n    {\n      length=strlen(message);\n      p=message;\n      while (isspace((int) ((unsigned char) *p)) != 0)\n        p++;\n      if ((*p == '\\'') || (*p == '\"'))\n        p++;\n      q=message+length-1;\n      while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n        q--;\n      if (q > p)\n        if ((*q == '\\'') || (*q == '\"'))\n          q--;\n      (void) memmove(message,p,(size_t) (q-p+1));\n      message[q-p+1]='\\0';\n    }\n  for (p=message; *p != '\\0'; p++)\n    if (*p == '\\n')\n      *p=' ';\n}", "target": 1}
{"code": "ext4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\ti = depth;\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\text4_ext_binsearch(inode, path + ppos, block);\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\text4_ext_show_path(inode, path);\n\treturn path;\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "gxps_archive_input_stream_read (GInputStream  *stream,\n\t\t\t\tvoid          *buffer,\n\t\t\t\tgsize          count,\n\t\t\t\tGCancellable  *cancellable,\n\t\t\t\tGError       **error)\n{\n\tGXPSArchiveInputStream *istream = GXPS_ARCHIVE_INPUT_STREAM (stream);\n        gssize                  bytes_read;\n\tif (g_cancellable_set_error_if_cancelled (cancellable, error))\n\t\treturn -1;\n        bytes_read = archive_read_data (istream->zip->archive, buffer, count);\n        if (bytes_read == 0 && istream->is_interleaved && !gxps_archive_input_stream_is_last_piece (istream)) {\n                gxps_archive_input_stream_next_piece (istream);\n                bytes_read = gxps_archive_input_stream_read (stream, buffer, count, cancellable, error);\n        }\n\treturn bytes_read;\n}", "target": 1}
{"code": "mysqlnd_switch_to_ssl_if_needed(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC\n\t\t)\n{\n\tenum_func_status ret = FAIL;\n\tconst MYSQLND_CHARSET * charset;\n\tMYSQLND_PACKET_AUTH * auth_packet;\n\tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");\n\tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);\n\tif (!auth_packet) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tgoto end;\n\t}\n\tauth_packet->client_flags = mysql_flags;\n\tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;\n\tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {\n\t\tauth_packet->charset_no\t= charset->nr;\n\t} else {\n#if MYSQLND_UNICODE\n\t\tauth_packet->charset_no\t= 200;\n#else\n\t\tauth_packet->charset_no\t= greet_packet->charset_no;\n#endif\n        }\n #ifdef MYSQLND_SSL_SUPPORTED\n       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {\n               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n               DBG_INF(\"Switching to SSL\");\n               if (!PACKET_WRITE(auth_packet, conn)) {\n                       CONN_SET_STATE(conn, CONN_QUIT_SENT);\n                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n                       goto end;\n               }\n               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n                       goto end;\n                }\n        }\n #endif\n        ret = PASS;\n end:\n        PACKET_FREE(auth_packet);\n        DBG_RETURN(ret);\n }", "target": 1}
{"code": " int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "parse_key_usage (PKT_signature * sig)\n{\n  int key_usage = 0;\n  const byte *p;\n  size_t n;\n  byte flags;\n  p = parse_sig_subpkt (sig->hashed, SIGSUBPKT_KEY_FLAGS, &n);\n  if (p && n)\n    {\n      flags = *p;\n      if (flags & 1)\n\t{\n\t  key_usage |= PUBKEY_USAGE_CERT;\n\t  flags &= ~1;\n\t}\n      if (flags & 2)\n\t{\n\t  key_usage |= PUBKEY_USAGE_SIG;\n\t  flags &= ~2;\n\t}\n      if (flags & (0x04 | 0x08))\n\t{\n\t  key_usage |= PUBKEY_USAGE_ENC;\n\t  flags &= ~(0x04 | 0x08);\n\t}\n      if (flags & 0x20)\n\t{\n\t  key_usage |= PUBKEY_USAGE_AUTH;\n\t  flags &= ~0x20;\n\t}\n      if (flags)\n\tkey_usage |= PUBKEY_USAGE_UNKNOWN;\n    }\n  return key_usage;\n}", "target": 1}
{"code": "void SystemClipboard::WriteImage(Image* image,\n                                 const KURL& url,\n                                 const String& title) {\n  DCHECK(image);\n  PaintImage paint_image = image->PaintImageForCurrentFrame();\n  SkBitmap bitmap;\n  if (sk_sp<SkImage> sk_image = paint_image.GetSkImage())\n    sk_image->asLegacyBitmap(&bitmap);\n   if (bitmap.isNull())\n     return;\n  if (!bitmap.getPixels())\n    return;\n   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);\n  if (url.IsValid() && !url.IsEmpty()) {\n#if !defined(OS_MACOSX)\n    clipboard_->WriteBookmark(mojom::ClipboardBuffer::kStandard,\n                              url.GetString(), NonNullString(title));\n#endif\n    clipboard_->WriteHtml(mojom::ClipboardBuffer::kStandard,\n                          URLToImageMarkup(url, title), KURL());\n  }\n  clipboard_->CommitWrite(mojom::ClipboardBuffer::kStandard);\n}", "target": 1}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n \tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int kernel_read_file(struct file *file, void **buf, loff_t *size,\n\t\t     loff_t max_size, enum kernel_read_file_id id)\n{\n\tloff_t i_size, pos;\n\tssize_t bytes = 0;\n\tint ret;\n\tif (!S_ISREG(file_inode(file)->i_mode) || max_size < 0)\n\t\treturn -EINVAL;\n\tret = deny_write_access(file);\n\tif (ret)\n\t\treturn ret;\n\tret = security_kernel_read_file(file, id);\n\tif (ret)\n\t\tgoto out;\n\ti_size = i_size_read(file_inode(file));\n\tif (i_size <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (i_size > SIZE_MAX || (max_size > 0 && i_size > max_size)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\tif (id != READING_FIRMWARE_PREALLOC_BUFFER)\n\t\t*buf = vmalloc(i_size);\n\tif (!*buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpos = 0;\n\twhile (pos < i_size) {\n\t\tbytes = kernel_read(file, *buf + pos, i_size - pos, &pos);\n\t\tif (bytes < 0) {\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t}\n\tif (pos != i_size) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tret = security_kernel_post_read_file(file, *buf, i_size, id);\n\tif (!ret)\n\t\t*size = pos;\nout_free:\n\tif (ret < 0) {\n\t\tif (id != READING_FIRMWARE_PREALLOC_BUFFER) {\n\t\t\tvfree(*buf);\n\t\t\t*buf = NULL;\n\t\t}\n\t}\nout:\n\tallow_write_access(file);\n\treturn ret;\n}", "target": 1}
{"code": "nextvar(\n\tint *datalen,\n\tconst char **datap,\n\tchar **vname,\n\tchar **vvalue\n\t)\n{\n\tconst char *cp;\n\tconst char *np;\n\tconst char *cpend;\n\tsize_t srclen;\n\tsize_t len;\n\tstatic char name[MAXVARLEN];\n\tstatic char value[MAXVALLEN];\n\tcp = *datap;\n\tcpend = cp + *datalen;\n\twhile (cp < cpend && (*cp == ',' || isspace((int)*cp)))\n\t\tcp++;\n\tif (cp >= cpend)\n\t\treturn 0;\n\tsrclen = strcspn(cp, \",=\\r\\n\");\n\tsrclen = min(srclen, (size_t)(cpend - cp));\n\tlen = srclen;\n\twhile (len > 0 && isspace((unsigned char)cp[len - 1]))\n\t\tlen--;\n\tif (len > 0)\n\t\tmemcpy(name, cp, len);\n\tname[len] = '\\0';\n\t*vname = name;\n\tcp += srclen;\n\tif (cp >= cpend || *cp == ',' || *cp == '\\r' || *cp == '\\n') {\n\t\tif (cp < cpend)\n\t\t\tcp++;\n\t\t*datap = cp;\n\t\t*datalen = cpend - cp;\n\t\t*vvalue = NULL;\n\t\treturn 1;\n\t}\n\tcp++;\t\n\twhile (cp < cpend && (isspace((unsigned char)*cp) && *cp != '\\r' && *cp != '\\n'))\n\t\tcp++;\n\tnp = cp;\n\tif ('\"' == *np) {\n\t\tdo {\n\t\t\tnp++;\n\t\t} while (np < cpend && '\"' != *np);\n\t\tif (np < cpend && '\"' == *np)\n\t\t\tnp++;\n\t} else {\n\t\twhile (np < cpend && ',' != *np && '\\r' != *np)\n\t\t\tnp++;\n\t}\n\tlen = np - cp;\n\tif (np > cpend || len >= sizeof(value) ||\n\t    (np < cpend && ',' != *np && '\\r' != *np))\n\t\treturn 0;\n\tmemcpy(value, cp, len);\n\twhile (len > 0 && isspace((unsigned char)value[len - 1]))\n\t\tlen--;\n\tvalue[len] = '\\0';\n\tif (np < cpend && ',' == *np)\n\t\tnp++;\n\t*datap = np;\n\t*datalen = cpend - np;\n\t*vvalue = value;\n\treturn 1;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; \n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n     state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }", "target": 1}
{"code": "MagickExport Image *ReadStream(const ImageInfo *image_info,StreamHandler stream,\n  ExceptionInfo *exception)\n{\n  CacheMethods\n    cache_methods;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  read_info=CloneImageInfo(image_info);\n  read_info->cache=AcquirePixelCache(0);\n  GetPixelCacheMethods(&cache_methods);\n  cache_methods.get_virtual_pixel_handler=GetVirtualPixelStream;\n  cache_methods.get_virtual_pixels_handler=GetVirtualPixelsStream;\n  cache_methods.get_virtual_metacontent_from_handler=\n    GetVirtualMetacontentFromStream;\n  cache_methods.get_authentic_pixels_handler=GetAuthenticPixelsStream;\n  cache_methods.queue_authentic_pixels_handler=QueueAuthenticPixelsStream;\n  cache_methods.sync_authentic_pixels_handler=SyncAuthenticPixelsStream;\n  cache_methods.get_authentic_pixels_from_handler=GetAuthenticPixelsFromStream;\n  cache_methods.get_authentic_metacontent_from_handler=\n    GetAuthenticMetacontentFromStream;\n  cache_methods.get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromStream;\n  cache_methods.get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromStream;\n  cache_methods.destroy_pixel_handler=DestroyPixelStream;\n  SetPixelCacheMethods(read_info->cache,&cache_methods);\n  read_info->stream=stream;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    InitializePixelChannelMap(image);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}", "target": 1}
{"code": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n    *pmaskHash = NULL;\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n    if (!pss)\n        return NULL;\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n    return pss;\n}", "target": 1}
{"code": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n \tmscfs_check_cache(priv->fs);\n \tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; \n \t\t\tbuf += 2;\n\t\t\tcount+=2;\n \t\t}\n \t}\n \treturn count;\n}", "target": 1}
{"code": "static int __init atalk_init(void)\n{\n\tint rc;\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}", "target": 1}
{"code": "sp<ABuffer> decodeBase64(const AString &s) {\n size_t n = s.size();\n if ((n % 4) != 0) {\n return NULL;\n }\n size_t padding = 0;\n if (n >= 1 && s.c_str()[n - 1] == '=') {\n        padding = 1;\n if (n >= 2 && s.c_str()[n - 2] == '=') {\n            padding = 2;\n if (n >= 3 && s.c_str()[n - 3] == '=') {\n                padding = 3;\n }\n }\n }\n size_t outLen = (n / 4) * 3 - padding;\n    sp<ABuffer> buffer = new ABuffer(outLen);\n uint8_t *out = buffer->data();\n if (out == NULL || buffer->size() < outLen) {\n return NULL;\n }\n size_t j = 0;\n uint32_t accum = 0;\n for (size_t i = 0; i < n; ++i) {\n char c = s.c_str()[i];\n unsigned value;\n if (c >= 'A' && c <= 'Z') {\n            value = c - 'A';\n } else if (c >= 'a' && c <= 'z') {\n            value = 26 + c - 'a';\n } else if (c >= '0' && c <= '9') {\n            value = 52 + c - '0';\n } else if (c == '+') {\n            value = 62;\n } else if (c == '/') {\n            value = 63;\n } else if (c != '=') {\n return NULL;\n } else {\n if (i < n - padding) {\n return NULL;\n }\n            value = 0;\n }\n         accum = (accum << 6) | value;\n         if (((i + 1) % 4) == 0) {\n            out[j++] = (accum >> 16);\n             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }\n             if (j < outLen) { out[j++] = accum & 0xff; }\n            accum = 0;\n }\n }\n return buffer;\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n\tchar *p = src + src_prefix_len + 1;\n\tchar *q = dst + dst_prefix_len + 1;\n\tchar *r = dst + dst_prefix_len;\n\tstruct stat s;\n\tbool last = false;\n\t*r = '\\0';\n\tfor (; !last; p++, q++) {\n\t\tif (*p == '\\0') {\n\t\t\tlast = true;\n\t\t}\n\t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n\t\t\t*p = '\\0';\n\t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n\t\t\t\t*q = '\\0';\n\t\t\t\t*r = '/';\n\t\t\t\tr = q;\n\t\t\t\tmkdir_attr(dst, s.st_mode, 0, 0);\n\t\t\t}\n\t\t\tif (!last) {\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n \t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n \t\t\t\t\t   &xattr_data,\n \t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n \t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n \treturn rc;\n }", "target": 1}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "ChunkedDecode(Request *reqPtr, bool update)\n{\n    const Tcl_DString *bufPtr;\n    const char        *end, *chunkStart;\n    bool              success = NS_TRUE;\n    NS_NONNULL_ASSERT(reqPtr != NULL);\n    bufPtr = &reqPtr->buffer;\n    end = bufPtr->string + bufPtr->length;\n    chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n    while (reqPtr->chunkStartOff <  (size_t)bufPtr->length) {\n        char   *p = strstr(chunkStart, \"\\r\\n\");\n        size_t  chunk_length;\n        if (p == NULL) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk did not find end-of-line\");\n            success = NS_FALSE;\n            break;\n        }\n        *p = '\\0';\n        chunk_length = (size_t)strtol(chunkStart, NULL, 16);\n        *p = '\\r';\n        if (p + 2 + chunk_length > end) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk length past end of buffer\");\n            success = NS_FALSE;\n            break;\n        }\n        if (update) {\n            char *writeBuffer = bufPtr->string + reqPtr->chunkWriteOff;\n            memmove(writeBuffer, p + 2, chunk_length);\n            reqPtr->chunkWriteOff += chunk_length;\n            *(writeBuffer + chunk_length) = '\\0';\n        }\n        reqPtr->chunkStartOff += (size_t)(p - chunkStart) + 4u + chunk_length;\n        chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n    }\n    return success;\n}", "target": 1}
{"code": "static CURLcode tftp_connect(struct connectdata *conn, bool *done)\n{\n  tftp_state_data_t *state;\n  int blksize;\n  blksize = TFTP_BLKSIZE_DEFAULT;\n  state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));\n  if(!state)\n    return CURLE_OUT_OF_MEMORY;\n  if(conn->data->set.tftp_blksize) {\n    blksize = (int)conn->data->set.tftp_blksize;\n    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)\n      return CURLE_TFTP_ILLEGAL;\n  }\n  if(!state->rpacket.data) {\n    state->rpacket.data = calloc(1, blksize + 2 + 2);\n    if(!state->rpacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  if(!state->spacket.data) {\n    state->spacket.data = calloc(1, blksize + 2 + 2);\n    if(!state->spacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  connclose(conn, \"TFTP\");\n  state->conn = conn;\n  state->sockfd = state->conn->sock[FIRSTSOCKET];\n  state->state = TFTP_STATE_START;\n  state->error = TFTP_ERR_NONE;\n  state->blksize = blksize;\n  state->requested_blksize = blksize;\n  ((struct sockaddr *)&state->local_addr)->sa_family =\n    (CURL_SA_FAMILY_T)(conn->ip_addr->ai_family);\n  tftp_set_timeouts(state);\n  if(!conn->bits.bound) {\n    int rc = bind(state->sockfd, (struct sockaddr *)&state->local_addr,\n                  conn->ip_addr->ai_addrlen);\n    if(rc) {\n      char buffer[STRERROR_LEN];\n      failf(conn->data, \"bind() failed; %s\",\n            Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n      return CURLE_COULDNT_CONNECT;\n    }\n    conn->bits.bound = TRUE;\n  }\n  Curl_pgrsStartNow(conn->data);\n  *done = TRUE;\n  return CURLE_OK;\n}", "target": 1}
{"code": " void DevToolsWindow::InspectedContentsClosing() {\n   web_contents_->GetRenderViewHost()->ClosePage();\n }", "target": 1}
{"code": "nsPluginInstance::setupCookies(const std::string& pageurl)\n{\n    std::string::size_type pos;\n    pos = pageurl.find(\"/\", pageurl.find(\"\n    std::string url = pageurl.substr(0, pos);\n    std::string ncookie;\n    char *cookie = 0;\n    uint32_t length = 0;\n    NPError rv = NPERR_GENERIC_ERROR;\n#if NPAPI_VERSION != 190\n    if (NPNFuncs.getvalueforurl) {\n        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),\n                                &cookie, &length);\n    } else {\n        LOG_ONCE( gnash::log_debug(\"Browser doesn't support getvalueforurl\") );\n    }\n#endif\n    if (rv == NPERR_GENERIC_ERROR) {\n        log_debug(\"Trying window.document.cookie for cookies\");\n        ncookie = getDocumentProp(\"cookie\");\n    }\n    if (cookie) {\n        ncookie.assign(cookie, length);\n        NPN_MemFree(cookie);\n    }\n    if (ncookie.empty()) {\n        gnash::log_debug(\"No stored Cookie for %s\", url);\n        return;\n    }\n    gnash::log_debug(\"The Cookie for %s is %s\", url, ncookie);\n    std::ofstream cookiefile;\n    std::stringstream ss;\n     ss << \"/tmp/gnash-cookies.\" << getpid();\n     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);\n    typedef boost::char_separator<char> char_sep;\n    typedef boost::tokenizer<char_sep> tokenizer;\n    tokenizer tok(ncookie, char_sep(\";\"));\n    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {\n        cookiefile << \"Set-Cookie: \" << *it << std::endl;\n    }\n    cookiefile.close();\n    if (setenv(\"GNASH_COOKIES_IN\", ss.str().c_str(), 1) < 0) {\n        gnash::log_error(\n            \"Couldn't set environment variable GNASH_COOKIES_IN to %s\",\n            ncookie);\n    }\n}", "target": 1}
{"code": "php_stream *php_stream_zip_opener(php_stream_wrapper *wrapper,\n\t\t\t\t\t\t\t\t\t\t\tchar *path,\n\t\t\t\t\t\t\t\t\t\t\tchar *mode,\n\t\t\t\t\t\t\t\t\t\t\tint options,\n                                                                                        char **opened_path,\n                                                                                        php_stream_context *context STREAMS_DC TSRMLS_DC)\n {\n       int path_len;\n        char *file_basename;\n        size_t file_basename_len;\n\tchar file_dirname[MAXPATHLEN];\n        struct zip *za;\n        struct zip_file *zf = NULL;\n        char *fragment;\n       int fragment_len;\n        int err;\n        php_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tfragment = strchr(path, '#');\n\tif (!fragment) {\n\t\treturn NULL;\n\t}\n\tif (strncasecmp(\"zip:\n\t\tpath += 6;\n\t}\n\tfragment_len = strlen(fragment);\n\tif (fragment_len < 1) {\n\t\treturn NULL;\n\t}\n\tpath_len = strlen(path);\n\tif (path_len >= MAXPATHLEN || mode[0] != 'r') {\n\t\treturn NULL;\n\t}\n\tmemcpy(file_dirname, path, path_len - fragment_len);\n\tfile_dirname[path_len - fragment_len] = '\\0';\n\tphp_basename(path, path_len - fragment_len, NULL, 0, &file_basename, &file_basename_len TSRMLS_CC);\n\tfragment++;\n\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname)) {\n\t\tefree(file_basename);\n\t\treturn NULL;\n\t}\n\tza = zip_open(file_dirname, ZIP_CREATE, &err);\n\tif (za) {\n\t\tzf = zip_fopen(za, fragment, 0);\n\t\tif (zf) {\n                        self = emalloc(sizeof(*self));\n                        self->za = za;\n                       self->zf = zf; \n                        self->stream = NULL;\n                        self->cursor = 0;\n                        stream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tif (opened_path) {\n\t\t\t\t*opened_path = estrdup(path);\n\t\t\t}\n\t\t} else {\n\t\t\tzip_close(za);\n\t\t}\n\t}\n\tefree(file_basename);\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n}", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n {\n \tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}", "target": 1}
{"code": "ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress)\n{\n\tObjectAddress address;\n\tObjectAddress refAddr;\n\tRelation\trel;\n\taddress =\n\t\tget_object_address_rv(stmt->objectType, stmt->relation, (List *) stmt->object,\n\t\t\t\t\t\t\t  &rel, AccessExclusiveLock, false);\n\tif (rel)\n\t\ttable_close(rel, NoLock);\n\trefAddr = get_object_address(OBJECT_EXTENSION, (Node *) stmt->extname,\n\t\t\t\t\t\t\t\t &rel, AccessExclusiveLock, false);\n\tAssert(rel == NULL);\n\tif (refAddress)\n\t\t*refAddress = refAddr;\n\trecordDependencyOn(&address, &refAddr, DEPENDENCY_AUTO_EXTENSION);\n\treturn address;\n}", "target": 1}
{"code": "SPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\tif (length <= 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n \t\tRETURN_FALSE;\n \t}\n \tZ_STRVAL_P(return_value) = emalloc(length + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tunsigned long h;\n\tconst unsigned char *p;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (p = id->name; *p; p++)\n\t\th = MULTIPLIER * h + *p;\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 1}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}", "target": 1}
{"code": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}", "target": 1}
{"code": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n \t}\n \treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n \tRETVAL_STRINGL(replaced, (int)new_len, 0);\n }", "target": 1}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "bool ParseVP9SuperFrameIndex(const std::uint8_t* frame,\n                             std::size_t frame_length, Ranges* frame_ranges) {\n  if (frame == nullptr || frame_length == 0 || frame_ranges == nullptr)\n    return false;\n  bool parse_ok = false;\n  const std::uint8_t marker = frame[frame_length - 1];\n  const std::uint32_t kHasSuperFrameIndexMask = 0xe0;\n  const std::uint32_t kSuperFrameMarker = 0xc0;\n  const std::uint32_t kLengthFieldSizeMask = 0x3;\n  if ((marker & kHasSuperFrameIndexMask) == kSuperFrameMarker) {\n    const std::uint32_t kFrameCountMask = 0x7;\n    const int num_frames = (marker & kFrameCountMask) + 1;\n    const int length_field_size = ((marker >> 3) & kLengthFieldSizeMask) + 1;\n    const std::size_t index_length = 2 + length_field_size * num_frames;\n    if (frame_length < index_length) {\n      std::fprintf(stderr, \"VP9Parse: Invalid superframe index size.\\n\");\n      return false;\n    }\n    const std::size_t length = frame_length - index_length;\n    if (length >= index_length &&\n        frame[frame_length - index_length] == marker) {\n      const std::uint8_t* byte = frame + length + 1;\n      std::size_t frame_offset = 0;\n      for (int i = 0; i < num_frames; ++i) {\n        std::uint32_t child_frame_length = 0;\n        for (int j = 0; j < length_field_size; ++j) {\n          child_frame_length |= (*byte++) << (j * 8);\n        }\n        frame_ranges->push_back(Range(frame_offset, child_frame_length));\n        frame_offset += child_frame_length;\n      }\n      if (static_cast<int>(frame_ranges->size()) != num_frames) {\n        std::fprintf(stderr, \"VP9Parse: superframe index parse failed.\\n\");\n        return false;\n      }\n      parse_ok = true;\n    } else {\n      std::fprintf(stderr, \"VP9Parse: Invalid superframe index.\\n\");\n    }\n  }\n  return parse_ok;\n}", "target": 1}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n \tlsa->l2tp_family = AF_INET6;\n \tlsa->l2tp_flowinfo = 0;\n \tlsa->l2tp_scope_id = 0;\n \tif (peer) {\n \t\tif (!lsk->peer_conn_id)\n \t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 1}
{"code": " static int uas_switch_interface(struct usb_device *udev,\n \t\t\t\tstruct usb_interface *intf)\n {\n\tint alt;\n \talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n }", "target": 1}
{"code": "void RateTransposer::setChannels(int nChannels)\n{\n    assert(nChannels > 0);\n    if (pTransposer->numChannels == nChannels) return;\n    pTransposer->setChannels(nChannels);\n    inputBuffer.setChannels(nChannels);\n    midBuffer.setChannels(nChannels);\n    outputBuffer.setChannels(nChannels);\n}", "target": 1}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n error:\n\treturn keyring;\n} ", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n \tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n \t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n \t\t\t\treturn -EINVAL;\n \t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n \t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n \treturn 0;\n }", "target": 1}
{"code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\tklass = method->klass;\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1}
{"code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}", "target": 1}
{"code": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}", "target": 1}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 1}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n \t\treturn ret;\n \t}\n \tread_lock(&tasklist_lock);\n \tif (pid != -1) {\n \t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n \t}\n \treturn 0;\n}", "target": 1}
{"code": "static int parse_line(char *str)\n{\n\tuint8_t array[256];\n\tuint16_t value, pskey, length = 0;\n\tchar *off, *end;\n\tpskey = strtol(str + 1, NULL, 16);\n\toff = strstr(str, \"=\");\n\tif (!off)\n\t\treturn -EIO;\n\toff++;\n\twhile (1) {\n\t\tvalue = strtol(off, &end, 16);\n\t\tif (value == 0 && off == end)\n\t\t\tbreak;\n\t\tarray[length++] = value & 0xff;\n\t\tarray[length++] = value >> 8;\n\t\tif (*end == '\\0')\n\t\t\tbreak;\n\t\toff = end + 1;\n\t}\n\treturn psr_put(pskey, array, length);\n}", "target": 1}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": " static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n {\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n \tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n \t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}", "target": 1}
{"code": "static void ssl_write_renegotiation_ext( ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renegotiation != SSL_RENEGOTIATION )\n        return;\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( (size_t)(end - p) < 5 + ssl->verify_data_len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 1}
{"code": "jio_snprintf(char * str, int n, const char * format, ...)\n{\n\tva_list args;\n\tint result;\n\tTrc_SC_snprintf_Entry();\n\tva_start(args, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else\n\tresult = vsprintf( str, format, args );\n#endif\n\tva_end(args);\n\tTrc_SC_snprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n\tif (2 == cipher_len)\n \t\treturn -1;\n \tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}", "target": 1}
{"code": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1); \n }\n return true;\n}", "target": 1}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 1}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n \tif (unlikely(file->f_flags & __O_TMPFILE)) {\n \t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n \t}\n \terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n \t}\n out:\n \tpath_cleanup(nd);\n \tif (!(opened & FILE_OPENED)) {\n \t\tBUG_ON(!error);\n \t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n \tstruct proc_maps_private *priv = m->private;\n \tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n \tif (priv->task)\n \t\tput_task_struct(priv->task);\n }", "target": 1}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}", "target": 1}
{"code": "cif_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\tint line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int lnum;\n        byte *in = (byte *)gs_malloc(pdev->memory, line_size, 1, \"cif_print_page(in)\");\n        char *s;\n        int scanline, scanbyte;\n        int length, start; \n        if (in == 0)\n                return_error(gs_error_VMerror);\n        if ((s = strchr(pdev->fname, '.')) == NULL)\n                length = strlen(pdev->fname) + 1;\n        else\n                length = s - pdev->fname;\n        s = (char *)gs_malloc(pdev->memory, length, sizeof(char), \"cif_print_page(s)\");\n        strncpy(s, pdev->fname, length);\n        *(s + length) = '\\0';\n        gp_fprintf(prn_stream, \"DS1 25 1;\\n9 %s;\\nLCP;\\n\", s);\n        gs_free(pdev->memory, s, length, 1, \"cif_print_page(s)\");\n   for (lnum = 0; lnum < pdev->height; lnum++) {\n      gdev_prn_copy_scan_lines(pdev, lnum, in, line_size);\n      length = 0;\n      for (scanline = 0; scanline < line_size; scanline++)\n#ifdef TILE\t\t\t\n         for (scanbyte = 0; scanbyte < 8; scanbyte++)\n            if (((in[scanline] >> scanbyte) & 1) != 0)\n               gp_fprintf(prn_stream, \"B4 4 %d %d;\\n\",\n                  (scanline * 8 + (7 - scanbyte)) * 4,\n                  (pdev->height - lnum) * 4);\n#else\t\t\t\t\n         for (scanbyte = 7; scanbyte >= 0; scanbyte--)\n            if (((in[scanline] >> scanbyte) & 1) != 0) {\n               if (length == 0)\n                  start = (scanline * 8 + (7 - scanbyte));\n               length++;\n            } else {\n               if (length != 0)\n                  gp_fprintf(prn_stream, \"B%d 4 %d %d;\\n\", length * 4,\n                           start * 4 + length * 2,\n                           (pdev->height - lnum) * 4);\n               length = 0;\n            }\n#endif\n   }\n        gp_fprintf(prn_stream, \"DF;\\nC1;\\nE\\n\");\n        gs_free(pdev->memory, in, line_size, 1, \"cif_print_page(in)\");\n        return 0;\n}", "target": 1}
{"code": "WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,\n                            void *pv_api_ip,\n                            void *pv_api_op)\n {\n     ihevcd_cxa_create_op_t *ps_create_op;\n     WORD32 ret;\n     codec_t *ps_codec;\n     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n    if((IV_FAIL == ret) && (NULL != ps_codec_obj))\n     {\n        ihevcd_free_static_bufs(ps_codec_obj);\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n return IV_FAIL;\n }\n    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n    ret = ihevcd_init(ps_codec);\n    TRACE_INIT(NULL);\n    STATS_INIT();\n return ret;\n}", "target": 1}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 1}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 1}
{"code": "static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)\n{\n    double mul2 = mul * mul, mul3 = mul2 * mul;\n    double kernel[] = {\n        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,\n        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,\n        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,\n         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,\n     };\n    double mat_freq[13];\n     memcpy(mat_freq, kernel, sizeof(kernel));\n     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));\n     int n = 6;\n    coeff_filter(mat_freq, n, kernel);\n    for (int k = 0; k < 2 * prefilter; ++k)\n        coeff_blur121(mat_freq, ++n);\n    double vec_freq[13];\n    n = index[3] + prefilter + 3;\n    calc_gauss(vec_freq, n, r2);\n    memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));\n    n -= 3;\n    coeff_filter(vec_freq, n, kernel);\n    for (int k = 0; k < prefilter; ++k)\n        coeff_blur121(vec_freq, --n);\n    double mat[4][4];\n    calc_matrix(mat, mat_freq, index);\n    double vec[4];\n    for (int i = 0; i < 4; ++i)\n        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];\n    for (int i = 0; i < 4; ++i) {\n        double res = 0;\n        for (int j = 0; j < 4; ++j)\n            res += mat[i][j] * vec[j];\n        mu[i] = FFMAX(0, res);\n    }\n}", "target": 1}
{"code": " static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n \t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n \t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n \t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\nunlock:\n\trelease_sock(sk);\n\treturn err ?: len;\n}", "target": 1}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n \tif (!addr)\n \t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "print_set_output(char *name, TBOOLEAN datablock, TBOOLEAN append_p)\n{\n    if (print_out && print_out != stderr && print_out != stdout) {\n#ifdef PIPES\n\tif (print_out_name[0] == '|') {\n\t    if (0 > pclose(print_out))\n\t\tperror(print_out_name);\n\t} else\n#endif\n\t    if (0 > fclose(print_out))\n\t\tperror(print_out_name);\n    }\n    free(print_out_name);\n    print_out_name = NULL;\n    print_out_var = NULL;\n    if (! name) {\n\tprint_out = stderr;\n\treturn;\n    }\n    if (strcmp(name, \"-\") == 0) {\n\tprint_out = stdout;\n\treturn;\n    }\n#ifdef PIPES\n    if (name[0] == '|') {\n\trestrict_popen();\n\tprint_out = popen(name + 1, \"w\");\n\tif (!print_out)\n\t    perror(name);\n\telse\n\t    print_out_name = name;\n\treturn;\n    }\n#endif\n    if (!datablock) {\n\tprint_out = fopen(name, append_p ? \"a\" : \"w\");\n\tif (!print_out) {\n\t    perror(name);\n\t    return;\n\t}\n    } else {\n\tprint_out_var = add_udv_by_name(name);\n\tif (!append_p)\n\t    gpfree_datablock(&print_out_var->udv_value);\n\tif (print_out_var->udv_value.type != DATABLOCK) {\n\t    free_value(&print_out_var->udv_value);\n\t    print_out_var->udv_value.type = DATABLOCK;\n\t    print_out_var->udv_value.v.data_array = NULL;\n\t}\n    }\n    print_out_name = name;\n}", "target": 1}
{"code": "__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\terror = -EFSBADCRC;\n\tif (!ext4_xattr_block_csum_verify(inode, bh))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t\t bh->b_data);\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0,\n\t\t\t\t   \"corrupted xattr block %llu\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr);\n\telse\n\t\tset_buffer_verified(bh);\n\treturn error;\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n {\n\tstruct list_head *tmp;\n \tstruct cifsSesInfo *ses;\n \twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n \t\t++ses->ses_count;\n \t\twrite_unlock(&cifs_tcp_ses_lock);\n \t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n    struct filter_op *array = NULL;\n    struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n    fprintf(stdout, \" Unfolding the meta-tree \");\n    fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}", "target": 1}
{"code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n     return 0;\n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n       return 0;\n     text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n       return 0;\n   }\n  *escaped_char = escaped_char_value(text);\n  return 1;\n}", "target": 1}
{"code": " static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n \tunsigned char max_level = 0;\n \tint unix_sock_count = 0;\n \tfor (i = scm->fp->count - 1; i >= 0; i--) {\n \t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n \tif (!UNIXCB(skb).fp)\n \t\treturn -ENOMEM;\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n \treturn max_level;\n }", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "png_set_PLTE(png_structp png_ptr, png_infop info_ptr,\n    png_colorp palette, int num_palette)\n {\n    png_debug1(1, \"in %s storage function\", \"PLTE\");\n    if (png_ptr == NULL || info_ptr == NULL)\n       return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n    {\n       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n          png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n#ifdef PNG_FREE_ME_SUPPORTED\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n #endif\n    png_ptr->palette = (png_colorp)png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));\n   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n#ifdef PNG_FREE_ME_SUPPORTED\n   info_ptr->free_me |= PNG_FREE_PLTE;\n#else\n   png_ptr->flags |= PNG_FLAG_FREE_PLTE;\n#endif\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}", "target": 1}
{"code": "static void set_k_acc(struct SYMBOL *s)\n{\n\tint i, j, nacc;\n\tchar accs[8], pits[8];\n\tstatic char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};\n\tstatic char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};\n\tif (s->u.key.sf > 0) {\n\t\tfor (nacc = 0; nacc < s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_SH;\n\t\t\tpits[nacc] = sharp_tb[nacc];\n\t\t}\n\t} else {\n\t\tfor (nacc = 0; nacc < -s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_FT;\n\t\t\tpits[nacc] = flat_tb[nacc];\n\t\t}\n\t}\n\tfor (i = 0; i < s->u.key.nacc; i++) {\n\t\tfor (j = 0; j < nacc; j++) {\n\t\t\tif (pits[j] == s->u.key.pits[i]) {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == nacc) {\n\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\tpits[j] = s->u.key.pits[i];\n\t\t\tnacc++;\t\t\n\t\t}\n\t}\n\tfor (i = 0; i < nacc; i++) {\n\t\ts->u.key.accs[i] = accs[i];\n\t\ts->u.key.pits[i] = pits[i];\n\t}\n\ts->u.key.nacc = nacc;\n}", "target": 1}
{"code": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n#ifdef SO_NOSIGPIPE\n\tif (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n#endif\n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \tsaddr.sin_port = htons(port);\n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n    }\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n}", "target": 1}
{"code": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   \n    }\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    dv_extract_audio(buf, ppcm, c->sys);\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n \tStream_Read_UINT32(s, scopeCount); \n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n \t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n {\n \tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n \tif (1 + wlen > MAX_XFER_SIZE) {\n \t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n \t\treturn -EOPNOTSUPP;\n \t}\n\two = (rbuf == NULL || rlen == 0); \n \tmutex_lock(&d->data_mutex);\n \tst->data[0] = cmd;\n \tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n \tmutex_unlock(&d->data_mutex);\n \treturn ret;\n}", "target": 1}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": " mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n \tdebug3(\"%s\", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \"keyboard-interactive\";\n \tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n }", "target": 1}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n \tgpio_dev = platform_get_drvdata(pdev);\n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn 0;\n }", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "lexer_process_char_literal (parser_context_t *context_p, \n                            const uint8_t *char_p, \n                            size_t length, \n                            uint8_t literal_type, \n                            bool has_escape) \n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n    literal_index++;\n  }\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} ", "target": 1}
{"code": "void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {\n   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);\n  DCHECK(it != headers.end());\n   if (!(it->second == \"GET\" || it->second == \"HEAD\")) {\n     QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid method \"\n                   << it->second;\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n  if (!SpdyUtils::UrlIsValid(headers)) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid URL \"\n                  << url_;\n    Reset(QUIC_INVALID_PROMISE_URL);\n    return;\n  }\n  if (!session_->IsAuthorized(SpdyUtils::GetHostNameFromHeaderBlock(headers))) {\n    Reset(QUIC_UNAUTHORIZED_PROMISE_URL);\n    return;\n  }\n  request_headers_.reset(new SpdyHeaderBlock(headers.Clone()));\n}", "target": 1}
{"code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\treturn;\n\t}\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}", "target": 1}
{"code": "b64decode(const uschar *code, uschar **ptr)\n{\nint x, y;\nuschar *result = store_get(3*(Ustrlen(code)/4) + 1);\n*ptr = result;\nwhile ((x = *code++) != 0)\n  {\n  if (isspace(x)) continue;\n  if (x > 127 || (x = dec64table[x]) == 255) return -1;\n  while (isspace(y = *code++)) ;\n  if (y == 0 || (y = dec64table[y]) == 255)\n    return -1;\n  *result++ = (x << 2) | (y >> 4);\n  while (isspace(x = *code++)) ;\n  if (x == '=')\t\t\n    {\n    while (isspace(x = *code++)) ;\n    if (x != '=') return -1;\n    while (isspace(y = *code++)) ;\n    if (y != 0) return -1;\n    break;\n    }\n  else\n    {\n    if (x > 127 || (x = dec64table[x]) == 255) return -1;\n    *result++ = (y << 4) | (x >> 2);\n    while (isspace(y = *code++)) ;\n    if (y == '=')\n      {\n      while (isspace(y = *code++)) ;\n      if (y != 0) return -1;\n      break;\n      }\n    else\n      {\n      if (y > 127 || (y = dec64table[y]) == 255) return -1;\n      *result++ = (x << 6) | y;\n      }\n    }\n  }\n*result = 0;\nreturn result - *ptr;\n}", "target": 1}
{"code": "display_dollar(colnr_T col)\n{\n    colnr_T save_col;\n    if (!redrawing())\n\treturn;\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    \n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}", "target": 1}
{"code": "static void arc_emac_tx_clean(struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tunsigned int i;\n\tfor (i = 0; i < TX_BD_NUM; i++) {\n\t\tunsigned int *txbd_dirty = &priv->txbd_dirty;\n\t\tstruct arc_emac_bd *txbd = &priv->txbd[*txbd_dirty];\n\t\tstruct buffer_state *tx_buff = &priv->tx_buff[*txbd_dirty];\n\t\tstruct sk_buff *skb = tx_buff->skb;\n\t\tunsigned int info = le32_to_cpu(txbd->info);\n\t\tif ((info & FOR_EMAC) || !txbd->data)\n\t\t\tbreak;\n\t\tif (unlikely(info & (DROP | DEFR | LTCL | UFLO))) {\n\t\t\tstats->tx_errors++;\n\t\t\tstats->tx_dropped++;\n\t\t\tif (info & DEFR)\n\t\t\t\tstats->tx_carrier_errors++;\n\t\t\tif (info & LTCL)\n\t\t\t\tstats->collisions++;\n\t\t\tif (info & UFLO)\n\t\t\t\tstats->tx_fifo_errors++;\n\t\t} else if (likely(info & FIRST_OR_LAST_MASK)) {\n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += skb->len;\n\t\t}\n\t\tdma_unmap_single(&ndev->dev, dma_unmap_addr(tx_buff, addr),\n\t\t\t\t dma_unmap_len(tx_buff, len), DMA_TO_DEVICE);\n\t\tdev_kfree_skb_irq(skb);\n\t\ttxbd->data = 0;\n\t\ttxbd->info = 0;\n\t\t*txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM;\n\t}\n\tsmp_mb();\n\tif (netif_queue_stopped(ndev) && arc_emac_tx_avail(priv))\n\t\tnetif_wake_queue(ndev);\n}", "target": 1}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n \t\tunregister_chrdev_region(cc->cdev->dev, 1);\n \t\tcdev_del(cc->cdev);\n \t}\n \trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": " void IGDstartelt(void * d, const char * name, int l)\n {\n \tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n \tdatas->cureltname[l] = '\\0';\n \tdatas->level++;\n \tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": " static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n {\n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\tvcpu->run->internal.ndata = 0;\n \tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn EMULATE_FAIL;\n }", "target": 1}
{"code": "size_t util_path_encode(char *s, size_t len)\n{\n\tchar t[(len * 3)+1];\n\tsize_t i, j;\n\tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n\t\tif (s[i] == '/') {\n\t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n\t\t\tj += 4;\n\t\t} else if (s[i] == '\\\\') {\n\t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n\t\t\tj += 4;\n\t\t} else {\n\t\t\tt[j] = s[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (len == 0)\n\t\treturn j;\n\ti = (j < len - 1) ? j : len - 1;\n\tmemcpy(s, t, i);\n\ts[i] = '\\0';\n\treturn j;\n}", "target": 1}
{"code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\tklass = method->klass;\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1}
{"code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  \n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}", "target": 1}
{"code": "static void managesieve_parser_save_arg(struct managesieve_parser *parser,\n\t\t\t\t const unsigned char *data, size_t size)\n{\n\tstruct managesieve_arg *arg;\n\tchar *str;\n\targ = managesieve_arg_create(parser);\n\tswitch (parser->cur_type) {\n\tcase ARG_PARSE_ATOM:\n\t\targ->type = MANAGESIEVE_ARG_ATOM;\n\t\targ->_data.str = p_strndup(parser->pool, data, size);\n\t\targ->str_len = size;\n\t\tbreak;\n\tcase ARG_PARSE_STRING:\n\t\tif ((parser->flags & MANAGESIEVE_PARSE_FLAG_STRING_STREAM) != 0) {\n\t\t\targ->type = MANAGESIEVE_ARG_STRING_STREAM;\n\t\t\targ->_data.str_stream = parser->str_stream;\n\t\t} else {\n\t\t\ti_assert(size > 0);\n\t\t\targ->type = MANAGESIEVE_ARG_STRING;\n\t\t\tstr = p_strndup(parser->pool, data+1, size-1);\n\t\t\tif (parser->str_first_escape >= 0 &&\n\t\t\t\t  (parser->flags & MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE) == 0) {\n\t\t\t\tstr_unescape(str + parser->str_first_escape-1);\n\t\t\t}\n\t\t\targ->_data.str = str;\n\t\t\targ->str_len = strlen(str);\n\t\t}\n\t\tbreak;\n\tcase ARG_PARSE_LITERAL_DATA:\n\t\tif ((parser->flags & MANAGESIEVE_PARSE_FLAG_STRING_STREAM) != 0) {\n\t\t\targ->type = MANAGESIEVE_ARG_STRING_STREAM;\n\t\t\targ->_data.str_stream = parser->str_stream;\n\t\t} else if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE) != 0) {\n\t\t\targ->type = MANAGESIEVE_ARG_LITERAL;\n\t\t\targ->_data.str = p_strndup(parser->pool, data, size);\n\t\t\targ->str_len = size;\n\t\t} else {\n\t\t\targ->type = MANAGESIEVE_ARG_STRING;\n\t\t\targ->_data.str = p_strndup(parser->pool, data, size);\n\t\t\targ->str_len = size;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ti_unreached();\n\t}\n\tparser->cur_type = ARG_PARSE_NONE;\n}", "target": 1}
{"code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\t\tself->rpc_tid = sw.tid;\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t\t*rpc = &self->rpc;\n\t}\nerr_exit:\n\treturn err;\n}", "target": 1}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;", "target": 1}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\n    os_ptr op = osp;\n     int code;\n     ref token;\n     pop(1);                     \n again:\n            gs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\n            break;\n        case scan_BOS:\n            code = 0;\n        case 0:         \n            push(2);\n            ref_assign(op - 1, &token);\n            make_true(op);\n            break;\n        case scan_EOF:          \n            push(1);\n            make_false(op);\n            code = 0;\n            break;\n        case scan_Refill:       \n            code = gs_scan_handle_refill(i_ctx_p, pstate, save,\n                                      ztoken_continue);\n            switch (code) {\n                case 0: \n                    goto again;\n                case o_push_estack:\n                    return code;\n            }\n            break;              \n    }", "target": 1}
{"code": "process_demand_active(STREAM s)\n {\n \tuint8 type;\n \tuint16 len_src_descriptor, len_combined_caps;\n \trd_create_ui();\n \tin_uint32_le(s, g_rdp_shareid);\n \tin_uint16_le(s, len_src_descriptor);\n \tin_uint16_le(s, len_combined_caps);\n \tin_uint8s(s, len_src_descriptor);\n \tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n\trdp_process_server_caps(s, len_combined_caps);\n\trdp_send_confirm_active();\n\trdp_send_synchronise();\n\trdp_send_control(RDP_CTL_COOPERATE);\n\trdp_send_control(RDP_CTL_REQUEST_CONTROL);\n\trdp_recv(&type);\t\n\trdp_recv(&type);\t\n\trdp_recv(&type);\t\n\trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,\n\t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_enum_bmpcache2();\n\t\trdp_send_fonts(3);\n\t}\n\telse\n\t{\n\t\trdp_send_fonts(1);\n\t\trdp_send_fonts(2);\n\t}\n\trdp_recv(&type);\t\n\treset_order_state();\n}", "target": 1}
{"code": "static void DetectFlow(ThreadVars *tv,\n                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                        Packet *p)\n {\n    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n    {\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n             flags = FlowGetDisruptionFlags(p->flow, flags);\n             DeStateUpdateInspectTransactionId(p->flow, flags, true);\n         }\n         return;\n     }\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}", "target": 1}
{"code": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n {\n \tBUG_ON(!net);\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n \treturn 0;\n }", "target": 1}
{"code": "static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\tindex = hash__alloc_context_id();\n\tif (index < 0)\n\t\treturn index;\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\tsubpage_prot_init_new_context(mm);\n\tpkey_mm_init(mm);\n\treturn index;\n}", "target": 1}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n \t\tif (err)\n \t\t\treturn err;\n \t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n \t\t\t\t       attrs[TIPC_NLA_SOCK],\n \t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 1}
{"code": "void close_all_sockets(atransport* t) {\n    asocket* s;\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close(s);\n             goto restart;\n         }\n     }\n}", "target": 1}
{"code": " scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n    const ComputedStyle&,\n     const FloatSize& target_size) {\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);\n  }\n  if (!ParseInputArguments(document))\n    return nullptr;\n  return generator_->Paint(client, RoundedIntSize(target_size),\n                           parsed_input_arguments_);\n}", "target": 1}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n \t\treturn k;\t\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "vba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\t\tret++;\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": " */\nstatic struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\tnapi->skb = NULL;\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\teth = skb_gro_header_fast(skb, 0);\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\tskb->protocol = eth->h_proto;\n\treturn skb;", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "target": 1}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 1}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n             continue;\n         }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n \t\treturn -EPROTONOSUPPORT;\n \thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n             sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n             SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n             buf[sz] = '\\0';\n             if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "static PassRefPtr<CSSValue> getPositionOffsetValue(RenderStyle* style, CSSPropertyID propertyID, RenderView* renderView)\n{\n    if (!style)\n        return 0;\n    Length l;\n    switch (propertyID) {\n        case CSSPropertyLeft:\n            l = style->left();\n            break;\n        case CSSPropertyRight:\n            l = style->right();\n            break;\n        case CSSPropertyTop:\n            l = style->top();\n            break;\n        case CSSPropertyBottom:\n            l = style->bottom();\n            break;\n        default:\n            return 0;\n    }\n    if (style->position() == AbsolutePosition || style->position() == FixedPosition) {\n        if (l.type() == WebCore::Fixed)\n            return zoomAdjustedPixelValue(l.value(), style);\n        else if (l.isViewportPercentage())\n            return zoomAdjustedPixelValue(valueForLength(l, 0, renderView), style);\n         return cssValuePool().createValue(l);\n     }\n    if (style->position() == RelativePosition)\n         return cssValuePool().createValue(l);\n     return cssValuePool().createIdentifierValue(CSSValueAuto);\n }", "target": 1}
{"code": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n        if (!GetIRCSock()) {\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n    return true;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": " int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n \t\t}\n \t}\n\thashbin->hb_current = NULL;\n \thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n                                 const GURL& real_url) {\n  if (real_url.SchemeIs(kGuestScheme))\n    return real_url;\n  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);\n  url::Origin origin = url::Origin::Create(url);\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  url::Origin isolated_origin;\n  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))\n    return isolated_origin.GetURL();\n  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {\n    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(\n        origin.host(),\n        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);\n    std::string site = origin.scheme();\n    site += url::kStandardSchemeSeparator;\n    site += domain.empty() ? origin.host() : domain;\n    return GURL(site);\n  }\n   if (!origin.unique()) {\n     DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \":\");\n   } else if (url.has_scheme()) {\n     DCHECK(!url.scheme().empty());\n     return GURL(url.scheme() + \":\");\n   }\n  DCHECK(!url.is_valid()) << url;\n  return GURL();\n}", "target": 1}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == thd->lex->first_select_lex()) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  select_lex->is_item_list_lookup= 0;\n  thd->column_usage= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->column_usage: %d\", thd->column_usage));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == thd->lex->first_select_lex() &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((*conds)->fix_fields_if_needed_for_bool(thd, conds))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(thd->is_error());\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64 weights_size = weights.size();\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n \t\t\tgoto out;\n \t\t}\n \t}\n \tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n \tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n \tstruct socket *ssocket = server->ssocket;\n \tint val = 1;\n \tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n \tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 1}
{"code": "_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,\n                      gcry_mpi_t r, gcry_mpi_t s,\n                      int flags, int hashalgo)\n{\n  gpg_err_code_t rc = 0;\n  int extraloops = 0;\n  gcry_mpi_t k, dr, sum, k_1, x;\n  mpi_point_struct I;\n  gcry_mpi_t hash;\n   const void *abuf;\n   unsigned int abits, qbits;\n   mpi_ec_t ctx;\n   if (DBG_CIPHER)\n     log_mpidump (\"ecdsa sign hash  \", input );\n  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);\n  if (rc)\n    return rc;\n   if (rc)\n     return rc;\n   k = NULL;\n   dr = mpi_alloc (0);\n   sum = mpi_alloc (0);\n    {\n      do\n        {\n          mpi_free (k);\n          k = NULL;\n          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)\n            {\n              if (!mpi_is_opaque (input))\n                {\n                  rc = GPG_ERR_CONFLICT;\n                  goto leave;\n                }\n              abuf = mpi_get_opaque (input, &abits);\n              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,\n                                            abuf, (abits+7)/8,\n                                            hashalgo, extraloops);\n              if (rc)\n                goto leave;\n              extraloops++;\n            }\n          else\n            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);\n          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n            {\n              if (DBG_CIPHER)\n                log_debug (\"ecc sign: Failed to get affine coordinates\\n\");\n              rc = GPG_ERR_BAD_SIGNATURE;\n              goto leave;\n            }\n          mpi_mod (r, x, skey->E.n);  \n        }\n      while (!mpi_cmp_ui (r, 0));\n      mpi_mulm (dr, skey->d, r, skey->E.n); \n      mpi_addm (sum, hash, dr, skey->E.n);  \n      mpi_invm (k_1, k, skey->E.n);         \n      mpi_mulm (s, k_1, sum, skey->E.n);    \n    }\n  while (!mpi_cmp_ui (s, 0));\n  if (DBG_CIPHER)\n         }", "target": 1}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n     current_element = object->child;\n     if (case_sensitive)\n     {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n         {\n             current_element = current_element->next;\n         }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n         }\n     }\n     return current_element;\n }", "target": 1}
{"code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int ssl_set_hostname( ssl_context *ssl, const char *hostname )\n{\n    if( hostname == NULL )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    ssl->hostname_len = strlen( hostname );\n    if( ssl->hostname_len + 1 == 0 )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    ssl->hostname = polarssl_malloc( ssl->hostname_len + 1 );\n    if( ssl->hostname == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    memcpy( ssl->hostname, (const unsigned char *) hostname,\n            ssl->hostname_len );\n    ssl->hostname[ssl->hostname_len] = '\\0';\n    return( 0 );\n}", "target": 1}
{"code": "static bool ntlmssp_check_buffer(const struct ntlmssp_buffer *buffer,\n\t\t\t\t size_t data_size, const char **error)\n{\n\tuint32_t offset = read_le32(&buffer->offset);\n\tuint16_t length = read_le16(&buffer->length);\n\tuint16_t space = read_le16(&buffer->space);\n\tif (length == 0 && space == 0)\n\t\treturn TRUE;\n\tif (offset >= data_size) {\n\t\t*error = \"buffer offset out of bounds\";\n\t\treturn FALSE;\n\t}\n\tif (offset + space > data_size) {\n\t\t*error = \"buffer end out of bounds\";\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n    if (lex< variable >()) {\n      kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)));\n    } else {\n      lex< alternatives< identifier_schema, identifier > >();\n      kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    }\n    lex< exactly<'='> >();\n    kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    if (peek< variable >()) kwd_arg->append(parse_list());\n    else if (lex< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(parsed);\n      kwd_arg->append(lexed_number(parsed));\n    }\n    else if (peek < ie_keyword_arg_value >()) { kwd_arg->append(parse_list()); }\n    return kwd_arg;\n  }", "target": 1}
{"code": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\nout:\n    g_free(elem);\n}", "target": 1}
{"code": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n const char* name;\n size_t namelen;\n if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n } else {\n        name = node->name;\n        namelen = node->namelen;\n }\n if (bufsize < namelen + 1) {\n return -1;\n }\n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n         if (pathlen < 0) {\n             return -1;\n         }\n        buf[pathlen++] = '/';\n }\n    memcpy(buf + pathlen, name, namelen + 1); \n return pathlen + namelen;\n}", "target": 1}
{"code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\tmutex_lock(&hiddev->existancelock);\n\tif (!list->hiddev->exist) {\n\t\tres = -ENODEV;\n\t\tgoto bail_unlock;\n\t}\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}", "target": 1}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid)) {\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "struct error_obj run_pam_auth(const char *username, char *password) {\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}", "target": 1}
{"code": "static int rsi_init_usb_interface(struct rsi_hw *adapter,\n\t\t\t\t  struct usb_interface *pfunction)\n{\n\tstruct rsi_91x_usbdev *rsi_dev;\n\tint status;\n\trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n\tif (!rsi_dev)\n\t\treturn -ENOMEM;\n\tadapter->rsi_dev = rsi_dev;\n\trsi_dev->usbdev = interface_to_usbdev(pfunction);\n\trsi_dev->priv = (void *)adapter;\n\tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_eps;\n\t}\n\tadapter->device = &pfunction->dev;\n\tusb_set_intfdata(pfunction, adapter);\n\trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n\tif (!rsi_dev->tx_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_eps;\n\t}\n\tif (rsi_usb_init_rx(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\trsi_dev->tx_blk_size = 252;\n\tadapter->block_size = rsi_dev->tx_blk_size;\n\tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n\tadapter->determine_event_timeout = rsi_usb_event_timeout;\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\tadapter->host_intf_ops = &usb_host_intf_ops;\n#ifdef CONFIG_RSI_DEBUGFS\n\tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n#endif\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\treturn 0;\nfail_rx:\n\tkfree(rsi_dev->tx_buffer);\nfail_eps:\n\tkfree(rsi_dev);\n\treturn status;\n}", "target": 1}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n \tstruct mm_struct *mm = file->private_data;\n \tunsigned long env_start, env_end;\n\tif (!mm)\n \t\treturn 0;\n \tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n \tif (bufflen > 0 && bufflen < (size_t)len)\n \t\treturn GIT_EBUFS;\n \tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\nout:\n\treturn rc;\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}", "target": 1}
{"code": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}", "target": 1}
{"code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}", "target": 1}
{"code": "lspci_process(STREAM s)\n{\n \tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, lspci_process_line, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": " static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n }", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "void DoCanonicalizeRef(const CHAR* spec,\n                       const Component& ref,\n                       CanonOutput* output,\n                       Component* out_ref) {\n  if (ref.len < 0) {\n    *out_ref = Component();\n    return;\n  }\n  output->push_back('#');\n  out_ref->begin = output->length();\n  int end = ref.end();\n  for (int i = ref.begin; i < end; i++) {\n    if (spec[i] == 0) {\n      continue;\n    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {\n      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);\n    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n      unsigned code_point;\n      ReadUTFChar(spec, &i, end, &code_point);\n      AppendUTF8Value(code_point, output);\n     }\n   }\n  out_ref->len = output->length() - out_ref->begin;\n}", "target": 1}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\tatomic_inc(&user->inotify_devs);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n \tif (ret >= 0)\n \t\treturn ret;\n \tatomic_dec(&user->inotify_devs);\n out_free_uid:\n \tfree_uid(user);\n\treturn ret;\n}", "target": 1}
{"code": "int ldb_handler_fold(struct ldb_context *ldb, void *mem_ctx,\n\t\t\t    const struct ldb_val *in, struct ldb_val *out)\n{\n\tchar *s, *t;\n\tsize_t l;\n\tif (!in || !out || !(in->data)) {\n\t\treturn -1;\n\t}\n\tout->data = (uint8_t *)ldb_casefold(ldb, mem_ctx, (const char *)(in->data), in->length);\n\tif (out->data == NULL) {\n\t\tldb_debug(ldb, LDB_DEBUG_ERROR, \"ldb_handler_fold: unable to casefold string [%.*s]\", (int)in->length, (const char *)in->data);\n\t\treturn -1;\n\t}\n\ts = (char *)(out->data);\n\tl = strlen(s);\n\twhile (l > 0 && s[l - 1] == ' ') l--;\n\ts[l] = '\\0';\n\tif (*s == ' ') {\n\t\tfor (t = s; *s == ' '; s++) ;\n\t\tmemmove(t, s, l);\n\t\ts = t;\n\t}\n\twhile ((t = strchr(s, ' ')) != NULL) {\n\t\tfor (s = t; *s == ' '; s++) ;\n\t\tif ((s - t) > 1) {\n\t\t\tl = strlen(s);\n\t\t\tmemmove(t + 1, s, l);\n\t\t}\n\t}\n\tout->length = strlen((char *)out->data);\n\treturn 0;\n}", "target": 1}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n \tif (!buf)\n \t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n \t\tret = -EFAULT;\n \t\tgoto out;\n \t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\tnp = pdev->dev.of_node;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\treturn 0;\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 1}
{"code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\t(void) size, (void) s;\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\n\t}\n\tjbg_dec_init(&decoder);\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\n#endif \n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\n\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\tjbg_dec_free(&decoder);\n\t\treturn 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\n\tjbg_dec_free(&decoder);\n\treturn 1;\n}", "target": 1}
{"code": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\t}\t\t\t\n\treturn status;\n}\t\t\t\t", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 1}
{"code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n     const ColorEntry *entry;\n     char color_name[100];\n     if (*p == '#') {\n         p++;\n         len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n        if (!entry)\n            return ret;\n        ret = entry->rgb_color;\n    }\n    return ret;\n}", "target": 1}
{"code": "StatusWith<Message> MessageCompressorManager::decompressMessage(const Message& msg,\n                                                                MessageCompressorId* compressorId) {\n    auto inputHeader = msg.header();\n    ConstDataRangeCursor input(inputHeader.data(), inputHeader.data() + inputHeader.dataLen());\n    if (input.length() < CompressionHeader::size()) {\n        return {ErrorCodes::BadValue, \"Invalid compressed message header\"};\n    }\n    CompressionHeader compressionHeader(&input);\n    auto compressor = _registry->getCompressor(compressionHeader.compressorId);\n    if (!compressor) {\n        return {ErrorCodes::InternalError,\n                \"Compression algorithm specified in message is not available\"};\n    }\n    if (compressorId) {\n        *compressorId = compressor->getId();\n    }\n    LOG(3) << \"Decompressing message with \" << compressor->getName();\n    size_t bufferSize = compressionHeader.uncompressedSize + MsgData::MsgDataHeaderSize;\n    if (bufferSize > MaxMessageSizeBytes) {\n        return {ErrorCodes::BadValue,\n                \"Decompressed message would be larger than maximum message size\"};\n    }\n    auto outputMessageBuffer = SharedBuffer::allocate(bufferSize);\n    MsgData::View outMessage(outputMessageBuffer.get());\n    outMessage.setId(inputHeader.getId());\n    outMessage.setResponseToMsgId(inputHeader.getResponseToMsgId());\n    outMessage.setOperation(compressionHeader.originalOpCode);\n    outMessage.setLen(bufferSize);\n    DataRangeCursor output(outMessage.data(), outMessage.data() + outMessage.dataLen());\n    auto sws = compressor->decompressData(input, output);\n    if (!sws.isOK())\n        return sws.getStatus();\n    if (sws.getValue() != static_cast<std::size_t>(compressionHeader.uncompressedSize)) {\n        return {ErrorCodes::BadValue, \"Decompressing message returned less data than expected\"};\n    }\n    outMessage.setLen(sws.getValue() + MsgData::MsgDataHeaderSize);\n    return {Message(outputMessageBuffer)};\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n \tif (bitmapUpdate->number > bitmapUpdate->count)\n \t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n \t\tif (!newdata)\n \t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "void Splash::scaleMaskYdXu(SplashImageMaskSource src, void *srcData,\n\t\t\t   int srcWidth, int srcHeight,\n\t\t\t   int scaledWidth, int scaledHeight,\n\t\t\t   SplashBitmap *dest) {\n  Guchar *lineBuf;\n  Guint *pixBuf;\n  Guint pix;\n  Guchar *destPtr;\n  int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, d;\n  int i, j;\n  yp = srcHeight / scaledHeight;\n  yq = srcHeight % scaledHeight;\n  xp = scaledWidth / srcWidth;\n  xq = scaledWidth % srcWidth;\n  lineBuf = (Guchar *)gmalloc(srcWidth);\n  pixBuf = (Guint *)gmallocn(srcWidth, sizeof(int));\n  yt = 0;\n  destPtr = dest->data;\n  for (y = 0; y < scaledHeight; ++y) {\n    if ((yt += yq) >= scaledHeight) {\n      yt -= scaledHeight;\n      yStep = yp + 1;\n    } else {\n      yStep = yp;\n    }\n    memset(pixBuf, 0, srcWidth * sizeof(int));\n    for (i = 0; i < yStep; ++i) {\n      (*src)(srcData, lineBuf);\n      for (j = 0; j < srcWidth; ++j) {\n\tpixBuf[j] += lineBuf[j];\n      }\n    }\n    xt = 0;\n    d = (255 << 23) / yStep;\n    for (x = 0; x < srcWidth; ++x) {\n      if ((xt += xq) >= srcWidth) {\n\txt -= srcWidth;\n\txStep = xp + 1;\n      } else {\n\txStep = xp;\n      }\n      pix = pixBuf[x];\n      pix = (pix * d) >> 23;\n      for (i = 0; i < xStep; ++i) {\n\t*destPtr++ = (Guchar)pix;\n      }\n    }\n  }\n  gfree(pixBuf);\n  gfree(lineBuf);\n}", "target": 1}
{"code": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n    file = (CompressedFile *) f->private;\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\tif (buf == bufend)\n\t    break;\n\tif (oldcode == -1)\n\t    break;\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n     \twhile ( code >= 256 )\n     \t{\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}", "target": 1}
{"code": "translate_input(int forward_translation, char *table_name) {\n\tchar charbuf[BUFSIZE];\n\tuint8_t *outputbuf;\n\tsize_t outlen;\n\twidechar inbuf[BUFSIZE];\n\twidechar transbuf[BUFSIZE];\n\tint inlen;\n\tint translen;\n\tint k;\n\tint ch = 0;\n\tint result;\n\twhile (1) {\n\t\ttranslen = BUFSIZE;\n\t\tk = 0;\n\t\twhile ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE - 1)\n\t\t\tcharbuf[k++] = ch;\n\t\tif (ch == EOF && k == 0) break;\n\t\tcharbuf[k] = 0;\n\t\tinlen = _lou_extParseChars(charbuf, inbuf);\n\t\tif (forward_translation)\n\t\t\tresult = lou_translateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\telse\n\t\t\tresult = lou_backTranslateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\tif (!result) break;\n#ifdef WIDECHARS_ARE_UCS4\n\t\toutputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);\n#else\n\t\toutputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);\n#endif\n\t\tprintf(ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);\n\t\tfree(outputbuf);\n\t}\n\tlou_free();\n}", "target": 1}
{"code": "        Header readHeader(BasicIo& io)\n        {\n            byte header[2];\n            io.read(header, 2);\n            ByteOrder byteOrder = invalidByteOrder;\n            if (header[0] == 'I' && header[1] == 'I')\n                byteOrder = littleEndian;\n            else if (header[0] == 'M' && header[1] == 'M')\n                byteOrder = bigEndian;\n            if (byteOrder == invalidByteOrder)\n                return Header();\n            byte version[2];\n            io.read(version, 2);\n            const uint16_t magic = getUShort(version, byteOrder);\n            if (magic != 0x2A && magic != 0x2B)\n                return Header();\n            Header result;\n            if (magic == 0x2A)\n            {\n                byte buffer[4];\n                io.read(buffer, 4);\n                const uint32_t offset = getULong(buffer, byteOrder);\n                result = Header(byteOrder, magic, 4, offset);\n            }\n            else\n            {\n                byte buffer[8];\n                io.read(buffer, 2);\n                const int size = getUShort(buffer, byteOrder);\n                assert(size == 8);\n                io.read(buffer, 2); \n                io.read(buffer, 8);\n                const uint64_t offset = getULongLong(buffer, byteOrder);\n                result = Header(byteOrder, magic, size, offset);\n            }\n            return result;\n        }", "target": 1}
{"code": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n                return NULL;\n        }\n       while (n-- && *src) {\n                size_t c_size;\n                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\n                                                          CH_UNIX, &c_size);\n                src += c_size;\n                c = toupper_m(c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\tdest[size] = 0;\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\ttalloc_set_name_const(dest, dest);\n\treturn dest;\n}", "target": 1}
{"code": "ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n      assert (q2 < 2);\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n      u0 = rp[n-2];\n      cy = (u0 < t);\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n      u1 += cnd_add_n (t, rp + n - 4, p->m, 3);\n      u1 -= (-t) & 0xffffffff;\n    }\n  rp[2] = u0;\n  rp[3] = u1;\n}", "target": 1}
{"code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n \t*iovcount = seg;\n \tif (unlikely(log))\n \t\t*log_num = nlogs;\n \treturn headcount;\n err:\n \tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n \t\t\t\tvoid __user *buffer, size_t *lenp,\n \t\t\t\tloff_t *ppos)\n {\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n \tif (ret || !write)\n \t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }", "target": 1}
{"code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\tumask_long = strtoll(optarg, &endptr, 0);\n \tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n \t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn;\n \t}\n \tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\tumask_cmdline = true;\n\treturn umask_val;\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type = NULL;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n        int mdnid, pknid;\n        EVP_MD_CTX_init(&ctx);\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\tgoto err;\n\t\t}\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}", "target": 1}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n \t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\t\treturn -ENOTCONN;\n \t\tpvc.sap_family = AF_ATMPVC;\n \t\tpvc.sap_addr.itf = vcc->dev->number;\n \t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 1}
{"code": "bool extract_sockaddr(struct pool *pool, char *url)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len)\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\telse\n\t\tstrcpy(port, \"80\");\n\tfree(pool->stratum_port);\n\tpool->stratum_port = strdup(port);\n\tfree(pool->sockaddr_url);\n\tpool->sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "_asn1_ltostr (long v, char *str)\n {\n   long d, r;\n   char temp[LTOSTR_MAX_SIZE];\n  int count, k, start;\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n       count++;\n       v = d;\n     }\n  while (v);\n   for (k = 0; k < count; k++)\n     str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}", "target": 1}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n    if (!resp)\n        return USB_RET_STALL;\n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    return 0;\n}", "target": 1}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ScreenPositionController::ConvertHostPointToRelativeToRootWindow(\n    aura::Window* root_window,\n    const aura::Window::Windows& root_windows,\n    gfx::Point* point,\n    aura::Window** target_root) {\n  DCHECK(!root_window->parent());\n   gfx::Point point_in_root(*point);\n   root_window->GetHost()->ConvertPointFromHost(&point_in_root);\n  *target_root = root_window;\n  *point = point_in_root;\n #if defined(USE_X11) || defined(USE_OZONE)\n  if (!root_window->GetHost()->GetBounds().Contains(*point)) {\n    gfx::Point location_in_native(point_in_root);\n    root_window->GetHost()->ConvertPointToNativeScreen(&location_in_native);\n    for (size_t i = 0; i < root_windows.size(); ++i) {\n      aura::WindowTreeHost* host = root_windows[i]->GetHost();\n      const gfx::Rect native_bounds = host->GetBounds();\n      if (native_bounds.Contains(location_in_native)) {\n         *target_root = root_windows[i];\n         *point = location_in_native;\n         host->ConvertPointFromNativeScreen(point);\n        break;\n       }\n     }\n   }\n#else\n  NOTIMPLEMENTED();\n #endif\n }", "target": 1}
{"code": "void ff_h264_free_tables(H264Context *h, int free_rbsp)\n{\n    int i;\n    H264Context *hx;\n    av_freep(&h->intra4x4_pred_mode);\n    av_freep(&h->chroma_pred_mode_table);\n    av_freep(&h->cbp_table);\n    av_freep(&h->mvd_table[0]);\n    av_freep(&h->mvd_table[1]);\n    av_freep(&h->direct_table);\n    av_freep(&h->non_zero_count);\n    av_freep(&h->slice_table_base);\n    h->slice_table = NULL;\n    av_freep(&h->list_counts);\n    av_freep(&h->mb2b_xy);\n    av_freep(&h->mb2br_xy);\n    av_buffer_pool_uninit(&h->qscale_table_pool);\n    av_buffer_pool_uninit(&h->mb_type_pool);\n    av_buffer_pool_uninit(&h->motion_val_pool);\n    av_buffer_pool_uninit(&h->ref_index_pool);\n     if (free_rbsp && h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n             ff_h264_unref_picture(h, &h->DPB[i]);\n         av_freep(&h->DPB);\n     } else if (h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n            h->DPB[i].needs_realloc = 1;\n    }\n    h->cur_pic_ptr = NULL;\n    for (i = 0; i < H264_MAX_THREADS; i++) {\n        hx = h->thread_context[i];\n        if (!hx)\n            continue;\n        av_freep(&hx->top_borders[1]);\n        av_freep(&hx->top_borders[0]);\n        av_freep(&hx->bipred_scratchpad);\n        av_freep(&hx->edge_emu_buffer);\n        av_freep(&hx->dc_val_base);\n        av_freep(&hx->er.mb_index2xy);\n        av_freep(&hx->er.error_status_table);\n        av_freep(&hx->er.er_temp_buffer);\n        av_freep(&hx->er.mbintra_table);\n        av_freep(&hx->er.mbskip_table);\n        if (free_rbsp) {\n            av_freep(&hx->rbsp_buffer[1]);\n            av_freep(&hx->rbsp_buffer[0]);\n            hx->rbsp_buffer_size[0] = 0;\n            hx->rbsp_buffer_size[1] = 0;\n        }\n        if (i)\n            av_freep(&h->thread_context[i]);\n    }\n}", "target": 1}
{"code": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain == 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size,\n    int do_interrupt, const uint8_t *dot1q_buf)\n{\n    struct iovec *iov = NULL;\n    struct iovec vlan_iov[3];\n    if (!size)\n    {\n        DPRINTF(\"+++ empty ethernet frame\\n\");\n        return;\n    }\n    if (dot1q_buf && size >= ETH_ALEN * 2) {\n        iov = (struct iovec[3]) {\n            { .iov_base = buf, .iov_len = ETH_ALEN * 2 },\n            { .iov_base = (void *) dot1q_buf, .iov_len = VLAN_HLEN },\n            { .iov_base = buf + ETH_ALEN * 2,\n                .iov_len = size - ETH_ALEN * 2 },\n        };\n        memcpy(vlan_iov, iov, sizeof(vlan_iov));\n        iov = vlan_iov;\n    }\n    if (TxLoopBack == (s->TxConfig & TxLoopBack))\n    {\n        size_t buf2_size;\n        uint8_t *buf2;\n        if (iov) {\n            buf2_size = iov_size(iov, 3);\n            buf2 = g_malloc(buf2_size);\n            iov_to_buf(iov, 3, 0, buf2, buf2_size);\n            buf = buf2;\n        }\n        DPRINTF(\"+++ transmit loopback mode\\n\");\n        rtl8139_do_receive(qemu_get_queue(s->nic), buf, size, do_interrupt);\n        if (iov) {\n            g_free(buf2);\n        }\n    }\n    else\n    {\n        if (iov) {\n            qemu_sendv_packet(qemu_get_queue(s->nic), iov, 3);\n        } else {\n            qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n        }\n    }\n}", "target": 1}
{"code": "build_config(char *prefix, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n \tif (!addr)\n \t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n \tmsr.host_initiated = false;\n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void Con_Dump_f (void)\n{\n\tint\t\tl, x, i;\n\tshort\t*line;\n\tfileHandle_t\tf;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\tif (Cmd_Argc() != 2)\n\t{\n\t\tCom_Printf (\"usage: condump <filename>\\n\");\n\t\treturn;\n\t}\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\tf = FS_FOpenFileWrite( filename );\n\tif (!f)\n\t{\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\tfor (l = con.current - con.totallines + 1 ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor (x=0 ; x<con.linewidth ; x++)\n\t\t\tif ((line[x] & 0xff) != ' ')\n\t\t\t\tbreak;\n\t\tif (x != con.linewidth)\n\t\t\tbreak;\n\t}\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor(i=0; i<con.linewidth; i++)\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor (x=con.linewidth-1 ; x>=0 ; x--)\n\t\t{\n\t\t\tif (buffer[x] == ' ')\n\t\t\t\tbuffer[x] = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write(buffer, strlen(buffer), f);\n\t}\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "static void sp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->flags\t\t= 0;\n}", "target": 1}
{"code": "static char *sanitize_cookie_path(const char *cookie_path)\n{\n  size_t len;\n  char *new_path = strdup(cookie_path);\n  if(!new_path)\n    return NULL;\n  if(new_path[0] == '\\\"') {\n    memmove((void *)new_path, (const void *)(new_path + 1), strlen(new_path));\n  }\n  if(new_path[strlen(new_path) - 1] == '\\\"') {\n    new_path[strlen(new_path) - 1] = 0x0;\n  }\n  if(new_path[0] != '/') {\n    free(new_path);\n    new_path = strdup(\"/\");\n    return new_path;\n  }\n  len = strlen(new_path);\n  if(1 < len && new_path[len - 1] == '/') {\n    new_path[len - 1] = 0x0;\n  }\n  return new_path;\n}", "target": 1}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; \n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n \t}\n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tbr_write_lock(&vfsmount_lock);\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tbr_write_unlock(&vfsmount_lock);\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\treturn mnt;\n out_free:\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  MagickPixelPacket\n    **pixels;\n  register ssize_t\n    i,\n    j;\n   size_t\n     columns,\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (MagickPixelPacket **) NULL)\n     return((MagickPixelPacket **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   columns=images->columns;\n   for (next=images; next != (Image *) NULL; next=next->next)\n     columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\n       sizeof(**pixels));\n    if (pixels[i] == (MagickPixelPacket *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n      GetMagickPixelPacket(images,&pixels[i][j]);\n  }\n  return(pixels);\n}", "target": 1}
{"code": "void ZRtp::storeMsgTemp(ZrtpPacketBase* pkt) {\n    int32_t length = pkt->getLength() * ZRTP_WORD_SIZE;\n    memset(tempMsgBuffer, 0, sizeof(tempMsgBuffer));\n    memcpy(tempMsgBuffer, (uint8_t*)pkt->getHeaderBase(), length);\n    lengthOfMsgData = length;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }", "target": 1}
{"code": "PatternMatch(char *pat, int patdashes, char *string, int stringdashes)\n{\n    char        c,\n                t;\n    if (stringdashes < patdashes)\n\treturn 0;\n    for (;;) {\n\tswitch (c = *pat++) {\n\tcase '*':\n\t    if (!(c = *pat++))\n\t\treturn 1;\n\t    if (c == XK_minus) {\n\t\tpatdashes--;\n\t\tfor (;;) {\n\t\t    while ((t = *string++) != XK_minus)\n\t\t\tif (!t)\n\t\t\t    return 0;\n\t\t    stringdashes--;\n\t\t    if (PatternMatch(pat, patdashes, string, stringdashes))\n\t\t\treturn 1;\n\t\t    if (stringdashes == patdashes)\n\t\t\treturn 0;\n\t\t}\n\t    } else {\n\t\tfor (;;) {\n\t\t    while ((t = *string++) != c) {\n\t\t\tif (!t)\n\t\t\t    return 0;\n\t\t\tif (t == XK_minus) {\n\t\t\t    if (stringdashes-- < patdashes)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t    }\n\t\t    if (PatternMatch(pat, patdashes, string, stringdashes))\n\t\t\treturn 1;\n \t\t}\n \t    }\n \tcase '?':\n\t    if (*string++ == XK_minus)\n \t\tstringdashes--;\n \t    break;\n \tcase '\\0':\n \t    return (*string == '\\0');\n\t\tpatdashes--;\n\t\tstringdashes--;\n\t\tbreak;\n\t    }\n\t    return 0;\n\tdefault:\n\t    if (c == *string++)\n\t\tbreak;\n\t    return 0;\n\t}\n    }", "target": 1}
{"code": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n \t\treturn 0;\n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\treturn 0;\n}", "target": 1}
{"code": " void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n }", "target": 1}
{"code": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_ARRAY;\n    data->length = size;\n    plist_t node = node_create(NULL, data);\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n        node_attach(node, val);\n    }\n    return node;\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n  const MagicInfo\n    *magic_info;\n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MaxTextExtent];\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MaxTextExtent);\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "void diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF))\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n \tregister const struct in6_addr *addr;\n \tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n \tep = ndo->ndo_snapend;\n \tND_TCHECK(dp->ip6r_segleft);\n \tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n \tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n \tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n    xmlNodePtr cur = NULL;\n    unsigned long val;\n    xmlChar str[20];\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i, ret;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t        cur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    val = (unsigned long)((char *)cur - (char *)0);\n    val /= sizeof(xmlNode);\n    sprintf((char *)str, \"id%ld\", val);\n    valuePush(ctxt, xmlXPathNewString(str));\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static struct wildmat *split_wildmats(char *str)\n{\n    const char *prefix;\n    char pattern[MAX_MAILBOX_BUFFER] = \"\", *p, *c;\n    struct wildmat *wild = NULL;\n    int n = 0;\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(pattern, sizeof(pattern), \"%s.\", prefix);\n    p = pattern + strlen(pattern);\n    do {\n\tif ((c = strrchr(str, ',')))\n\t    *c++ = '\\0';\n\telse\n\t    c = str;\n\tif (!(n % 10)) \n\t    wild = xrealloc(wild, (n + 11) * sizeof(struct wildmat));\n\tif (*c == '!') wild[n].not = 1;\t\t\n\telse if (*c == '@') wild[n].not = -1;\t\n\telse wild[n].not = 0;\n\tstrcpy(p, wild[n].not ? c + 1 : c);\n\twild[n++].pat = xstrdup(pattern);\n    } while (c != str);\n    wild[n].pat = NULL;\n    return wild;\n}", "target": 1}
{"code": "void DocumentWriter::setDecoder(TextResourceDecoder* decoder)\n{\n    m_decoder = decoder;\n}", "target": 1}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return xref->isOk();\n}", "target": 1}
{"code": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n    if (!shouldClose(navigationType == NavigationTypeReload))\n         return;\n     m_frame->document()->cancelParsing();\n    detachDocumentLoader(m_provisionalDocumentLoader);\n    if (!m_frame->host())\n        return;\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n    m_loadType = type;\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n    takeObjectSnapshot();\n}", "target": 1}
{"code": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    int i, j, code, stride;\n    int x, y;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n            for (j = i - 1; j >= 0; --j) {\n                jbig2_image_release(ctx, GSPLANES[j]);\n            }\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }", "target": 1}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !ext_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 1}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    if (header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    while(header[0] == '#')\n      {\n        fgets (header,MAX_CHARS_IN_ROW,fp);\n      }\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    maxval = strtol (header,&ptr,0);\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n    return TRUE;\n}", "target": 1}
{"code": "static void _imap_quote_string (char *dest, size_t dlen, const char *src,\n                                const char *to_quote)\n{\n  char *pt;\n  const char *s;\n  pt = dest;\n  s  = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr (to_quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}", "target": 1}
{"code": " static void pipe_advance(struct iov_iter *i, size_t size)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n \tif (unlikely(i->count < size))\n \t\tsize = i->count;\n\torig_sz = size;\n \tif (size) {\n \t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n \t\twhile (1) {\n \t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n \t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n \t\t\tidx = next_idx(idx, pipe);\n \t\t}\n\t\tbuf->len = size;\n \t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n \t}\n\ti->count -= orig_sz;\n }", "target": 1}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n \tif (ret)\n \t\tgoto out;\n \tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n \tif (p->io_context)\n \t\tret = p->io_context->ioprio;\n out:\n \treturn ret;\n }", "target": 1}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n         plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n     } else {\n         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n     }\n     ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 1}
{"code": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n \t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n \t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n \t\treturn -EINVAL;\n \treturn cdrom_slot_status(cdi, arg);\n }", "target": 1}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n         if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "check_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n {\n        char path[PATH_MAX];\n        struct passwd *pwd;\n       FILE *fp;\n       int i, save_errno;\n        uid_t fsuid;\n        pwd = pam_modutil_getpwnam(pamh, this_user);\n        if (pwd == NULL) {\n\t}\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tfsuid = setfsuid(pwd->pw_uid);\n\tfp = fopen(path, \"r\");\n                return PAM_SESSION_ERR;\n        }\n        fsuid = setfsuid(pwd->pw_uid);\n       fp = fopen(path, \"r\");\n        save_errno = errno;\n        setfsuid(fsuid);\n       if (fp != NULL) {\n                char buf[LINE_MAX], *tmp;\n                while (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}", "target": 1}
{"code": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\tif (file_name == NULL)\n\t\treturn NULL;\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\tprefix_len = p + 2 - file_name;\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\treturn p;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n\t\tops->destroy(dev);\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n \t\treturn ret;\n \t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n    return containingBlock()->availableLogicalHeight();\n}", "target": 1}
{"code": "void Part::slotOpenExtractedEntry(KJob *job)\n{\n    if (!job->error()) {\n        OpenJob *openJob = qobject_cast<OpenJob*>(job);\n        Q_ASSERT(openJob);\n        m_tmpExtractDirList << openJob->tempDir();\n        const QString fullName = openJob->validatedFilePath();\n        bool isWritable = m_model->archive() && !m_model->archive()->isReadOnly();\n        if (!isWritable) {\n            QFile::setPermissions(fullName, QFileDevice::ReadOwner | QFileDevice::ReadGroup | QFileDevice::ReadOther);\n        }\n        if (isWritable) {\n            m_fileWatcher = new QFileSystemWatcher;\n            connect(m_fileWatcher, &QFileSystemWatcher::fileChanged, this, &Part::slotWatchedFileModified);\n            m_fileWatcher->addPath(fullName);\n        }\n        if (qobject_cast<OpenWithJob*>(job)) {\n            const QList<QUrl> urls = {QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile)};\n            KRun::displayOpenWithDialog(urls, widget());\n         } else {\n             KRun::runUrl(QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile),\n                          QMimeDatabase().mimeTypeForFile(fullName).name(),\n                         widget());\n         }\n     } else if (job->error() != KJob::KilledJobError) {\n         KMessageBox::error(widget(), job->errorString());\n    }\n    setReadyGui();\n}", "target": 1}
{"code": "status_t Camera3Device::createDefaultRequest(int templateId,\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n return OK;\n}", "target": 1}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n             }\n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n    uint id = replaces_id ? replaces_id : m_nextId++;\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n    bool isPersistent = timeout == 0;\n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n        timeout = 2000 + qMax(timeout, 3000);\n    }", "target": 1}
{"code": "vhost_backend_cleanup(struct virtio_net *dev)\n{\n\tif (dev->mem) {\n\t\tfree_mem_region(dev);\n\t\trte_free(dev->mem);\n\t\tdev->mem = NULL;\n\t}\n\tfree(dev->guest_pages);\n\tdev->guest_pages = NULL;\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t\tdev->log_addr = 0;\n\t}\n\tif (dev->slave_req_fd >= 0) {\n\t\tclose(dev->slave_req_fd);\n\t\tdev->slave_req_fd = -1;\n\t}\n\tif (dev->postcopy_ufd >= 0) {\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t}\n\tdev->postcopy_listening = 0;\n}", "target": 1}
{"code": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tpcount = pq_getmsgint(buf, 4);\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n \t\tPG_RETURN_POINTER(out);\n \t}\n \tpairs = palloc(pcount * sizeof(Pairs));\n \tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\tout = hstorePairs(pairs, pcount, buflen);\n\tPG_RETURN_POINTER(out);\n}", "target": 1}
{"code": " void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n    g_free(s->ctx.fs_root);\n     g_free(s->tag);\n }", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n \tif (!err) {\n \t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n \t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n \t}\n \treturn err;\n }", "target": 1}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n \treturn \"3\"\"SIG padding does not check out\";\n     }\n    s += padlen + 3;\n    (*psig) = s;\n     return NULL;\n}", "target": 1}
{"code": "void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   uint8_t* p = p_data->p_data;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN);\n   smp_key_distribution(p_cb, NULL);\n}", "target": 1}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char buf[256];\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  X509_NAME_oneline(X509_get_subject_name(server_cert), buf, sizeof(buf));\n  X509_free (server_cert);\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  DBUG_RETURN(1);", "target": 1}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                 if (cid <= 0)\n                     continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t\n\t\telse {\t\t\t\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"ntp\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"%hu\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}", "target": 1}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "void spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, zend_long ctor_flags) \n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed;\n\tsize_t len;\n\tzend_long flags;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling);\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tintern = Z_SPLFILESYSTEM_P(getThis());\n\tif (intern->_path) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\tphp_error_docref(NULL, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob:\n\t\tspprintf(&path, 0, \"glob:\n\t\tspl_filesystem_dir_open(intern, path);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path);\n\t}\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator) ? 1 : 0;\n\tzend_restore_error_handling(&error_handling);\n}", "target": 1}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \tif (ret < 0)\n \t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n \tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n \tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n \treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n \t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}", "target": 1}
{"code": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->HasRealtimeConstraint()) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n  } else {\n    if (context()->ContextState() == BaseAudioContext::kRunning) {\n      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n          std::move(handler_));\n    }\n   }\n }", "target": 1}
{"code": "static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,\n unsigned long arg)\n{\n unsigned long tmp;\n struct vm_area_struct * vma, *prev;\n int unmapped_error = 0;\n int error = -EINVAL;\n\tvma = find_vma_prev(current->mm, start, &prev);\n if (vma && start > vma->vm_start)\n\t\tprev = vma;\n for (;;) {\n\t\terror = -ENOMEM;\n if (!vma)\n return error;\n if (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n if (start >= end)\n return error;\n }\n\t\ttmp = vma->vm_end;\n if (end < tmp)\n \t\t\ttmp = end;\n\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n\t\tstart = tmp;\n if (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n if (start >= end)\n return error;\n if (prev)\n\t\t\tvma = prev->vm_next;\n else \n\t\t\tvma = find_vma(current->mm, start);\n }\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n     if (!s->initialized) {\n         ff_vp8_decode_init(avctx);\n         s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n     }\n     s->lossless = 0;\n     if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "int dhcp6_option_append_ia(uint8_t **buf, size_t *buflen, const DHCP6IA *ia) {\n        uint16_t len;\n        uint8_t *ia_hdr;\n        size_t iaid_offset, ia_buflen, ia_addrlen = 0;\n        DHCP6Address *addr;\n        int r;\n        assert_return(buf, -EINVAL);\n        assert_return(*buf, -EINVAL);\n        assert_return(buflen, -EINVAL);\n        assert_return(ia, -EINVAL);\n        switch (ia->type) {\n        case SD_DHCP6_OPTION_IA_NA:\n                len = DHCP6_OPTION_IA_NA_LEN;\n                iaid_offset = offsetof(DHCP6IA, ia_na);\n                break;\n        case SD_DHCP6_OPTION_IA_TA:\n                len = DHCP6_OPTION_IA_TA_LEN;\n                iaid_offset = offsetof(DHCP6IA, ia_ta);\n                break;\n        default:\n                return -EINVAL;\n        }\n        if (*buflen < len)\n                return -ENOBUFS;\n        ia_hdr = *buf;\n        ia_buflen = *buflen;\n        *buf += sizeof(DHCP6Option);\n        *buflen -= sizeof(DHCP6Option);\n        memcpy(*buf, (char*) ia + iaid_offset, len);\n        *buf += len;\n        *buflen -= len;\n        LIST_FOREACH(addresses, addr, ia->addresses) {\n                r = option_append_hdr(buf, buflen, SD_DHCP6_OPTION_IAADDR,\n                                      sizeof(addr->iaaddr));\n                if (r < 0)\n                        return r;\n                memcpy(*buf, &addr->iaaddr, sizeof(addr->iaaddr));\n                *buf += sizeof(addr->iaaddr);\n                *buflen -= sizeof(addr->iaaddr);\n                ia_addrlen += sizeof(DHCP6Option) + sizeof(addr->iaaddr);\n        }\n        r = option_append_hdr(&ia_hdr, &ia_buflen, ia->type, len + ia_addrlen);\n        if (r < 0)\n                return r;\n        return 0;\n}", "target": 1}
{"code": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t    rfbCloseClient(cl);\n\t}\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n}", "target": 1}
{"code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n    bs->read_only = 1;\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }", "target": 1}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    allow_t allow = ACCESS_DENIED;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        allow = checklist.fastCheck();\n        if (allow == ACCESS_ALLOWED && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }", "target": 1}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}", "target": 1}
{"code": "void ide_atapi_cmd_reply_end(IDEState *s)\n{\n    int byte_count_limit, size, ret;\n    while (s->packet_transfer_size > 0) {\n        trace_ide_atapi_cmd_reply_end(s, s->packet_transfer_size,\n                                      s->elementary_transfer_size,\n                                      s->io_buffer_index);\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n            if (!s->elementary_transfer_size) {\n                ret = cd_read_sector(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                }\n                return;\n            } else {\n                ret = cd_read_sector_sync(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                    return;\n                }\n            }\n        }\n        if (s->elementary_transfer_size > 0) {\n            size = s->cd_sector_size - s->io_buffer_index;\n            if (size > s->elementary_transfer_size)\n                size = s->elementary_transfer_size;\n        } else {\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n            ide_set_irq(s->bus);\n            byte_count_limit = atapi_byte_count_limit(s);\n            trace_ide_atapi_cmd_reply_end_bcl(s, byte_count_limit);\n            size = s->packet_transfer_size;\n            if (size > byte_count_limit) {\n                if (byte_count_limit & 1)\n                    byte_count_limit--;\n                size = byte_count_limit;\n            }\n            s->lcyl = size;\n            s->hcyl = size >> 8;\n            s->elementary_transfer_size = size;\n            if (s->lba != -1) {\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n                    size = (s->cd_sector_size - s->io_buffer_index);\n            }\n            trace_ide_atapi_cmd_reply_end_new(s, s->status);\n        }\n        s->packet_transfer_size -= size;\n        s->elementary_transfer_size -= size;\n        s->io_buffer_index += size;\n        if (!ide_transfer_start_norecurse(s,\n                                          s->io_buffer + s->io_buffer_index - size,\n                                          size, ide_atapi_cmd_reply_end)) {\n            return;\n        }\n    }\n    trace_ide_atapi_cmd_reply_end_eot(s, s->status);\n    ide_atapi_cmd_ok(s);\n    ide_set_irq(s->bus);\n}", "target": 1}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tkenter(\"{%d}\", key->serial);\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}", "target": 1}
{"code": "static void ssl3_take_mac(SSL *s)\n        {\n        const char *sender;\n        int slen;\n        if (s->state & SSL_ST_CONNECT)\n                {\n                sender=s->method->ssl3_enc->server_finished_label;\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}", "target": 1}
{"code": " void acpi_ns_terminate(void)\n {\n \tacpi_status status;\n \tACPI_FUNCTION_TRACE(ns_terminate);\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n \t}\n#endif\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}", "target": 1}
{"code": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n     virResetLastError();\n     virCheckDomainReturn(dom, -1);\n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}", "target": 1}
{"code": "rfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n\trfbAuthProcessSecurityTypeMessage(cl);\n\treturn;\n#ifdef VINO_HAVE_GNUTLS\n    case RFB_TLS_HANDSHAKE:\n\trfbAuthProcessTLSHandshake(cl);\n\treturn;\n#endif\n    case RFB_AUTH_TYPE:\n\trfbAuthProcessAuthTypeMessage(cl);\n\treturn;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_AUTH_DEFERRED:\n\trfbLog(\"Authentication deferred - ignoring client message\\n\");\n\treturn;\n    case RFB_INITIALISATION:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}", "target": 1}
{"code": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https:\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }", "target": 1}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n \t}\n \ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 1}
{"code": " bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n  if (IsDownloadFromMiniGallery(download_url) &&\n      StartsWithASCII(referrer_url.spec(),\n                      extension_urls::kMiniGalleryBrowsePrefix, false)) {\n    return true;\n  }\n  const Extension* download_extension = GetExtensionByWebExtent(download_url);\n  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);\n  const Extension* webstore_app = GetWebStoreApp();\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           switches::kAppsGalleryURL));\n  if (!store_url.is_empty()) {\n    std::string store_tld =\n        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);\n    if (!referrer_valid) {\n      std::string referrer_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              referrer_url);\n      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);\n    }\n    if (!download_valid) {\n      std::string download_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              download_url);\n      download_valid = (download_tld == store_tld);\n    }\n  }\n  return (referrer_valid && download_valid);\n}", "target": 1}
{"code": " bool SVGElement::HasSVGParent() const {\n  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n }", "target": 1}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static CURLcode read_data(struct connectdata *conn,\n                          curl_socket_t fd,\n                          struct krb5buffer *buf)\n{\n  int len;\n  void *tmp = NULL;\n  CURLcode result;\n  result = socket_read(fd, &len, sizeof(len));\n  if(result)\n    return result;\n  if(len) {\n    len = ntohl(len);\n    tmp = Curl_saferealloc(buf->data, len);\n  }\n  if(tmp == NULL)\n    return CURLE_OUT_OF_MEMORY;\n  buf->data = tmp;\n  result = socket_read(fd, buf->data, len);\n  if(result)\n    return result;\n  buf->size = conn->mech->decode(conn->app_data, buf->data, len,\n                                 conn->data_prot, conn);\n  buf->index = 0;\n  return CURLE_OK;\n}", "target": 1}
{"code": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "gs_heap_alloc_bytes(gs_memory_t * mem, uint size, client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    byte *ptr = 0;\n#ifdef DEBUG\n    const char *msg;\n    static const char *const ok_msg = \"OK\";\n#  define set_msg(str) (msg = (str))\n#else\n#  define set_msg(str) DO_NOTHING\n#endif\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\n    if (size > mmem->limit - sizeof(gs_malloc_block_t)) {\n        set_msg(\"exceeded limit\");\n     } else {\n         uint added = size + sizeof(gs_malloc_block_t);\n        if (mmem->limit - added < mmem->used)\n             set_msg(\"exceeded limit\");\n         else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n             set_msg(\"failed\");\n        else {\n            gs_malloc_block_t *bp = (gs_malloc_block_t *) ptr;\n            set_msg(ok_msg);\n            if (mmem->allocated)\n                mmem->allocated->prev = bp;\n            bp->next = mmem->allocated;\n            bp->prev = 0;\n            bp->size = size;\n            bp->type = &st_bytes;\n            bp->cname = cname;\n            mmem->allocated = bp;\n            ptr = (byte *) (bp + 1);\n            mmem->used += size + sizeof(gs_malloc_block_t);\n            if (mmem->used > mmem->max_used)\n                mmem->max_used = mmem->used;\n        }\n    }\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t\n    if (ptr)\n        gs_alloc_fill(ptr, gs_alloc_fill_alloc, size);\n#ifdef DEBUG\n    if (gs_debug_c('a') || msg != ok_msg)\n        dmlprintf6(mem, \"[a+]gs_malloc(%s)(%u) = 0x%lx: %s, used=%ld, max=%ld\\n\",\n                   client_name_string(cname), size, (ulong) ptr, msg, mmem->used, mmem->max_used);\n#endif\n    return ptr;\n#undef set_msg\n}", "target": 1}
{"code": "bool IsSmartVirtualKeyboardEnabled() {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n           keyboard::switches::kEnableVirtualKeyboard)) {\n     return false;\n   }\n  return !base::CommandLine::ForCurrentProcess()->HasSwitch(\n      keyboard::switches::kDisableSmartVirtualKeyboard);\n }", "target": 1}
{"code": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n   png_ptr->zstream.next_in = (png_bytep)data; \n   png_ptr->zstream.avail_in = size;\n   while (1)\n   {\n      int ret, avail;\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n       {\n          if (output != 0 && output_size > count)\n          {\n            int copy = output_size - count;\n            if (avail < copy) copy = avail;\n             png_memcpy(output + count, png_ptr->zbuf, copy);\n          }\n          count += avail;\n      }\n      if (ret == Z_OK)\n         continue;\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n      if (ret == Z_STREAM_END)\n         return count; \n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n            char umsg[52];\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n            msg = umsg;\n#else\n            msg = \"Damaged compressed datastream in chunk other than IDAT\";\n#endif\n         }\n         png_warning(png_ptr, msg);\n      }\n      return 0;\n   }\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n \twhile ( size_left ) {\n \t\tuint32_t id;\n \t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n \t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 1}
{"code": "std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,\n                                       bool include_rcd,\n                                       bool exclude_file_scheme) {\n  typedef base::StringPairs HostVector;\n  HostVector hosts_best_rcd;\n  for (const URLPattern& pattern : host_patterns) {\n    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)\n       continue;\n     std::string host = pattern.host();\n     if (pattern.match_subdomains())\n      host = \"*.\" + host;\n    std::string rcd;\n    size_t reg_len =\n        net::registry_controlled_domains::PermissiveGetHostRegistryLength(\n            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,\n            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);\n    if (reg_len && reg_len != std::string::npos) {\n      if (include_rcd)  \n        rcd = host.substr(host.size() - reg_len);\n      host = host.substr(0, host.size() - reg_len);\n    }\n    HostVector::iterator it = hosts_best_rcd.begin();\n    for (; it != hosts_best_rcd.end(); ++it) {\n      if (it->first == host)\n        break;\n    }\n    if (it != hosts_best_rcd.end()) {\n      if (include_rcd && RcdBetterThan(rcd, it->second))\n        it->second = rcd;\n    } else {  \n      hosts_best_rcd.push_back(std::make_pair(host, rcd));\n    }\n  }\n  std::set<std::string> distinct_hosts;\n  for (const auto& host_rcd : hosts_best_rcd)\n    distinct_hosts.insert(host_rcd.first + host_rcd.second);\n  return distinct_hosts;\n}", "target": 1}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n \t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n \t\tsizeof(ualg->cru_module_name));\n \tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tsize_t event_size = sizeof (struct inotify_event);\n\tstruct inotify_device *dev;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT(wait);\n\tstart = buf;\n\tdev = file->private_data;\n\twhile (1) {\n\t\tprepare_to_wait(&dev->wq, &wait, TASK_INTERRUPTIBLE);\n\t\tmutex_lock(&dev->ev_mutex);\n\t\tif (!list_empty(&dev->events)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&dev->ev_mutex);\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\tfinish_wait(&dev->wq, &wait);\n\tif (ret)\n\t\treturn ret;\n\twhile (1) {\n\t\tstruct inotify_kernel_event *kevent;\n\t\tret = buf - start;\n\t\tif (list_empty(&dev->events))\n\t\t\tbreak;\n\t\tkevent = inotify_dev_get_event(dev);\n\t\tif (event_size + kevent->event.len > count) {\n\t\t\tif (ret == 0 && count > 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tremove_kevent(dev, kevent);\n\t\tmutex_unlock(&dev->ev_mutex);\n\t\tif (copy_to_user(buf, &kevent->event, event_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += event_size;\n\t\tcount -= event_size;\n\t\tif (kevent->name) {\n\t\t\tif (copy_to_user(buf, kevent->name, kevent->event.len)){\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += kevent->event.len;\n\t\t\tcount -= kevent->event.len;\n\t\t}\n\t\tfree_kevent(kevent);\n\t\tmutex_lock(&dev->ev_mutex);\n\t}\n\tmutex_unlock(&dev->ev_mutex);\n\treturn ret;\n}", "target": 1}
{"code": " static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n {\n\tchar *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \tsize_t new_vlen;\n \tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n \tif (!vsep) {\n \t\tif (!eof) {\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n \tefree(val);\n \tvar->ptr = vsep + (vsep != var->end);\n \treturn 1;\n }", "target": 1}
{"code": "static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size > HCI_MIN_ENC_KEY_SIZE);\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MaxTextExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n \t\t\tucounts = new;\n \t\t}\n \t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n \t\tucounts = NULL;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "int x509_get_name( unsigned char **p, const unsigned char *end,\n                   x509_name *cur )\n{\n    int ret;\n    size_t len;\n    const unsigned char *end2;\n    x509_name *use;\n    if( ( ret = asn1_get_tag( p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SET ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n    end2 = end;\n    end  = *p + len;\n    use = cur;\n    do\n    {\n        if( ( ret = x509_get_attr_type_value( p, end, use ) ) != 0 )\n            return( ret );\n        if( *p != end )\n        {\n            use->next = (x509_name *) polarssl_malloc(\n                    sizeof( x509_name ) );\n            if( use->next == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n            memset( use->next, 0, sizeof( x509_name ) );\n            use = use->next;\n        }\n    }\n    while( *p != end );\n    if( *p == end2 )\n        return( 0 );\n    cur->next = (x509_name *) polarssl_malloc(\n         sizeof( x509_name ) );\n    if( cur->next == NULL )\n        return( POLARSSL_ERR_X509_MALLOC_FAILED );\n    memset( cur->next, 0, sizeof( x509_name ) );\n    return( x509_get_name( p, end2, cur->next ) );\n}", "target": 1}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n   rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n   if (len < 0) \n     {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "static int lookup1_values(int entries, int dim)\n{\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   \n       ++r;                                              \n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); \n    return r;\n }", "target": 1}
{"code": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; \n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}", "target": 1}
{"code": "int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n {\n \tchar *copy;\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n\t && strncmp(m->modname, \"symbol:\", 7) == 0\n\t) {\n\t\tG.need_symbols = 1;\n\t}\n}", "target": 1}
{"code": " char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n {\n        char *dst;\n        if (!value.length)\n                return NULL;\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n                return NULL;\n        }\n       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);\n        return dst;\n }", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n \t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n \t\treturn -EINVAL;\n \tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n         LINE_OP(output[x], inverse_db_table[y]);\n       }\n    }\n }", "target": 1}
{"code": "   static void  Ins_JMPR( INS_ARG )\n   {\n     CUR.IP      += (Int)(args[0]);\n     CUR.step_ins = FALSE;\n     * allow for simple cases here by just checking the preceding byte.\n     * Fonts with this problem are not uncommon.\n     */\n      CUR.IP -= 1;\n  }", "target": 1}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \t\tcase 0xC0:\n \t\t\tl = p[1];\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 1}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n     FT_Size_Metrics*  metrics;\n    size->ttmetrics.valid = FALSE;\n     face = (TT_Face)size->root.face;\n     metrics = &size->metrics;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n    size->ttmetrics.valid = TRUE;\n    if ( only_height )\n      return FT_Err_Ok;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif \n    return FT_Err_Ok;\n  }", "target": 1}
{"code": " int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n\tu16 offset = sizeof(struct ipv6hdr);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \twhile (offset <= packet_len) {\n \t\tstruct ipv6_opt_hdr *exthdr;\n \t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n \t\t*nexthdr = &exthdr->nexthdr;\n \t}\n\treturn -EINVAL;\n}", "target": 1}
{"code": "void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n{\n\tvoid *buf = n->nm_nlh;\n        size_t nlmsg_len = n->nm_nlh->nlmsg_len;\n        size_t tlen;\n        tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n        if ((tlen + nlmsg_len) > n->nm_size)\n\tn->nm_nlh->nlmsg_len += tlen;\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\tNL_DBG(2, \"msg %p: Reserved %zu (%zu) bytes, pad=%d, nlmsg_len=%d\\n\",\n\t\t  n, tlen, len, pad, n->nm_nlh->nlmsg_len);\n\treturn buf;\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n   plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n     return CURLE_OUT_OF_MEMORY;\n   plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n \t\t}\n \t\tif (field->value[n] >= min && field->value[n] <= max\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \t\tif (value[n] >= min && value[n] <= max\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": " bool PasswordAutofillAgent::TryToShowTouchToFill(\n     const WebFormControlElement& control_element) {\n   const WebInputElement* element = ToWebInputElement(&control_element);\n  if (!element || (!base::Contains(web_input_to_password_info_, *element) &&\n                   !base::Contains(password_to_username_, *element))) {\n     return false;\n   }\n   if (was_touch_to_fill_ui_shown_)\n    return false;\n  was_touch_to_fill_ui_shown_ = true;\n  GetPasswordManagerDriver()->ShowTouchToFill();\n  return true;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n \t\tif (err) {\n \t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n \t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}\n\treturn 0;\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "Field *create_tmp_field_from_field(THD *thd, Field *org_field,\n                                   const char *name, TABLE *table,\n                                   Item_field *item)\n{\n  Field *new_field;\n  new_field= org_field->make_new_field(thd->mem_root, table,\n                                       table == org_field->table);\n  if (new_field)\n  {\n    new_field->init(table);\n    new_field->orig_table= org_field->orig_table;\n    if (item)\n      item->result_field= new_field;\n    else\n      new_field->field_name= name;\n    new_field->flags|= (org_field->flags & NO_DEFAULT_VALUE_FLAG);\n    if (org_field->maybe_null() || (item && item->maybe_null))\n      new_field->flags&= ~NOT_NULL_FLAG;\t\n    if (org_field->type() == MYSQL_TYPE_VAR_STRING ||\n        org_field->type() == MYSQL_TYPE_VARCHAR)\n      table->s->db_create_options|= HA_OPTION_PACK_RECORD;\n    else if (org_field->type() == FIELD_TYPE_DOUBLE)\n      ((Field_double *) new_field)->not_fixed= TRUE;\n    new_field->vcol_info= 0;\n    new_field->cond_selectivity= 1.0;\n    new_field->next_equal_field= NULL;\n    new_field->option_list= NULL;\n    new_field->option_struct= NULL;\n  }\n  return new_field;\n}", "target": 1}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    while (xref_offset)\n    {\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n             methnum = ap_method_register(cmd->pool,\n                                          apr_pstrdup(cmd->pool, method));\n         }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 1}
{"code": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n    uint8_t *start = pkt;\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            case 0x0:\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            case 0x1:\n                return TM_ECODE_FAILED;\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n    return TM_ECODE_FAILED;\n}", "target": 1}
{"code": "void xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}", "target": 1}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "static int irda_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct sockaddr_irda saddr;\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->dtsap_sel;\n\t\tsaddr.sir_addr = self->daddr;\n\t} else {\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->stsap_sel;\n\t\tsaddr.sir_addr = self->saddr;\n\t}\n\tIRDA_DEBUG(1, \"%s(), tsap_sel = %#x\\n\", __func__, saddr.sir_lsap_sel);\n\tIRDA_DEBUG(1, \"%s(), addr = %08x\\n\", __func__, saddr.sir_addr);\n\t*uaddr_len = sizeof (struct sockaddr_irda);\n\tmemcpy(uaddr, &saddr, *uaddr_len);\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": " double ConvolverNode::latencyTime() const\n {\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n }", "target": 1}
{"code": "unsigned int get_random_int(void)\n{\n\treturn secure_ip_id((__force __be32)(current->pid + jiffies));\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n }", "target": 1}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 1}
{"code": "look_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \"org.freedesktop.Accounts\",\n                                                             \"/org/freedesktop/Accounts\",\n                                                             \"org.freedesktop.Accounts\",\n                                                             NULL,\n                                                             &error);\n        if (!priv->accountsservice_proxy) {\n                g_critical (\"Failed to contact accountsservice: %s\", error->message);\n                goto out;\n        }\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \"ListCachedUsers\",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n        if (!call_result) {\n                g_critical (\"Failed to list cached users: %s\", error->message);\n                goto out;\n        }\n        g_variant_get (call_result, \"(@ao)\", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n        return priv->accountsservice_proxy != NULL && call_result != NULL;\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": " cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n {\n \tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n \tDPRINTF((\"Chain:\"));\n \tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\treturn (size_t)-1;\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}", "target": 1}
{"code": "void RenderSVGImage::paint(PaintInfo& paintInfo, const LayoutPoint&)\n{\n    ANNOTATE_GRAPHICS_CONTEXT(paintInfo, this);\n    if (paintInfo.context->paintingDisabled() || style()->visibility() == HIDDEN || !m_imageResource->hasImage())\n        return;\n    FloatRect boundingBox = repaintRectInLocalCoordinates();\n    if (!SVGRenderSupport::paintInfoIntersectsRepaintRect(boundingBox, m_localTransform, paintInfo))\n        return;\n    PaintInfo childPaintInfo(paintInfo);\n    bool drawsOutline = style()->outlineWidth() && (childPaintInfo.phase == PaintPhaseOutline || childPaintInfo.phase == PaintPhaseSelfOutline);\n    if (drawsOutline || childPaintInfo.phase == PaintPhaseForeground) {\n         GraphicsContextStateSaver stateSaver(*childPaintInfo.context);\n         childPaintInfo.applyTransform(m_localTransform);\n        if (childPaintInfo.phase == PaintPhaseForeground) {\n             SVGRenderingContext renderingContext(this, childPaintInfo);\n             if (renderingContext.isRenderingPrepared()) {\n                if (style()->svgStyle()->bufferedRendering() == BR_STATIC  && renderingContext.bufferForeground(m_bufferedForeground))\n                     return;\n                 paintForeground(childPaintInfo);\n            }\n        }\n        if (drawsOutline)\n            paintOutline(childPaintInfo, IntRect(boundingBox));\n    }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n \t\tgoto drop;\n \t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n \t\treturn 0;\n\t}\n \topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n \tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    SafeStringValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "HttpHeader::chunked() const\n{\n    return has(Http::HdrType::TRANSFER_ENCODING) &&\n           hasListMember(Http::HdrType::TRANSFER_ENCODING, \"chunked\", ',');\n}", "target": 1}
{"code": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[1024];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    sprintf (pathName, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}", "target": 1}
{"code": "void SoundTouch::setChannels(uint numChannels)\n{\n    channels = numChannels;\n    pRateTransposer->setChannels((int)numChannels);\n    pTDStretch->setChannels((int)numChannels);\n}", "target": 1}
{"code": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}", "target": 1}
{"code": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { \n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}", "target": 1}
{"code": "static void part_write_body(const struct message_part *part,\n\t\t\t    string_t *str, bool extended)\n{\n\tconst struct message_part_data *data = part->data;\n\tbool text;\n\ti_assert(part->data != NULL);\n\tif ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tstr_append(str, \"\\\"message\\\" \\\"rfc822\\\"\");\n\t\ttext = FALSE;\n\t} else {\n\t\tif (data->content_type == NULL) {\n\t\t\ttext = TRUE;\n\t\t\tstr_append(str, \"\\\"text\\\" \\\"plain\\\"\");\n\t\t} else {\n\t\t\ttext = (strcasecmp(data->content_type, \"text\") == 0);\n\t\t\timap_append_string(str, data->content_type);\n\t\t\tstr_append_c(str, ' ');\n\t\t\timap_append_string(str, data->content_subtype);\n\t\t}\n\t}\n\tstr_append_c(str, ' ');\n\tparams_write(data->content_type_params,\n\t\tdata->content_type_params_count, str, text);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_id);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_description);\n\tstr_append_c(str, ' ');\n\tif (data->content_transfer_encoding != NULL)\n\t\timap_append_string(str, data->content_transfer_encoding);\n\telse\n\t\tstr_append(str, \"\\\"7bit\\\"\");\n\tstr_printfa(str, \" %\"PRIuUOFF_T, part->body_size.virtual_size);\n\tif (text) {\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tconst struct message_part_data *child_data;\n\t\ti_assert(part->children != NULL);\n\t\ti_assert(part->children->next == NULL);\n\t\tchild_data = part->children->data;\n\t\tstr_append(str, \" (\");\n\t\timap_envelope_write(child_data->envelope, str);\n\t\tstr_append(str, \") \");\n\t\tpart_write_bodystructure_siblings(part->children, str, extended);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t}\n\tif (!extended)\n\t\treturn;\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_md5);\n\tpart_write_bodystructure_common(data, str);\n}", "target": 1}
{"code": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }", "target": 1}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n \tif (iter) {\n \t\tclass_dev_iter_exit(iter);\n \t\tkfree(iter);\n \t}\n }", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char print_buffer[256];\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}", "target": 1}
{"code": "static CURLcode imap_state_fetch_resp(struct connectdata *conn, int imapcode,\n                                      imapstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct pingpong *pp = &imapc->pp;\n  const char *ptr = data->state.buffer;\n  bool parsed = FALSE;\n  curl_off_t size = 0;\n  (void)instate; \n  if(imapcode != '*') {\n    Curl_pgrsSetDownloadSize(data, -1);\n    state(conn, IMAP_STOP);\n    return CURLE_REMOTE_FILE_NOT_FOUND; \n  }\n  while(*ptr && (*ptr != '{'))\n    ptr++;\n  if(*ptr == '{') {\n    char *endptr;\n    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {\n      if(endptr - ptr > 1 && endptr[0] == '}' &&\n         endptr[1] == '\\r' && endptr[2] == '\\0')\n        parsed = TRUE;\n    }\n  }\n  if(parsed) {\n    infof(data, \"Found %\" CURL_FORMAT_CURL_OFF_TU \" bytes to download\\n\",\n          size);\n    Curl_pgrsSetDownloadSize(data, size);\n    if(pp->cache) {\n      size_t chunk = pp->cache_size;\n      if(chunk > (size_t)size)\n        chunk = (size_t)size;\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, pp->cache, chunk);\n      if(result)\n        return result;\n      data->req.bytecount += chunk;\n      infof(data, \"Written %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes, %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes are left for transfer\\n\", (curl_off_t)chunk,\n            size - chunk);\n      if(pp->cache_size > chunk) {\n        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);\n        pp->cache_size -= chunk;\n      }\n      else {\n        Curl_safefree(pp->cache);\n        pp->cache_size = 0;\n      }\n    }\n    if(data->req.bytecount == size)\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n    else {\n      data->req.maxdownload = size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, size, FALSE, NULL, -1, NULL);\n    }\n  }\n  else {\n    failf(pp->conn->data, \"Failed to parse FETCH response.\");\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  state(conn, IMAP_STOP);\n  return result;\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 1}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n \tif (url_len < 1)\n \t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n \tif (port_len) {\n \t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "static void xgmac_enet_send(XgmacState *s)\n{\n    struct desc bd;\n    int frame_size;\n    int len;\n    uint8_t frame[8192];\n    uint8_t *ptr;\n    ptr = frame;\n    frame_size = 0;\n    while (1) {\n        xgmac_read_desc(s, &bd, 0);\n        if ((bd.ctl_stat & 0x80000000) == 0) {\n            break;\n        }\n        len = (bd.buffer1_size & 0xfff) + (bd.buffer2_size & 0xfff);\n        if ((bd.buffer1_size & 0xfff) > 2048) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 1 len on send > 2048 (0x%x)\\n\",\n                         __func__, bd.buffer1_size & 0xfff);\n        }\n        if ((bd.buffer2_size & 0xfff) != 0) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 2 len on send != 0 (0x%x)\\n\",\n                        __func__, bd.buffer2_size & 0xfff);\n        }\n        if (len >= sizeof(frame)) {\n            DEBUGF_BRK(\"qemu:%s: buffer overflow %d read into %zu \"\n                        \"buffer\\n\" , __func__, len, sizeof(frame));\n            DEBUGF_BRK(\"qemu:%s: buffer1.size=%d; buffer2.size=%d\\n\",\n                        __func__, bd.buffer1_size, bd.buffer2_size);\n        }\n        cpu_physical_memory_read(bd.buffer1_addr, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.ctl_stat & 0x20000000) {\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->regs[DMA_STATUS] |= DMA_STATUS_TI | DMA_STATUS_NIS;\n        }\n        bd.ctl_stat &= ~0x80000000;\n        xgmac_write_desc(s, &bd, 0);\n    }\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n \t\tconst char __user *buffer, size_t count, loff_t *pos)\n {\n \tchar *end, buf[sizeof(\"nnnnn\\0\")];\n \tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n \t\treturn -EFAULT;\n \ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, \"Tag[%u] \", *data));\n            else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n               if (*data)\n                 ND_PRINT((ndo, \"Tag[%u] \", *data));\n               else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n            ND_PRINT((ndo, \"%s (0x%02x) \",\n                   tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                   *data));\n           data++;\n           length--;\n         break;\n    }\n   for (i=0; *data && i < length ; i++, data++)\n        ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n    return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n \t\treturn -ENOMEM;\n \tsize = roundup(size, PAGE_SIZE);\n \tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n \t\treturn ret;\n \tbo->dumb = false;\n \tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 1}
{"code": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n if (RAW != '%')\n return;\n    NEXT;\n    name = xmlParseName(ctxt);\n if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n \"xmlParsePEReference: no name\\n\");\n return;\n }\n if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n return;\n }\n    NEXT;\n    ctxt->nbentities++;\n if ((ctxt->sax != NULL) &&\n (ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n if (ctxt->instate == XML_PARSER_EOF)\n return;\n if (entity == NULL) {\n if ((ctxt->standalone == 1) ||\n ((ctxt->hasExternalSubset == 0) &&\n (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n } else {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n }\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n } else {\n if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n } else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n if (xmlPushInput(ctxt, input) < 0)\n return;\n if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n (IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n if (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    xmlHaltParser(ctxt);\n return;\n }\n }\n }\n }\n    ctxt->hasPErefs = 1;\n}", "target": 1}
{"code": "cvtchar(register const char *sp)\n{\n    unsigned char c = 0;\n    int len;\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tc = UChar(*++sp);\n\tif (c == '?')\n\t    c = 127;\n\telse\n\t    c &= 0x1f;\n\tlen = 2;\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}", "target": 1}
{"code": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n out:\n \tskb_free_datagram(sk, skb);\nout_nofree:\n\treturn rval;\n}", "target": 1}
{"code": " int prepare_binprm(struct linux_binprm *bprm)\n {\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n \tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n \tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n    buf4++;\n     buf = (const unsigned char FAR *)buf4;\n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tsize = rz_buf_read(buffer, s1, n1);\n\tif (size != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else\n\t\tn2 = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tsize = rz_buf_read(buffer, s2, n2);\n\tif (size != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n  if (overflow2(sizeof (unsigned char *), sy)) {\n\tgdFree(im);\n\treturn NULL;\n  }\n  im = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n  memset (im, 0, sizeof (gdImage));\n  im->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; (i < sy); i++)\n    {\n      im->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\t\tif (!im->pixels[i]) \n\t\t\t{\n\t\t\t\tfor (--i ; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t\t}\n\t\t\t\tgdFree(im);\n\t\t\t\treturn NULL;\n\t\t\t}\n    }\n  im->sx = sx;\n  im->sy = sy;\n  im->colorsTotal = 0;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->thick = 1;\n  im->AA = 0;\n  for (i = 0; (i < gdMaxColors); i++)\n    {\n      im->open[i] = 1;\n      im->red[i] = 0;\n      im->green[i] = 0;\n      im->blue[i] = 0;\n    };\n  im->trueColor = 0;\n  im->tpixels = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  return im;\n}", "target": 1}
{"code": "find_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); \n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\tcol += MB_CHAR2LEN(regstart); \n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n\t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n \tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "static int parseValuesReturnFilter (\n\tOperation *op,\n\tSlapReply *rs,\n\tLDAPControl *ctrl )\n{\n\tBerElement\t*ber;\n\tstruct berval\tfstr = BER_BVNULL;\n\tif ( op->o_valuesreturnfilter != SLAP_CONTROL_NONE ) {\n\t\trs->sr_text = \"valuesReturnFilter control specified multiple times\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISNULL( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is absent\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISEMPTY( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is empty\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tber = ber_init( &(ctrl->ldctl_value) );\n\tif (ber == NULL) {\n\t\trs->sr_text = \"internal error\";\n\t\treturn LDAP_OTHER;\n\t}\n\trs->sr_err = get_vrFilter( op, ber,\n\t\t(ValuesReturnFilter **)&(op->o_vrFilter), &rs->sr_text);\n\t(void) ber_free( ber, 1 );\n\tif( rs->sr_err != LDAP_SUCCESS ) {\n\t\tif( rs->sr_err == SLAPD_DISCONNECT ) {\n\t\t\trs->sr_err = LDAP_PROTOCOL_ERROR;\n\t\t\tsend_ldap_disconnect( op, rs );\n\t\t\trs->sr_err = SLAPD_DISCONNECT;\n\t\t} else {\n\t\t\tsend_ldap_result( op, rs );\n\t\t}\n\t\tif( op->o_vrFilter != NULL) vrFilter_free( op, op->o_vrFilter ); \n\t}\n#ifdef LDAP_DEBUG\n\telse {\n\t\tvrFilter2bv( op, op->o_vrFilter, &fstr );\n\t}\n\tDebug( LDAP_DEBUG_ARGS, \"\tvrFilter: %s\\n\",\n\t\tfstr.bv_len ? fstr.bv_val : \"empty\", 0, 0 );\n\top->o_tmpfree( fstr.bv_val, op->o_tmpmemctx );\n#endif\n\top->o_valuesreturnfilter = ctrl->ldctl_iscritical\n\t\t? SLAP_CONTROL_CRITICAL\n\t\t: SLAP_CONTROL_NONCRITICAL;\n\trs->sr_err = LDAP_SUCCESS;\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(\n    const ChildProcessLauncherHelper::Process& process,\n    bool known_dead) {\n  ChildProcessTerminationInfo info;\n   if (!java_peer_avaiable_on_client_thread_)\n     return info;\n  Java_ChildProcessLauncherHelperImpl_getTerminationInfo(\n       AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));\n   base::android::ApplicationState app_state =\n      base::android::ApplicationStatusListener::GetState();\n  bool app_foreground =\n      app_state == base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES ||\n      app_state == base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES;\n  if (app_foreground &&\n      (info.binding_state == base::android::ChildBindingState::MODERATE ||\n       info.binding_state == base::android::ChildBindingState::STRONG)) {\n    info.status = base::TERMINATION_STATUS_OOM_PROTECTED;\n  } else {\n    info.status = base::TERMINATION_STATUS_NORMAL_TERMINATION;\n  }\n  return info;\n}", "target": 1}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n \tif (err == -EINPROGRESS)\n \t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n }", "target": 1}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 1}
{"code": " FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {\n   const DictionaryValue* dict = GetExtensionPref(extension_id);\n   std::string path;\n   if (!dict->GetString(kPrefPath, &path))\n     return FilePath();\n  return install_directory_.Append(FilePath::FromWStringHack(UTF8ToWide(path)));\n}", "target": 1}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "get_password(const char *prompt, char *input, int capacity)\n{\n#ifdef ENABLE_SYSTEMD\n\tint is_systemd_running;\n\tstruct stat a, b;\n\tis_systemd_running = (lstat(\"/sys/fs/cgroup\", &a) == 0)\n\t\t&& (lstat(\"/sys/fs/cgroup/systemd\", &b) == 0)\n\t\t&& (a.st_dev != b.st_dev);\n\tif (is_systemd_running) {\n\t\tchar *cmd, *ret;\n\t\tFILE *ask_pass_fp = NULL;\n\t\tcmd = ret = NULL;\n\t\tif (asprintf(&cmd, \"systemd-ask-password \\\"%s\\\"\", prompt) >= 0) {\n\t\t\task_pass_fp = popen (cmd, \"re\");\n\t\t\tfree (cmd);\n\t\t}\n\t\tif (ask_pass_fp) {\n\t\t\tret = fgets(input, capacity, ask_pass_fp);\n\t\t\tpclose(ask_pass_fp);\n\t\t}\n\t\tif (ret) {\n\t\t\tint len = strlen(input);\n\t\t\tif (input[len - 1] == '\\n')\n\t\t\t\tinput[len - 1] = '\\0';\n\t\t\treturn input;\n\t\t}\n\t}\n#endif\n\tchar *tmp_pass = getpass(prompt);\n\tif (!tmp_pass)\n\t\treturn NULL;\n\tstrncpy(input, tmp_pass, capacity - 1);\n\tinput[capacity - 1] = '\\0';\n\tmemset(tmp_pass, 0, strlen(tmp_pass));\n\treturn input;\n}", "target": 1}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  return(ProcessMSLScript(image_info,&msl_image,exception));\n}", "target": 1}
{"code": "void FontInfoScanner::scanFonts(XRef *xrefA, Dict *resDict, std::vector<FontInfo*> *fontsList) {\n  GfxFontDict *gfxFontDict;\n  GfxFont *font;\n  gfxFontDict = nullptr;\n  const Object &fontObj = resDict->lookupNF(\"Font\");\n  if (fontObj.isRef()) {\n    Object obj2 = fontObj.fetch(xrefA);\n    if (obj2.isDict()) {\n      Ref r = fontObj.getRef();\n      gfxFontDict = new GfxFontDict(xrefA, &r, obj2.getDict());\n    }\n  } else if (fontObj.isDict()) {\n    gfxFontDict = new GfxFontDict(xrefA, nullptr, fontObj.getDict());\n  }\n  if (gfxFontDict) {\n    for (int i = 0; i < gfxFontDict->getNumFonts(); ++i) {\n      if ((font = gfxFontDict->getFont(i))) {\n        Ref fontRef = *font->getID();\n        if (fonts.find(fontRef.num) == fonts.end()) {\n\t  fontsList->push_back(new FontInfo(font, xrefA));\n          fonts.insert(fontRef.num);\n        }\n      }\n    }\n    delete gfxFontDict;\n  }\n  const char *resTypes[] = { \"XObject\", \"Pattern\" };\n  for (unsigned int resType = 0; resType < sizeof(resTypes) / sizeof(resTypes[0]); ++resType) {\n    Object objDict = resDict->lookup(resTypes[resType]);\n    if (objDict.isDict()) {\n      for (int i = 0; i < objDict.dictGetLength(); ++i) {\n        const Object &dictObjI = objDict.dictGetValNF(i);\n        if (dictObjI.isRef()) {\n          const Ref r = dictObjI.getRef();\n          if (visitedObjects.find(r.num) != visitedObjects.end()) {\n            continue;\n          }\n          visitedObjects.insert(r.num);\n        }\n        Object obj2 = dictObjI.fetch(xrefA);\n        if (obj2.isStream()) {\n          Object resObj = obj2.streamGetDict()->lookup(\"Resources\");\n          if (resObj.isDict() && resObj.getDict() != resDict) {\n            scanFonts(xrefA, resObj.getDict(), fontsList);\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  strcpy(addr.sun_path, sockFile);\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n  return sock;\n#endif\n}", "target": 1}
{"code": "inline void* Zone::New(int size) {\n  ASSERT(scope_nesting_ > 0);\n  size = RoundUp(size, kAlignment);\n  if (kPointerSize == 4 && kAlignment == 4) {\n    position_ += ((~size) & 4) & (reinterpret_cast<intptr_t>(position_) & 4);\n  } else {\n    ASSERT(kAlignment >= kPointerSize);\n  }\n  Address result = position_;\n  if (size > limit_ - position_) {\n     result = NewExpand(size);\n  } else {\n     position_ += size;\n  }\n  ASSERT(IsAddressAligned(result, kAlignment, 0));\n  allocation_size_ += size;\n  return reinterpret_cast<void*>(result);\n}", "target": 1}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t busid)\n{\n    uint32_t cmdlen;\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    cmdlen = fifo8_num_used(&s->cmdfifo);\n    esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    fifo8_reset(&s->cmdfifo);\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        s->ti_cmd = 0;\n        esp_set_tc(s, 0);\n        if (datalen > 0) {\n            s->data_in_ready = false;\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            esp_raise_irq(s);\n            esp_lower_drq(s);\n        }\n        scsi_req_continue(s->current_req);\n        return;\n    }\n}", "target": 1}
{"code": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval;\n\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trio->rio_dev = dev;\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\tmutex_init(&(rio->lock));\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\n\treturn 0;\n}", "target": 1}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n \tstruct flowi4 fl4;\n \tint error = 0;\n \tif (sp->sa_protocol != PX_PROTO_PPTP)\n \t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": " void red_channel_pipes_add_empty_msg(RedChannel *channel, int msg_type)\n {\n    RingItem *link;\n    RING_FOREACH(link, &channel->clients) {\n         red_channel_client_pipe_add_empty_msg(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             msg_type);\n    }\n}", "target": 1}
{"code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n \t\tgoto out;\n \t}\n \tret = vfs_dedupe_file_range(file, same);\n \tif (ret)\n \t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}", "target": 1}
{"code": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}", "target": 1}
{"code": "static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\tdst_confirm(dst);\n\tif (mtu < dst_mtu(dst) && rt6->rt6i_dst.plen == 128) {\n\t\tstruct net *net = dev_net(dst->dev);\n\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tu32 features = dst_metric(dst, RTAX_FEATURES);\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tfeatures |= RTAX_FEATURE_ALLFRAG;\n\t\t\tdst_metric_set(dst, RTAX_FEATURES, features);\n\t\t}\n\t\tdst_metric_set(dst, RTAX_MTU, mtu);\n\t\trt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);\n\t}\n}", "target": 1}
{"code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n    return BSON_OK;\n}", "target": 1}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n {\n \tstruct common_audit_data sa;\n \tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n \tsize_t arg_size;\n \tint error;\n \tif (size == 0)\n \t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n \tif (current != task)\n \t\treturn -EACCES;\n\targs = value;\n \targs = strim(args);\n \tcommand = strsep(&args, \" \");\n \tif (!args)\n\t\treturn -EINVAL;\n \targs = skip_spaces(args);\n \tif (!*args)\n\t\treturn -EINVAL;\n \targ_size = size - (args - (char *) value);\n \tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n \t\t\tgoto fail;\n \t} else\n\t\treturn -EINVAL;\n \tif (!error)\n \t\terror = size;\n \treturn error;\n fail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n \taad.profile = aa_current_profile();\n \taad.op = OP_SETPROCATTR;\n \taad.info = name;\n\taad.error = -EINVAL;\n \taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n }", "target": 1}
{"code": "int tls1_cbc_remove_padding(const SSL* s,\n\t\t\t    SSL3_RECORD *rec,\n\t\t\t    unsigned block_size,\n\t\t\t    unsigned mac_size)\n\t{\n\tunsigned padding_length, good, to_check, i;\n\tconst char has_explicit_iv =\n\t\ts->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;\n\tconst unsigned overhead = 1  +\n\t\t\t\t  mac_size +\n\t\t\t\t  (has_explicit_iv ? block_size : 0);\n\tif (overhead > rec->length)\n\t\treturn 0;\n\tif (has_explicit_iv)\n\t\t{\n\t\trec->data += block_size;\n\t\trec->input += block_size;\n\t\trec->length -= block_size;\n\t\t}\n\tpadding_length = rec->data[rec->length-1];\n\tif ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand)\n\t\t{\n\t\tif ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) &&\n\t\t    !(padding_length & 1))\n\t\t\t{\n\t\t\ts->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\n\t\t\t}\n\t\tif ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) &&\n\t\t    padding_length > 0)\n\t\t\t{\n\t\t\tpadding_length--;\n\t\t\t}\n\t\t}\n\tif (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)\n\t\t{\n\t\trec->length -= padding_length;\n\t\treturn 1;\n\t\t}\n\tgood = constant_time_ge(rec->length, overhead+padding_length);\n\tto_check = 255; \n\tif (to_check > rec->length-1)\n\t\tto_check = rec->length-1;\n\tfor (i = 0; i < to_check; i++)\n\t\t{\n\t\tunsigned char mask = constant_time_ge(padding_length, i);\n\t\tunsigned char b = rec->data[rec->length-1-i];\n\t\tgood &= ~(mask&(padding_length ^ b));\n\t\t}\n\tgood &= good >> 4;\n\tgood &= good >> 2;\n\tgood &= good >> 1;\n\tgood <<= sizeof(good)*8-1;\n\tgood = DUPLICATE_MSB_TO_ALL(good);\n\tpadding_length = good & (padding_length+1);\n\trec->length -= padding_length;\n\trec->type |= padding_length<<8;\t\n\treturn (int)((good & 1) | (~good & -1));\n\t}", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"empty string\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 1}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {\n unsigned int cpy_len, rem_len;\n uint32_t list_len;\n uint8_t* p;\n uint8_t type;\n#if (SDP_DEBUG_RAW == TRUE)\n uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];\n uint32_t i;\n for (i = 0; i < p_ccb->list_len; i++) {\n    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, \"%02X\",\n (uint8_t)(p_ccb->rsp_list[i]));\n }\n  SDP_TRACE_WARNING(\"result :%s\", num_array);\n#endif\n if (p_ccb->p_db->raw_data) {\n    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;\n    list_len = p_ccb->list_len;\n     p = &p_ccb->rsp_list[0];\n     if (offset) {\n       type = *p++;\n       p = sdpu_get_len_from_type(p, type, &list_len);\n     }\n     if (list_len < cpy_len) {\n       cpy_len = list_len;\n }\n    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);\n if (cpy_len > rem_len) {\n      SDP_TRACE_WARNING(\"rem_len :%d less than cpy_len:%d\", rem_len, cpy_len);\n      cpy_len = rem_len;\n }\n    SDP_TRACE_WARNING(\n \"%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d \"\n \"raw_used:%d raw_data:%p\",\n        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,\n        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);\n    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);\n    p_ccb->p_db->raw_used += cpy_len;\n }\n}", "target": 1}
{"code": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n if (size < 4 || size == SIZE_MAX) {\n return ERROR_MALFORMED;\n }\n uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n delete[] buffer;\n        buffer = NULL;\n return ERROR_IO;\n }\n uint32_t metadataKey = 0;\n switch (mPath[depth]) {\n case FOURCC('t', 'i', 't', 'l'):\n {\n            metadataKey = kKeyTitle;\n break;\n }\n case FOURCC('p', 'e', 'r', 'f'):\n {\n            metadataKey = kKeyArtist;\n break;\n }\n case FOURCC('a', 'u', 't', 'h'):\n {\n            metadataKey = kKeyWriter;\n break;\n }\n case FOURCC('g', 'n', 'r', 'e'):\n {\n            metadataKey = kKeyGenre;\n break;\n }\n case FOURCC('a', 'l', 'b', 'm'):\n {\n if (buffer[size - 1] != '\\0') {\n char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n }\n            metadataKey = kKeyAlbum;\n break;\n }\n case FOURCC('y', 'r', 'r', 'c'):\n {\n char tmp[5];\n uint16_t year = U16_AT(&buffer[4]);\n if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n                mFileMetaData->setCString(kKeyYear, tmp);\n }\n break;\n }\n default:\n break;\n }\n if (metadataKey > 0) {\n bool isUTF8 = true; \n char16_t *framedata = NULL;\n         int len16 = 0; \n         if (size - 6 >= 4) {\n             len16 = ((size - 6) / 2) - 1; \n             framedata = (char16_t *)(buffer + 6);\n if (0xfffe == *framedata) {\n for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n }\n }\n if (0xfeff == *framedata) {\n                framedata++;\n                len16--;\n                isUTF8 = false;\n }\n }\n if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n } else {\n String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n }\n }\n delete[] buffer;\n    buffer = NULL;\n return OK;\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n   return 0;\n  fail:\n   vp9_free_context_buffers(cm);\n   return 1;\n }", "target": 1}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 1}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n\t\trequest_module(\"%s\", name);\n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n     if (error) {\n       std::move(callback).Run(error, nullptr,\n                               nullptr);\n      return;\n    }\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n    std::move(callback).Run(base::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n{\n\tstruct warc_s *w = a->format->data;\n\tconst char *rab;\n\tssize_t nrd;\n\tif (w->cntoff >= w->cntlen) {\n\teof:\n\t\t*buf = NULL;\n\t\t*bsz = 0U;\n\t\t*off = w->cntoff + 4U;\n\t\tw->unconsumed = 0U;\n \t\treturn (ARCHIVE_EOF);\n \t}\n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;\n\t\treturn (int)nrd;\n\t} else if (nrd == 0) {\n\t\tgoto eof;\n\t} else if ((size_t)nrd > w->cntlen - w->cntoff) {\n\t\tnrd = w->cntlen - w->cntoff;\n\t}\n\t*off = w->cntoff;\n\t*bsz = nrd;\n\t*buf = rab;\n\tw->cntoff += nrd;\n\tw->unconsumed = (size_t)nrd;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \tif (!asoc)\n \t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 1}
{"code": "static int svc_listen(struct socket *sock,int backlog)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\tpr_debug(\"svc_listen %p\\n\",vcc);\n\tlock_sock(sk);\n\tif (test_bit(ATM_VF_SESSION,&vcc->flags)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tvcc_insert_socket(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\tsigd_enq(vcc,as_listen,NULL,NULL,&vcc->local);\n\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\tschedule();\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_LISTEN,&vcc->flags);\n\tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n     data = malloc(size * sizeof(krb5_data));\n     if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n     while (!retval && (component = va_arg(ap, char *))) {\n         if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     \n    memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n    code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                len - devlen);\n    if (code == ~(uint) 0) {    \n        esp -= 5;               \n        return o_pop_estack;\n    } else if (code > len)      \n        return_error(gs_error_rangecheck);\n    else {\n        push(1);\n        ref_assign(op, pscratch);\n        r_set_size(op, code + devlen);\n        push_op_estack(file_continue);  \n        *++esp = pscratch[2];   \n        return o_push_estack;\n    }\n}", "target": 1}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "static struct kobject *cdev_get(struct cdev *p)\n{\n\tstruct module *owner = p->owner;\n\tstruct kobject *kobj;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&p->kobj);\n\tif (!kobj)\n\t\tmodule_put(owner);\n\treturn kobj;\n}", "target": 1}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 1}
{"code": "void RenderThreadImpl::Shutdown() {\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, OnRenderProcessShutdown());\n  ChildThread::Shutdown();\n  if (memory_observer_) {\n    message_loop()->RemoveTaskObserver(memory_observer_.get());\n    memory_observer_.reset();\n  }\n   if (webkit_platform_support_) {\n     webkit_platform_support_->web_database_observer_impl()->\n         WaitForAllDatabasesToClose();\n   }\n  if (devtools_agent_message_filter_.get()) {\n    RemoveFilter(devtools_agent_message_filter_.get());\n    devtools_agent_message_filter_ = NULL;\n  }\n  RemoveFilter(audio_input_message_filter_.get());\n  audio_input_message_filter_ = NULL;\n  RemoveFilter(audio_message_filter_.get());\n  audio_message_filter_ = NULL;\n#if defined(ENABLE_WEBRTC)\n  RTCPeerConnectionHandler::DestructAllHandlers();\n  peer_connection_factory_.reset();\n#endif\n  RemoveFilter(vc_manager_->video_capture_message_filter());\n  vc_manager_.reset();\n  RemoveFilter(db_message_filter_.get());\n  db_message_filter_ = NULL;\n  if (file_thread_)\n    file_thread_->Stop();\n  if (compositor_output_surface_filter_.get()) {\n    RemoveFilter(compositor_output_surface_filter_.get());\n    compositor_output_surface_filter_ = NULL;\n  }\n  media_thread_.reset();\n  compositor_thread_.reset();\n  input_handler_manager_.reset();\n  if (input_event_filter_.get()) {\n    RemoveFilter(input_event_filter_.get());\n    input_event_filter_ = NULL;\n  }\n  embedded_worker_dispatcher_.reset();\n  main_thread_indexed_db_dispatcher_.reset();\n  if (webkit_platform_support_)\n    blink::shutdown();\n  lazy_tls.Pointer()->Set(NULL);\n#if defined(OS_WIN)\n  NPChannelBase::CleanupChannels();\n#endif\n}", "target": 1}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 1}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n         return NULL;\n     }\n    SkBitmap* bitmap = new SkBitmap;\n    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n             ctable = new SkColorTable(src, count);\n         }\n     }\n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n        delete bitmap;\n         return NULL;\n     }\n SkSafeUnref(ctable);\n size_t size = bitmap->getSize();\n    android::Parcel::ReadableBlob blob;\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        delete bitmap;\n         return NULL;\n     }\n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n     blob.release();\n    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n            NULL, NULL, density);\n }", "target": 1}
{"code": "WCHAR* VDir::MapPathW(const WCHAR *pInName)\n{   \n    WCHAR szBuffer[(MAX_PATH+1)*2];\n    WCHAR szlBuf[MAX_PATH+1];\n    int length = wcslen(pInName);\n    if (!length)\n\treturn (WCHAR*)pInName;\n    if (length > MAX_PATH) {\n\twcsncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    if (pInName[1] == ':') {\n\tif (IsPathSep(pInName[2])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDirW(DriveIndex((char)*pInName)));\n\t    wcscat(szBuffer, &pInName[2]);\n\t    if(wcslen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n    }\n    else {\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDefaultDirW());\n\t    if (IsPathSep(pInName[0])) {\n\t\twcscpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t    }\n\t    else {\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (WCHAR*)pInName;\n\t\t}\n\t\telse {\n\t\t    wcscat(szBuffer, pInName);\n\t\t    if (wcslen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\t\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t\t}\n\t    }\n\t}\n    }\n    return szLocalBufferW;\n}", "target": 1}
{"code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}", "target": 1}
{"code": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }", "target": 1}
{"code": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n  return false;\n}", "target": 1}
{"code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n \tOM_uint32 tmpmin;\n \tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n \tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n \t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static int __init serial_ir_init_module(void)\n{\n\tint result;\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\tcase IR_ANIMAX:\n\tcase IR_IGOR:\n\t\tio = io ? io : 0x3f8;\n\t\tirq = irq ? irq : 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!softcarrier) {\n\t\tswitch (type) {\n\t\tcase IR_HOMEBREW:\n\t\tcase IR_IGOR:\n\t\t\thardware[type].set_send_carrier = false;\n\t\t\thardware[type].set_duty_cycle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sense != -1)\n\t\tsense = !!sense;\n\tresult = serial_ir_init();\n\tif (!result)\n\t\treturn 0;\n\tserial_ir_exit();\n\treturn result;\n}", "target": 1}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n \tkey = key_ref_to_ptr(key_ref);\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n \tdp = (const struct ip6_frag *)bp;\n \tip6 = (const struct ip6_hdr *)bp2;\n\tND_TCHECK(dp->ip6f_offlg);\n \tif (ndo->ndo_vflag) {\n \t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 1}
{"code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\tif (thread)\n\t\tCloseHandle (thread);\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\tg_free (this->name);\n}", "target": 1}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n }", "target": 1}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n \tchar *ptr;\n \tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n \tif (!file)\n \t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "matchCurrentInput(\n \t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n \tint k;\n \tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n \t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n \t\t\treturn 0;\n \treturn 1;\n}", "target": 1}
{"code": "static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 1}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n                struct NameValueParserData * data)\n {\n \tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n \tparser.xmlstart = buffer;\n \tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": " ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n   ActionReply reply;\n   QMapIterator<QString, QVariant> it(args);\n    proc.setOutputChannelMode(KProcess::SeparateChannels);\n    proc.setProcessEnvironment(QProcessEnvironment::systemEnvironment());\n#if defined(Q_OS_LINUX)\n    proc.setEnv(\"PASSWD\", entry[\"mh_url\"].toUrl().password(), true);\n#endif\n     QVariantMap entry = it.value().toMap();\n     KProcess proc(this);\n    command << entry[\"mh_mountpoint\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n    command << entry[\"mh_unc\"].toString();\n    command << entry[\"mh_mountpoint\"].toString();\n#else\n#endif\n    proc.setProgram(command);\n    proc.start();\n    if (proc.waitForStarted(-1))\n    {\n      bool userKill = false;\n     QStringList command;\n #if defined(Q_OS_LINUX)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n        else\n        {\n        }\n        if (HelperSupport::isStopped())\n        {\n          proc.kill();\n          userKill = true;\n          break;\n        }\n        else\n        {\n        }\n      }\n      if (proc.exitStatus() == KProcess::CrashExit)\n      {\n        if (!userKill)\n        {\n          reply.setType(ActionReply::HelperErrorType);\n          reply.setErrorDescription(i18n(\"The mount process crashed.\"));\n          break;\n        }\n        else\n        {\n        }\n      }\n      else\n      {\n        QString stdErr = QString::fromUtf8(proc.readAllStandardError());\n        reply.addData(QString(\"mh_error_message_%1\").arg(index), stdErr.trimmed());\n      }\n    }", "target": 1}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n     pkiDebug(\"found kdcPkId in AS REQ\\n\");\n     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n     if (is == NULL)\n        goto cleanup;\n     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n     if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n     }\n     retval = 0;\ncleanup:\n     X509_NAME_free(is->issuer);\n     ASN1_INTEGER_free(is->serial);\n     free(is);\n    return retval;\n}", "target": 1}
{"code": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n  g_free (raw_data);\n  return 1;\n}", "target": 1}
{"code": "static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n  if (!element->isConnected())\n    return false;\n  if (!element->IsAutofocusable())\n    return false;\n   Document& doc = element->GetDocument();\n  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control because the form's frame is \"\n        \"sandboxed and the 'allow-scripts' permission is not set.\"));\n    return false;\n  }\n  if (!doc.IsInMainFrame() &&\n      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control in a cross-origin subframe.\"));\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "AVA_Sort( LDAPRDN rdn, int nAVAs )\n{\n\tLDAPAVA\t*ava_i;\n\tint\t\ti;\n\tassert( rdn != NULL );\n\tfor ( i = 1; i < nAVAs; i++ ) {\n\t\tLDAPAVA *ava_j;\n\t\tint j;\n\t\tava_i = rdn[ i ];\n\t\tfor ( j = i-1; j >=0; j-- ) {\n\t\t\tint a;\n\t\t\tava_j = rdn[ j ];\n\t\t\ta = strcmp( ava_i->la_attr.bv_val, ava_j->la_attr.bv_val );\n\t\t\tif ( a == 0 )\n\t\t\t\treturn LDAP_INVALID_DN_SYNTAX;\n\t\t\tif ( a > 0 )\n\t\t\t\tbreak;\n\t\t\trdn[ j+1 ] = rdn[ j ];\n\t\t}\n\t\trdn[ j+1 ] = ava_i;\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}", "target": 1}
{"code": " xps_select_font_encoding(xps_font_t *font, int idx)\n {\n     byte *cmapdata, *entry;\n     int pid, eid;\n     if (idx < 0 || idx >= font->cmapsubcount)\n        return;\n     cmapdata = font->data + font->cmaptable;\n     entry = cmapdata + 4 + idx * 8;\n     pid = u16(entry + 0);\n     eid = u16(entry + 2);\n     font->cmapsubtable = font->cmaptable + u32(entry + 4);\n     font->usepua = (pid == 3 && eid == 0);\n }", "target": 1}
{"code": "void FetchManager::Loader::Start() {\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n  PerformHTTPFetch();\n}", "target": 1}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; \n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 1}
{"code": "static void ssl_write_hostname_ext( ssl_context *ssl,\n                                    unsigned char *buf,\n                                    size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->hostname == NULL )\n        return;\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding server name extension: %s\",\n                   ssl->hostname ) );\n    if( (size_t)(end - p) < ssl->hostname_len + 9 )\n    {\n         SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n         return;\n    }\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );\n    memcpy( p, ssl->hostname, ssl->hostname_len );\n    *olen = ssl->hostname_len + 9;\n}", "target": 1}
{"code": " void dvb_usbv2_disconnect(struct usb_interface *intf)\n {\n \tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n \tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n \t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n \tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n }", "target": 1}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n \t\t     const u_char *bp, u_int length,\n \t\t     const u_char *bp2)\n {\n \tif(length == 1 && bp[0]==0xff) {\n \t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n \t\treturn;\n\t}\n \tif(length < 4) {\n \t\tgoto trunc;\n \t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n     struct stat stbuf;\n     V9fsFidState *fidp;\n     V9fsPDU *pdu = opaque;\n     v9fs_stat_init(&v9stat);\n     err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n        goto out_nofid;\n    }", "target": 1}
{"code": "static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\treturn false;\n}", "target": 1}
{"code": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n }", "target": 1}
{"code": "bool FontData::Bound(int32_t offset) {\nif (offset > Size() || offset < 0)\n    return false;\n  bound_offset_ += offset;\n  return true;\n}", "target": 1}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n \t\treturn 0;\n \t}\n \tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n \t}\n \tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n \trc = jbd2_journal_stop(handle);\n \tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 1}
{"code": "  int DoWrite(WriteWrap* w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  \n  }", "target": 1}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 1}
{"code": " static blink::WebScreenOrientations stringToOrientations(const AtomicString& orientationString)\n {\n     DEFINE_STATIC_LOCAL(const AtomicString, portrait, (\"portrait\", AtomicString::ConstructFromLiteral));\n     DEFINE_STATIC_LOCAL(const AtomicString, landscape, (\"landscape\", AtomicString::ConstructFromLiteral));\n     if (orientationString == portrait)\n         return blink::WebScreenOrientationPortraitPrimary | blink::WebScreenOrientationPortraitSecondary;\n     if (orientationString == landscape)\n        return blink::WebScreenOrientationLandscapePrimary | blink::WebScreenOrientationLandscapeSecondary;\n    unsigned length = 0;\n    ScreenOrientationInfo* orientationMap = orientationsMap(length);\n    for (unsigned i = 0; i < length; ++i) {\n        if (orientationMap[i].name == orientationString)\n            return orientationMap[i].orientation;\n    }\n    return 0;\n}", "target": 1}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": " static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n \tstruct nat_entry *ne;\n\tint err;\n \tif (unlikely(nid == 0))\n \t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n \tspin_lock(&nm_i->nid_list_lock);\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\n\tif (err) {\n \t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n }", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n {\n \tstruct snd_kcontrol *kctl;\n \tlist_for_each_entry(kctl, &card->controls, list) {\n \t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n \t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}", "target": 1}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n {\n \tstruct sclp_ctl_sccb ctl_sccb;\n \tstruct sccb_header *sccb;\n \tint rc;\n \tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n \tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n \tif (!sccb)\n \t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n \t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n \trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tme = current;\n\twrite_lock_irq(&tasklist_lock);\n\tparent = me->real_parent;\n\tret = -EPERM;\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\toldcred = parent->replacement_session_keyring;\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\twrite_unlock_irq(&tasklist_lock);\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\tput_cred(cred);\n\treturn ret;\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n#else \n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif \n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 1}
{"code": "static MagickBooleanType WriteAnimatedWEBPImage(const ImageInfo *image_info,\n  Image *image,WebPConfig *configure,WebPMemoryWriter *writer_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *first_image;\n  PictureMemory\n    *current,\n    *head;\n  size_t\n    effective_delta = 0,\n    frame_timestamp = 0;\n  WebPAnimEncoder\n    *enc;\n  WebPAnimEncoderOptions\n    enc_options;\n  WebPData\n    webp_data;\n  WebPPicture\n    picture;\n  WebPAnimEncoderOptionsInit(&enc_options);\n  if (image_info->verbose)\n    enc_options.verbose = 1;\n  image=CoalesceImages(image, exception);\n  first_image=image;\n  enc=WebPAnimEncoderNew((int) image->page.width,(int) image->page.height,\n    &enc_options);\n  head=(PictureMemory *) calloc(sizeof(*head),1);\n  current=head;\n  while (image != NULL)\n  {\n    if (WebPPictureInit(&picture) == 0)\n      ThrowWriterException(ResourceLimitError,\"UnableToEncodeImageFile\");\n    WriteSingleWEBPImage(image_info, image, &picture, current, exception);\n    effective_delta = image->delay*1000/image->ticks_per_second;\n    if (effective_delta < 10)\n      effective_delta = 100; \n    frame_timestamp+=effective_delta;\n    WebPAnimEncoderAdd(enc,&picture,(int) frame_timestamp,configure);\n    image = GetNextImageInList(image);\n    current->next=(PictureMemory *) calloc(sizeof(*head), 1);\n    current = current->next;\n  }\n  webp_data.bytes=writer_info->mem;\n  webp_data.size=writer_info->size;\n  WebPAnimEncoderAssemble(enc, &webp_data);\n  WebPMemoryWriterClear(writer_info);\n  writer_info->size=webp_data.size;\n  writer_info->mem=(unsigned char *) webp_data.bytes;\n  WebPAnimEncoderDelete(enc);\n  DestroyImageList(first_image);\n  FreePictureMemoryList(head);\n  return(MagickTrue);\n}", "target": 1}
{"code": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n  if (!current_window->GetFrame())\n    return;\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}", "target": 1}
{"code": "rleUncompress (int inLength, int maxLength, const signed char in[], char out[])\n{\n    char *outStart = out;\n    while (inLength > 0)\n    {\n\tif (*in < 0)\n\t{\n\t    int count = -((int)*in++);\n\t    inLength -= count + 1;\n\t    if (0 > (maxLength -= count))\n\t\treturn 0;\n        if (inLength < 0)\n          return 0;\n        memcpy(out, in, count);\n        out += count;\n        in  += count;\n\t}\n\telse\n\t{\n\t    int count = *in++;\n\t    inLength -= 2;\n\t    if (0 > (maxLength -= count + 1))\n\t\treturn 0;\n        memset(out, *(char*)in, count+1);\n        out += count+1;\n\t    in++;\n\t}\n    }\n    return out - outStart;\n}", "target": 1}
{"code": " static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n \treturn usb_serial_generic_open(tty, port);\n }", "target": 1}
{"code": "rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n \tsize_t ibl, obl;\n \tchar *pin, *pout;\n \tif (!icv_utf16_to_local)\n \t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\tif (*string == NULL)\n\t{\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\ts->p += in_len;\n\t*pout = 0;\n\tif (*string)\n\t\t*str_size = pout - *string;\n}", "target": 1}
{"code": "void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\trowstep = jas_matrix_rowstep(matrix);\n\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t  rowstart += rowstep) {\n\t\tdata = rowstart;\n\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t  ++data) {\n\t\t\tv = *data;\n\t\t\tif (v < minval) {\n\t\t\t\t*data = minval;\n\t\t\t} else if (v > maxval) {\n\t\t\t\t*data = maxval;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "xfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint64_t\t\t\t\tsize;\n\tASSERT(ip->i_afp->if_format == XFS_DINODE_FMT_LOCAL);\n\tifp = XFS_IFORK_PTR(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\tendp = (char *)sfp + size;\n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\t\tnext_sfep = XFS_ATTR_SF_NEXTENTRY(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\treturn NULL;\n}", "target": 1}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n \tfor (;;) {\n \t\tu8 label_len;\n\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": " static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                                uint32_t prefix, int length)\n {\n     if (!bitstream_read_bit(bc)) { \n         if(hc->current >= 256){\n             av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n \tif (!data)\n \t\treturn 1;\n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}", "target": 1}
{"code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\tcpia2_usb_init();\n\treturn 0;\n}", "target": 1}
{"code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\treturn;\n#endif\n    if (scriptin[curscript] != NULL)\t\n\t++curscript;\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t\n\trestart_edit = 0;\t\n\tp_im = FALSE;\t\t\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t\n\t    normal_cmd(&oa, FALSE);\t\n\t    vpeekc();\t\t\t\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next (SEQSET_ITERATOR *iter, unsigned int *next)\n{\n  char *range_sep;\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && iter->range_cur == (iter->range_end - 1)) ||\n        (!iter->down && iter->range_cur == (iter->range_end + 1)))\n      iter->in_range = 0;\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr (iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    range_sep = strchr (iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_atoui (iter->substr_cur, &iter->range_cur))\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_atoui (range_sep, &iter->range_end))\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}", "target": 1}
{"code": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tint points;\n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\tpoints += p->signal->oom_score_adj;\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}", "target": 1}
{"code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}", "target": 1}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 1}
{"code": "int MonClient::handle_auth_request(\n  Connection *con,\n  AuthConnectionMeta *auth_meta,\n  bool more,\n  uint32_t auth_method,\n  const bufferlist& payload,\n  bufferlist *reply)\n{\n  auth_meta->auth_mode = payload[0];\n  if (auth_meta->auth_mode < AUTH_MODE_AUTHORIZER ||\n      auth_meta->auth_mode > AUTH_MODE_AUTHORIZER_MAX) {\n    return -EACCES;\n  }\n  AuthAuthorizeHandler *ah = get_auth_authorize_handler(con->get_peer_type(),\n\t\t\t\t\t\t\tauth_method);\n  if (!ah) {\n    lderr(cct) << __func__ << \" no AuthAuthorizeHandler found for auth method \"\n\t       << auth_method << dendl;\n    return -EOPNOTSUPP;\n  }\n  auto ac = &auth_meta->authorizer_challenge;\n  if (!HAVE_FEATURE(con->get_features(), CEPHX_V2)) {\n    if (cct->_conf->cephx_service_require_version >= 2) {\n      ldout(cct,10) << __func__ << \" client missing CEPHX_V2 (\"\n\t\t    << \"cephx_service_requre_version = \"\n\t\t    << cct->_conf->cephx_service_require_version << \")\" << dendl;\n      return -EACCES;\n    }\n    ac = nullptr;\n  }\n  bool was_challenge = (bool)auth_meta->authorizer_challenge;\n  bool isvalid = ah->verify_authorizer(\n    cct,\n    rotating_secrets.get(),\n    payload,\n    auth_meta->get_connection_secret_length(),\n    reply,\n    &con->peer_name,\n    &con->peer_global_id,\n    &con->peer_caps_info,\n    &auth_meta->session_key,\n    &auth_meta->connection_secret,\n    ac);\n  if (isvalid) {\n    handle_authentication_dispatcher->ms_handle_authentication(con);\n    return 1;\n  }\n  if (!more && !was_challenge && auth_meta->authorizer_challenge) {\n    ldout(cct,10) << __func__ << \" added challenge on \" << con << dendl;\n    return 0;\n  }\n  ldout(cct,10) << __func__ << \" bad authorizer on \" << con << dendl;\n  return -EACCES;\n}", "target": 1}
{"code": " static int perf_swevent_init(struct perf_event *event)\n {\n\tint event_id = event->attr.config;\n \tif (event->attr.type != PERF_TYPE_SOFTWARE)\n \t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\ng_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }", "target": 1}
{"code": "static void early_init_amd(struct cpuinfo_x86 *c)\n{\n\tearly_init_amd_mc(c);\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t\tif (!check_tsc_unstable())\n\t\t\tsched_clock_stable = 1;\n\t}\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#else\n\tif (c->x86 == 5)\n\t\tif (c->x86_model == 13 || c->x86_model == 9 ||\n\t\t    (c->x86_model == 8 && c->x86_mask >= 8))\n\t\t\tset_cpu_cap(c, X86_FEATURE_K6_MTRR);\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\tif (cpu_has_apic && c->x86 >= 0xf) {\n\t\tunsigned int val;\n\t\tval = read_pci_config(0, 24, 0, 0x68);\n\t\tif ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))\n\t\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n\t}\n#endif\n}", "target": 1}
{"code": "size_t olm_pk_decrypt(\n    OlmPkDecryption * decryption,\n    void const * ephemeral_key, size_t ephemeral_key_length,\n    void const * mac, size_t mac_length,\n    void * ciphertext, size_t ciphertext_length,\n    void * plaintext, size_t max_plaintext_length\n) {\n    if (max_plaintext_length\n            < olm_pk_max_plaintext_length(decryption, ciphertext_length)) {\n        decryption->last_error =\n            OlmErrorCode::OLM_OUTPUT_BUFFER_TOO_SMALL;\n        return std::size_t(-1);\n    }\n    struct _olm_curve25519_public_key ephemeral;\n    olm::decode_base64(\n        (const uint8_t*)ephemeral_key, ephemeral_key_length,\n        (uint8_t *)ephemeral.public_key\n    );\n    olm::SharedKey secret;\n    _olm_crypto_curve25519_shared_secret(&decryption->key_pair, &ephemeral, secret);\n    uint8_t raw_mac[MAC_LENGTH];\n    olm::decode_base64((const uint8_t*)mac, olm::encode_base64_length(MAC_LENGTH), raw_mac);\n    size_t raw_ciphertext_length = olm::decode_base64_length(ciphertext_length);\n    olm::decode_base64((const uint8_t *)ciphertext, ciphertext_length, (uint8_t *)ciphertext);\n    size_t result = _olm_cipher_aes_sha_256_ops.decrypt(\n        olm_pk_cipher,\n        secret, sizeof(secret),\n        (uint8_t *) raw_mac, MAC_LENGTH,\n        (const uint8_t *) ciphertext, raw_ciphertext_length,\n        (uint8_t *) plaintext, max_plaintext_length\n    );\n    if (result == std::size_t(-1)) {\n        decryption->last_error =\n            OlmErrorCode::OLM_BAD_MESSAGE_MAC;\n        return std::size_t(-1);\n    } else {\n        return result;\n    }\n}", "target": 1}
{"code": "gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n \t\treturn NULL;\n \t}\n \tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 1}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "static int smtp_command_parse_parameters(struct smtp_command_parser *parser)\n{\n\tconst unsigned char *p, *mp;\n\tuoff_t max_size = (parser->auth_response ?\n\t\tparser->limits.max_auth_size :\n\t\tparser->limits.max_parameters_size);\n\tp = parser->cur + parser->state.poff;\n\twhile (p < parser->end) {\n\t\tunichar_t ch;\n\t\tint nch = 1;\n\t\tif (parser->auth_response)\n\t\t\tch = *p;\n\t\telse {\n\t\t\tnch = uni_utf8_get_char_n(p, (size_t)(p - parser->end),\n\t\t\t\t\t\t  &ch);\n\t\t}\n\t\tif (nch < 0) {\n\t\t\tsmtp_command_parser_error(parser,\n\t\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\t\"Invalid UTF-8 character in command parameters\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ((parser->auth_response || (ch & 0x80) == 0x00) &&\n\t\t    !smtp_char_is_textstr((unsigned char)ch))\n\t\t\tbreak;\n\t\tp += nch;\n\t}\n\tif (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,\n\t\t\t\"%s line is too long\",\n\t\t\t(parser->auth_response ?\n\t\t\t\t\"AUTH response\" : \"Command\"));\n\t\treturn -1;\n\t}\n\tparser->state.poff = p - parser->cur;\n\tif (p == parser->end)\n\t\treturn 0;\n\tmp = p;\n\tif (mp > parser->cur) {\n\t\twhile (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\\t'))\n\t\t\tmp--;\n\t}\n\tif (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\"Duplicate space after command name\");\n\t\treturn -1;\n\t}\n\tparser->state.cmd_params = i_strdup_until(parser->cur, mp);\n\tparser->cur = p;\n\tparser->state.poff = 0;\n\treturn 1;\n}", "target": 1}
{"code": "int lg3ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff3_joystick_ac;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))\n\t\treturn -ENODEV;\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lg3ff_play);\n\tif (error)\n\t\treturn error;\n\tif (test_bit(FF_AUTOCENTER, dev->ffbit))\n\t\tdev->ff->set_autocenter = hid_lg3ff_set_autocenter;\n\thid_info(hid, \"Force feedback for Logitech Flight System G940 by Gary Stein <LordCnidarian@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n \tif (!out_buf)\n \t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n \t\tcount = DJREPORT_SHORT_LENGTH - 2;\n \tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n \t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n \t\tflush_dcache_page(page);\n \t\tif (!tmp) {\n \t\t\tunlock_page(page);\n \t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n \t\treq->page_descs[req->num_pages].length = tmp;\n \t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n \t\tcount += tmp;\n \t\tpos += tmp;\n \t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "void TabSpecificContentSettings::OnContentBlocked(\n    ContentSettingsType type,\n     const std::string& resource_identifier) {\n   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n       << \"Geolocation settings handled by OnGeolocationPermissionSet\";\n   content_accessed_[type] = true;\n  std::string identifier;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableResourceContentSettings)) {\n    identifier = resource_identifier;\n  }\n  if (!identifier.empty())\n    AddBlockedResource(type, identifier);\n#if defined (OS_ANDROID)\n  if (type == CONTENT_SETTINGS_TYPE_POPUPS) {\n    content_blocked_[type] = false;\n    content_blockage_indicated_to_user_[type] = false;\n  }\n#endif\n  if (!content_blocked_[type]) {\n    content_blocked_[type] = true;\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n        content::Source<WebContents>(web_contents()),\n        content::NotificationService::NoDetails());\n  }\n}", "target": 1}
{"code": " MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 1}
{"code": "BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(\n    TabContents* tab_contents,\n    const string16& utf16_name)\n    : PluginInfoBarDelegate(tab_contents, utf16_name) {\n  UserMetrics::RecordAction(UserMetricsAction(\"BlockedPluginInfobar.Shown\"));\n  std::string name = UTF16ToUTF8(utf16_name);\n  if (name == webkit::npapi::PluginGroup::kJavaGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.Java\"));\n  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.QuickTime\"));\n  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.Shockwave\"));\n   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)\n     UserMetrics::RecordAction(\n         UserMetricsAction(\"BlockedPluginInfobar.Shown.RealPlayer\"));\n }", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n \tif (!(size > 0))\n \t\treturn 0;\n \tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n \tif (ret != size) {\n \t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "mix_pool(unsigned char *pool)\n{\n  static unsigned char failsafe_digest[DIGESTLEN];\n  static int failsafe_digest_valid;\n  unsigned char *hashbuf = pool + POOLSIZE;\n  unsigned char *p, *pend;\n  int i, n;\n  SHA1_CONTEXT md;\n  unsigned int nburn;\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for SHA-1\n#endif\n  gcry_assert (pool_is_locked);\n  _gcry_sha1_mixblock_init (&md);\n  pend = pool + POOLSIZE;\n  memcpy (hashbuf, pend - DIGESTLEN, DIGESTLEN );\n  memcpy (hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n  nburn = _gcry_sha1_mixblock (&md, hashbuf);\n  memcpy (pool, hashbuf, DIGESTLEN);\n  if (failsafe_digest_valid && pool == rndpool)\n    {\n      for (i=0; i < DIGESTLEN; i++)\n        pool[i] ^= failsafe_digest[i];\n    }\n  p = pool;\n  for (n=1; n < POOLBLOCKS; n++)\n    {\n      memcpy (hashbuf, p, DIGESTLEN);\n      p += DIGESTLEN;\n      if (p+DIGESTLEN+BLOCKLEN < pend)\n        memcpy (hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n      else\n        {\n          unsigned char *pp = p + DIGESTLEN;\n          for (i=DIGESTLEN; i < BLOCKLEN; i++ )\n            {\n              if ( pp >= pend )\n                pp = pool;\n              hashbuf[i] = *pp++;\n\t    }\n\t}\n      _gcry_sha1_mixblock (&md, hashbuf);\n      memcpy(p, hashbuf, DIGESTLEN);\n    }\n  if ( pool == rndpool)\n    {\n      _gcry_sha1_hash_buffer (failsafe_digest, pool, POOLSIZE);\n      failsafe_digest_valid = 1;\n    }\n  _gcry_burn_stack (nburn);\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n out_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 1}
{"code": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\tBUG_ON(((int)(start - end)) > 0);\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n\t\t\tcur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}", "target": 1}
{"code": "void ContainerNode::parserInsertBefore(PassRefPtrWillBeRawPtr<Node> newChild, Node& nextChild)\n{\n    ASSERT(newChild);\n    ASSERT(nextChild.parentNode() == this);\n    ASSERT(!newChild->isDocumentFragment());\n    ASSERT(!isHTMLTemplateElement(this));\n    if (nextChild.previousSibling() == newChild || &nextChild == newChild) \n        return;\n    if (!checkParserAcceptChild(*newChild))\n        return;\n    RefPtrWillBeRawPtr<Node> protect(this);\n     while (RefPtrWillBeRawPtr<ContainerNode> parent = newChild->parentNode())\n         parent->parserRemoveChild(*newChild);\n     if (document() != newChild->document())\n         document().adoptNode(newChild.get(), ASSERT_NO_EXCEPTION);\n    {\n        EventDispatchForbiddenScope assertNoEventDispatch;\n        ScriptForbiddenScope forbidScript;\n        treeScope().adoptIfNeeded(*newChild);\n        insertBeforeCommon(nextChild, *newChild);\n        newChild->updateAncestorConnectedSubframeCountForInsertion();\n        ChildListMutationScope(*this).childAdded(*newChild);\n    }\n    notifyNodeInserted(*newChild, ChildrenChangeSourceParser);\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n     AppProto alproto = ALPROTO_UNKNOWN;\n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n            goto end;\n         }\n     }\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n     }\n  end:\n     SCReturnUInt(alproto);\n }", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": " struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n \tstruct pt_regs regs;\n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n \t\tinit_idle(task, cpu);\n \treturn task;\n }", "target": 1}
{"code": "mix_pool(byte *pool)\n{\n    char *hashbuf = pool + POOLSIZE;\n    char *p, *pend;\n    int i, n;\n    RMD160_CONTEXT md;\n    rmd160_init( &md );\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for ripe-md-160\n#endif\n    pend = pool + POOLSIZE;\n    memcpy(hashbuf, pend - DIGESTLEN, DIGESTLEN );\n    memcpy(hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n    rmd160_mixblock( &md, hashbuf);\n    memcpy(pool, hashbuf, DIGESTLEN);\n    p = pool;\n    for( n=1; n < POOLBLOCKS; n++ ) {\n\tmemcpy(hashbuf, p, DIGESTLEN );\n\tp += DIGESTLEN;\n\tif( p+DIGESTLEN+BLOCKLEN < pend )\n\t    memcpy(hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n\telse {\n\t    char *pp = p+DIGESTLEN;\n\t    for(i=DIGESTLEN; i < BLOCKLEN; i++ ) {\n\t\tif( pp >= pend )\n\t\t    pp = pool;\n\t\thashbuf[i] = *pp++;\n\t    }\n\t}\n\trmd160_mixblock( &md, hashbuf);\n\tmemcpy(p, hashbuf, DIGESTLEN);\n    }\n    burn_stack (384); \n}", "target": 1}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 1}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n \t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n \tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n \t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    size_t usable;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   \n    if (greedy == 1) {\n        if (newlen < SDS_MAX_PREALLOC)\n            newlen *= 2;\n        else\n            newlen += SDS_MAX_PREALLOC;\n    }\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  \n    if (oldtype==type) {\n        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc_usable(hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    usable = usable-hdrlen-1;\n    if (usable > sdsTypeMaxSize(type))\n        usable = sdsTypeMaxSize(type);\n    sdssetalloc(s, usable);\n    return s;\n}", "target": 1}
{"code": "check_tty(const char *tty)\n{\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}", "target": 1}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "int MockNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials,\n    const CompletionCallback& callback) {\n  if (!IsReadyToRestartForAuth())\n     return ERR_FAILED;\n   HttpRequestInfo auth_request_info = *request_;\n  auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");\n  return StartInternal(&auth_request_info, callback, BoundNetLog());\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tresult = current_dir + filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\\n\";\n\treturn result;\n}", "target": 1}
{"code": "static efi_status_t __init phys_efi_set_virtual_address_map(\n\tunsigned long memory_map_size,\n\tunsigned long descriptor_size,\n\tu32 descriptor_version,\n\tefi_memory_desc_t *virtual_map)\n{\n\tefi_status_t status;\n\tunsigned long flags;\n\tpgd_t *save_pgd;\n\tsave_pgd = efi_call_phys_prolog();\n\tlocal_irq_save(flags);\n\tstatus = efi_call_phys(efi_phys.set_virtual_address_map,\n\t\t\t       memory_map_size, descriptor_size,\n\t\t\t       descriptor_version, virtual_map);\n\tlocal_irq_restore(flags);\n\tefi_call_phys_epilog(save_pgd);\n\treturn status;\n}", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 1}
{"code": " static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n\tunsigned int random_variable = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 1}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n \tconst u_char *ep = ndo->ndo_snapend;\n \tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n \t\treturn (-1);\n\t}\n \tn = EXTRACT_32BITS(&prep->pp_n);\n \tps = (const struct pgstate *)(prep + 1);\n \twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n \tBUG_ON(!thresholds);\n \tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n \tsynchronize_rcu();\n \tmutex_unlock(&memcg->thresholds_lock);\n }", "target": 1}
{"code": "rsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n  rsa_compute_root (key, xb, mb);\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n  return res;\n}", "target": 1}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n \tif (IS_ERR(sb))\n \t\treturn ERR_CAST(sb);\n \tif (!proc_parse_options(options, ns)) {\n \t\tdeactivate_locked_super(sb);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\treturn dget(sb->s_root);\n}", "target": 1}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n \t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n \t\t\t     10000\n \t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n \t\tstatus = get_unaligned_le16(status_buf);\n \t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n    if (!data->expect)\n        erc = -1;\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n    if (!src)\n        return 0;\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}", "target": 1}
{"code": " bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n   SetState(STATE_NORMAL);\n   ui::MouseEvent synthetic_event(\n      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),\n      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);\n  NotifyClick(synthetic_event);\n  return true;\n}", "target": 1}
{"code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "xsltStylesheetPtr XSLStyleSheet::compileStyleSheet()\n{\n     if (m_embedded)\n         return xsltLoadStylesheetPI(document());\n     ASSERT(!m_stylesheetDocTaken);\n     xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc);\n     if (result)\n         m_stylesheetDocTaken = true;\n     return result;\n }", "target": 1}
{"code": "static int vol_prc_lib_release(effect_handle_t handle)\n{\n     struct listnode *node, *temp_node_next;\n     vol_listener_context_t *context = NULL;\n     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;\n    int status = -1;\n     bool recompute_flag = false;\n     int active_stream_count = 0;\n     ALOGV(\"%s context %p\", __func__, handle);\n     pthread_mutex_lock(&vol_listner_init_lock);\n     list_for_each_safe(node, temp_node_next, &vol_effect_list) {\n         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);\n        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)\n            && (context->session_id == recv_contex->session_id)\n            && (context->stream_type == recv_contex->stream_type)) {\n             ALOGV(\"--- Found something to remove ---\");\n            list_remove(&context->effect_list_node);\n             PRINT_STREAM_TYPE(context->stream_type);\n             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {\n                 recompute_flag = true;\n }\n            free(context);\n            status = 0;\n } else {\n ++active_stream_count;\n }\n }\n     if (status != 0) {\n         ALOGE(\"something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>\");\n     }\n if (active_stream_count == 0) {\n        current_gain_dep_cal_level = -1;\n        current_vol = 0.0;\n }\n if (recompute_flag) {\n        check_and_set_gain_dep_cal();\n }\n if (dumping_enabled) {\n        dump_list_l();\n }\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}", "target": 1}
{"code": " int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n \tpx->ft->data = px;\n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\treturn FALSE;\n}", "target": 1}
{"code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "  bool DoTouchScroll(const gfx::Point& point,\n                     const gfx::Vector2d& distance,\n                     bool wait_until_scrolled) {\n    EXPECT_EQ(0, GetScrollTop());\n    int scrollHeight = ExecuteScriptAndExtractInt(\n        \"document.documentElement.scrollHeight\");\n    EXPECT_EQ(1200, scrollHeight);\n    scoped_refptr<FrameWatcher> frame_watcher(new FrameWatcher());\n    frame_watcher->AttachTo(shell()->web_contents());\n    SyntheticSmoothScrollGestureParams params;\n    params.gesture_source_type = SyntheticGestureParams::TOUCH_INPUT;\n    params.anchor = gfx::PointF(point);\n    params.distances.push_back(-distance);\n    runner_ = new MessageLoopRunner();\n    std::unique_ptr<SyntheticSmoothScrollGesture> gesture(\n        new SyntheticSmoothScrollGesture(params));\n    GetWidgetHost()->QueueSyntheticGesture(\n        std::move(gesture),\n        base::Bind(&TouchActionBrowserTest::OnSyntheticGestureCompleted,\n                   base::Unretained(this)));\n    runner_->Run();\n    runner_ = NULL;\n     while (wait_until_scrolled &&\n           frame_watcher->LastMetadata().root_scroll_offset.y() <= 0) {\n       frame_watcher->WaitFrames(1);\n     }\n    int scrollTop = GetScrollTop();\n    if (scrollTop == 0)\n      return false;\n    EXPECT_EQ(distance.y(), scrollTop);\n    return true;\n  }", "target": 1}
{"code": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n \trcu_read_lock();\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n \trcu_read_unlock();\n }", "target": 1}
{"code": "bool ContainerNode::replaceChild(PassRefPtr<Node> newChild, Node* oldChild, ExceptionCode& ec, bool shouldLazyAttach)\n{\n    ASSERT(refCount() || parentOrHostNode());\n    RefPtr<Node> protect(this);\n    ec = 0;\n    if (oldChild == newChild) \n        return true;\n    checkReplaceChild(newChild.get(), oldChild, ec);\n    if (ec)\n        return false;\n    if (!oldChild || oldChild->parentNode() != this) {\n        ec = NOT_FOUND_ERR;\n        return false;\n    }\n#if ENABLE(MUTATION_OBSERVERS)\n    ChildListMutationScope mutation(this);\n#endif\n    RefPtr<Node> next = oldChild->nextSibling();\n    RefPtr<Node> removedChild = oldChild;\n    removeChild(oldChild, ec);\n    if (ec)\n        return false;\n    if (next && (next->previousSibling() == newChild || next == newChild)) \n        return true;\n    checkReplaceChild(newChild.get(), oldChild, ec);\n    if (ec)\n        return false;\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(newChild.get(), targets, ec);\n     if (ec)\n         return false;\n     InspectorInstrumentation::willInsertDOMNode(document(), this);\n    for (NodeVector::const_iterator it = targets.begin(); it != targets.end(); ++it) {\n        Node* child = it->get();\n        if (next && next->parentNode() != this)\n            break;\n        if (child->parentNode())\n            break;\n        treeScope()->adoptIfNeeded(child);\n        forbidEventDispatch();\n        if (next)\n            insertBeforeCommon(next.get(), child);\n        else\n            appendChildToContainer(child, this);\n        allowEventDispatch();\n        updateTreeAfterInsertion(this, child, shouldLazyAttach);\n    }\n    dispatchSubtreeModifiedEvent();\n    return true;\n}", "target": 1}
{"code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n\t\treturn NULL;\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\tif (!MsPipes)\n\t\treturn NULL;\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\treturn MsPipes;\nout_error:\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\tfree(MsPipes);\n\treturn NULL;\n}", "target": 1}
{"code": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }", "target": 1}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n \thid->version = req->version;\n \thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n \tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n \t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)\n{\n\tstruct tevent_req *req =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct tevent_req);\n\tstruct cli_session_setup_gensec_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct cli_session_setup_gensec_state);\n\tNTSTATUS status;\n\tTALLOC_FREE(state->inbuf);\n\tTALLOC_FREE(state->recv_iov);\n\tstatus = cli_sesssetup_blob_recv(subreq, state, &state->blob_in,\n\t\t\t\t\t &state->inbuf, &state->recv_iov);\n\tTALLOC_FREE(subreq);\n\tdata_blob_free(&state->blob_out);\n\tif (!NT_STATUS_IS_OK(status) &&\n\t    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t{\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tstruct smbXcli_session *session = NULL;\n\t\tbool is_guest = false;\n\t\tif (smbXcli_conn_protocol(state->cli->conn) >= PROTOCOL_SMB2_02) {\n\t\t\tsession = state->cli->smb2.session;\n\t\t} else {\n\t\t\tsession = state->cli->smb1.session;\n\t\t}\n\t\tis_guest = smbXcli_session_is_guest(session);\n\t\tif (is_guest) {\n\t\t\tstate->blob_in = data_blob_null;\n\t\t\tstate->local_ready = true;\n\t\t}\n\t\tstate->remote_ready = true;\n\t}\n\tif (state->local_ready && state->remote_ready) {\n\t\tcli_session_setup_gensec_ready(req);\n\t\treturn;\n\t}\n\tcli_session_setup_gensec_local_next(req);\n}", "target": 1}
{"code": "wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                       const void* msg, size_t msg_len,\n                                       const wsrep_gtid_t* current_gtid,\n                                       const char* state, size_t state_len,\n                                       bool bypass)\n{\n  local_status.set(WSREP_MEMBER_DONOR);\n  const char* method = (char*)msg;\n  size_t method_len  = strlen (method);\n  const char* data   = method + method_len + 1;\n  char uuid_str[37];\n  wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n  wsp::env env(NULL);\n  if (env.error())\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n  int ret;\n  if ((ret= sst_append_auth_env(env, sst_auth_real)))\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): appending auth env failed: %d\", ret);\n    return WSREP_CB_FAILURE;\n  }\n  if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n  {\n    ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                               current_gtid->seqno, bypass, env());\n  }\n  else\n  {\n    ret = sst_donate_other(method, data, uuid_str,\n                           current_gtid->seqno, bypass, env());\n  }\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n   if (strstr(timestring, \",\") == NULL &&\n       strstr(timestring, \"/\") == NULL) { \n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n  return MS_TRUE;\n}", "target": 1}
{"code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }", "target": 1}
{"code": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}", "target": 1}
{"code": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = (uint8_t*)p_data;\n   uint8_t reason = SMP_INVALID_PARAMETERS;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->status = *(uint8_t*)p_data;\n   if (smp_command_has_invalid_parameters(p_cb)) {\n     smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\n     return;\n   }\n   if (p != NULL) {\n     STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);\n   } else {\n    p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;\n }\n  p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;\n}", "target": 1}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 1}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n \t\t\t       start, end + 1, GFP_KERNEL);\n \tif (family->id < 0) {\n \t\terr = family->id;\n\t\tgoto errout_locked;\n \t}\n \terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\n errout_remove:\n \tidr_remove(&genl_fam_idr, family->id);\n \tkfree(family->attrbuf);\n errout_locked:\n \tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n \tif (sk_hashed(sk)) {\n \t\twrite_lock_bh(&ping_table.lock);\n \t\thlist_nulls_del(&sk->sk_nulls_node);\n \t\tsock_put(sk);\n \t\tisk->inet_num = 0;\n \t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 1}
{"code": " static void cliRefreshPrompt(void) {\n    int len;\n     if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n     if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n }", "target": 1}
{"code": "*/\nstatic void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;", "target": 1}
{"code": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n      if (len != data_size)\n\t{\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n      p = data + 2;\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\t  p += len;\n\t}\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  switch (type)\n\t    {\n\t    case 0:\t\t\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "static int hso_get_config_data(struct usb_interface *interface)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tu8 *config_data = kmalloc(17, GFP_KERNEL);\n\tu32 if_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\ts32 result;\n\tif (!config_data)\n\t\treturn -ENOMEM;\n\tif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t    0x86, 0xC0, 0, 0, config_data, 17,\n\t\t\t    USB_CTRL_SET_TIMEOUT) != 0x11) {\n\t\tkfree(config_data);\n\t\treturn -EIO;\n\t}\n\tswitch (config_data[if_num]) {\n\tcase 0x0:\n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x1:\n\t\tresult = HSO_PORT_DIAG;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x3:\n\t\tresult = HSO_PORT_GPS_CONTROL;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x5:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tcase 0x6:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x7:\n\t\tresult = HSO_PORT_NETWORK;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_MODEM;\n\t\tbreak;\n\tcase 0x9:\n\t\tresult = HSO_PORT_MSD;\n\t\tbreak;\n\tcase 0xa:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0xb:\n\t\tresult = HSO_PORT_VOICE;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t}\n\tif (result)\n\t\tresult |= HSO_INTF_BULK;\n\tif (config_data[16] & 0x1)\n\t\tresult |= HSO_INFO_CRC_BUG;\n\tkfree(config_data);\n\treturn result;\n}", "target": 1}
{"code": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if ((ctx->num + inl) < ctx->length) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}", "target": 1}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n    int chunk_size;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}", "target": 1}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    TF_RETURN_IF_ERROR(ValidateNode(node));\n  }\n  if (graph_def.has_library()) {\n    const FunctionDefLibrary& library = graph_def.library();\n    for (const auto& function : library.function()) {\n      for (const auto& node : function.node_def()) {\n        TF_RETURN_IF_ERROR(ValidateNode(node));\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n \tif (flags & (MSG_OOB))\n \t\treturn -EOPNOTSUPP;\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n \t\treturn err;\n \t}\n\tmsg->msg_namelen = 0;\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n \tstruct nft_chain *chain, *nc;\n \tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n \t\tctx->chain = chain;\n \t\terr = nft_delrule_by_chain(ctx);\n \t\tif (err < 0)\n \t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n \t}\n \tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n \t\t\tgoto out;\n \t}\n \terr = nft_deltable(ctx);\n out:\n \treturn err;\n}", "target": 1}
{"code": "static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\tforward = NULL;\n\tfound = 0;\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Extension unit %d \"\n\t\t\t\t\t  \"has more than 1 input pin.\\n\",\n\t\t\t\t\t  entity->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\t\t\t\tprintk(KERN_CONT \" XU %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Unsupported input \"\n\t\t\t\t\t\"terminal %u.\\n\", forward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\t\t\t\tprintk(KERN_CONT \" OT %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tprintk(KERN_CONT \")\");\n\treturn 0;\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n uint32_t cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n     if (mStatus != NO_ERROR) {\n         return mStatus;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}", "target": 1}
{"code": "int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)\n{\n    int result = -1;\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n     case V_ASN1_OBJECT:\n         result = OBJ_cmp(a->value.object, b->value.object);\n         break;\n     case V_ASN1_NULL:\n         result = 0;             \n         break;\n    case V_ASN1_NEG_ENUMERATED:\n    case V_ASN1_BIT_STRING:\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_SEQUENCE:\n    case V_ASN1_SET:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_OTHER:\n    default:\n        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,\n                                 (ASN1_STRING *)b->value.ptr);\n        break;\n    }\n    return result;\n}", "target": 1}
{"code": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\tdown_read(&current->mm->mmap_sem);\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\t\tif (len)\n\t\t\tbreak;\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\tup_read(&current->mm->mmap_sem);\n\tif (buffers)\n\t\treturn buffers;\n\treturn error;\n}", "target": 1}
{"code": "static float *get_window(vorb *f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n    return NULL;\n }", "target": 1}
{"code": "XListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  \nint maxNames,\nint *actualCount)\t\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n     if (rep.nFonts) {\n \tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length < (INT_MAX >> 2)) {\n \t    rlen = rep.length << 2;\n \t    ch = Xmalloc(rlen + 1);\n\t}\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\t_XReadPad (dpy, ch, rlen);\n\tchend = ch + (rlen + 1);\n\tlength = *(unsigned char *)ch;\n\t*ch = 1; \n\tfor (i = 0; i < rep.nFonts; i++) {\n \t    if (ch + length < chend) {\n \t\tflist[i] = ch + 1;  \n \t\tch += length + 1;  \n\t\tlength = *(unsigned char *)ch;\n\t\t*ch = '\\0';  \n\t\tcount++;\n\t    } else\n\t\tflist[i] = NULL;\n \t}\n     }\n     *actualCount = count;\n\t\t\tfor (names = list+1; *names; names++)\n\t\t\t\tXfree (*names);\n\t\t}", "target": 1}
{"code": "static int is_userinfo_valid(const char *str, size_t len)\n{\n\tchar *valid = \"-._~!$&'()*+,;=:\";\n\tchar *p = str;\n\twhile (p - str < len) {\n\t\tif (isalpha(*p) || isdigit(*p) || strchr(valid, *p)) {\n\t\t\tp++;\n\t\t} else if (*p == '%' && p - str <= len - 3 && isdigit(*(p+1)) && isxdigit(*(p+2))) {\n\t\t\tp += 3;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n \t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n \t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n \t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n {\n \tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n \t\treturn num - (1<<number);\n \telse\n \t\treturn num;\n}", "target": 1}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n \tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n \t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": " void ahci_uninit(AHCIState *s)\n {\n     g_free(s->dev);\n }", "target": 1}
{"code": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder && decoder->globals );\n     FT_ZERO( buf );\n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     \n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }", "target": 1}
{"code": "long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  for (si = s; si < se; ) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \tvalue_len = php_url_decode(buf2, value_len);\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn d_url;\n }", "target": 1}
{"code": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n\t    }\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\t    _XReadPad (dpy, ch, rlen);\n\t    chend = ch + (rlen + 1);\n\t    length = *ch;\n\t    for (i = 0; i < rep.nExtensions; i++) {\n\t\tif (ch + length < chend) {\n\t\t    list[i] = ch+1;  \n\t\t    ch += length + 1; \n\t\t    if (ch <= chend) {\n\t\t\tlength = *ch;\n\t\t\t*ch = '\\0'; \n\t\t\tcount++;\n\t\t    } else {\n\t\t\tlist[i] = NULL;\n\t\t    }\n\t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": " void CLASS foveon_load_camf()\n {\n   unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n   fseek (ifp, meta_offset, SEEK_SET);\n   type = get4();  get4();  get4();\n   wide = get4();\n   high = get4();\n   if (type == 2) {\n     fread (meta_data, 1, meta_length, ifp);\n     for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}", "target": 1}
{"code": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n     if (err != NO_ERROR) return 0;\n     native_handle* h = native_handle_create(numFds, numInts);\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n         if (h->data[i] < 0) err = BAD_VALUE;\n }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}", "target": 1}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 1}
{"code": "jio_vsnprintf(char * str, int n, const char * format, va_list args)\n{\n\tint result;\n\tTrc_SC_vsnprintf_Entry(str, n, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else \n\tresult = vsprintf( str, format, args );\n#endif\n\tTrc_SC_vsnprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst struct user_regset *regset = &view->regsets[i];\n \t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n \t\t    (!regset->active || regset->active(t->task, regset))) {\n \t\t\tint ret;\n \t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n     int again;\n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n             break;\n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n             break;\n         case EST_ADVANCEQUEUE:\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n             break;\n         }", "target": 1}
{"code": "static int zr364xx_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct zr364xx_camera *cam = video_drvdata(file);\n\tstrscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\n\tstrscpy(cap->card, cam->udev->product, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cam->udev->dev),\n\t\tsizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 1}
{"code": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n  params << net->serverEncode(bufname) << quotedReply;\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1}
{"code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    int refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n    return refcount;\n}", "target": 1}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n \t}\n \tn = xmalloc(len);\n \tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n \tfor (p = path; p; p = p->up) {\n \t\tif (p->elem_len) {\n \t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n {\n \tint i;\n \tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n \tstruct pagevec pvec_putback;\n \tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n \t\t\t\tcontinue;\n \t\t\telse\n \t\t\t\t__munlock_isolation_failed(page);\n \t\t}\n \t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n \t\tpvec->pages[i] = NULL;\n \t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n \t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n \tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {\n  if (U_FAILURE(*status))\n    return;\n  const icu::UnicodeSet* recommended_set =\n      uspoof_getRecommendedUnicodeSet(status);\n  icu::UnicodeSet allowed_set;\n  allowed_set.addAll(*recommended_set);\n  const icu::UnicodeSet* inclusion_set = uspoof_getInclusionUnicodeSet(status);\n  allowed_set.addAll(*inclusion_set);\n  allowed_set.remove(0x338u);\n  allowed_set.remove(0x58au);  \n  allowed_set.remove(0x2010u);\n  allowed_set.remove(0x2019u);  \n  allowed_set.remove(0x2027u);\n  allowed_set.remove(0x30a0u);  \n   allowed_set.remove(0x2bbu);  \n   allowed_set.remove(0x2bcu);  \n#if defined(OS_MACOSX)\n  allowed_set.remove(0x0620u);\n  allowed_set.remove(0x0F8Cu);\n  allowed_set.remove(0x0F8Du);\n  allowed_set.remove(0x0F8Eu);\n  allowed_set.remove(0x0F8Fu);\n#endif\n  allowed_set.remove(0x01CDu, 0x01DCu);  \n  allowed_set.remove(0x1C80u, 0x1C8Fu);  \n  allowed_set.remove(0x1E00u, 0x1E9Bu);  \n  allowed_set.remove(0x1F00u, 0x1FFFu);  \n  allowed_set.remove(0xA640u, 0xA69Fu);  \n  allowed_set.remove(0xA720u, 0xA7FFu);  \n  uspoof_setAllowedUnicodeSet(checker_, &allowed_set, status);\n}", "target": 1}
{"code": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n         return;\n     }\n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n }", "target": 1}
{"code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n    if (!mount_point.isEmpty())\n        return mount_point;\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n        return QString();\n    }\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n        return QString();\n    }\n    return mount_point;\n}", "target": 1}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n \twhile(l && argv0[l - 1] != '/')\n \t\tl--;\n \tif(l == 0)\n \t\tmemcpy(own_dir, \".\", 2);\n \telse {\n \t\tmemcpy(own_dir, argv0, l - 1);\n \t\town_dir[l] = 0;\n\t}\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }", "target": 1}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n \t\t\t__WNOTHREAD|__WCLONE|__WALL))\n \t\treturn -EINVAL;\n \tif (upid == -1)\n \t\ttype = PIDTYPE_MAX;\n \telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 1}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0 || bgcolor >= gdMaxColors) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": " std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n  if (!func_name.empty()) {\n#if defined(__APPLE__)\n    if (func_name[0] != '_') {\n      return func_name;\n    }\n#endif\n    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n    if (name) {\n      func_name = name;\n      free(name);\n    }\n  }\n   return func_name;\n }", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> guard(globalMutex);\n  string pipePath = endpoint.name();\n  if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {\n    throw runtime_error(\"Tried to listen twice on the same path\");\n  }\n  sockaddr_un local;\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(fd);\n  initServerSocket(fd);\n  local.sun_family = AF_UNIX; \n  strcpy(local.sun_path, pipePath.c_str());\n  unlink(local.sun_path);\n  FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));\n  ::listen(fd, 5);\n#ifndef WIN32\n  FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));\n#endif\n  pipeServerSockets[pipePath] = set<int>({fd});\n  return pipeServerSockets[pipePath];\n}", "target": 1}
{"code": "xps_load_sfnt_name(xps_font_t *font, char *namep)\n{\n    byte *namedata;\n    int offset, length;\n    int count, stringoffset;\n    int found;\n    int i, k;\n    found = 0;\n    strcpy(namep, \"Unknown\");\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n         return;\n     }\n     namedata = font->data + offset;\n     count = u16(namedata + 2);\n     stringoffset = u16(namedata + 4);\n     if (length < 6 + (count * 12))\n     {\n         gs_warn(\"name table too short\");\n        {\n            if (pid == 1 && eid == 0 && langid == 0) \n            {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n            if (pid == 3 && eid == 1 && langid == 0x409) \n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n            if (pid == 3 && eid == 10 && langid == 0x409) \n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": " ptaReadStream(FILE  *fp)\n {\nchar       typestr[128];\n l_int32    i, n, ix, iy, type, version;\n l_float32  x, y;\n PTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (version != PTA_VERSION_NUMBER)\n         return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (!strcmp(typestr, \"float\"))\n         type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                BatchToSpaceNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int* crops = GetTensorData<int32>(op_context->crops);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->crops), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[1], 2);\n  for (int i = 0; i < spatial_dims_num * 2; ++i) {\n    TF_LITE_ENSURE(context, crops[i] >= 0);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);\n    output_batch_size = output_batch_size / block_shape[dim];\n    output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -\n                                 crops[dim * 2] - crops[dim * 2 + 1];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 1}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n \t\t\treturn;\t\t\n \t\tidx = getFillIdx(shape, fill);\n \t}\n \trecord = addStyleRecord(shape);\n \trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 1}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 1}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n \t\tif (is_error_noslot_pfn(pfn)) {\n \t\t\tgfn += 1;\n \t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 1}
{"code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\tif (!hdev)\n\t\treturn -EBADFD;\n\tlock_sock(sk);\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \trelease_sock(sk);\n \treturn 0;\n}", "target": 1}
{"code": "static inline void constructBidiRunsForSegment(InlineBidiResolver& topResolver, BidiRunList<BidiRun>& bidiRuns, const InlineIterator& endOfRuns, VisualDirectionOverride override, bool previousLineBrokeCleanly)\n{\n    ASSERT(&topResolver.runs() == &bidiRuns);\n    ASSERT(topResolver.position() != endOfRuns);\n    RenderObject* currentRoot = topResolver.position().root();\n    topResolver.createBidiRunsForLine(endOfRuns, override, previousLineBrokeCleanly);\n    while (!topResolver.isolatedRuns().isEmpty()) {\n        BidiRun* isolatedRun = topResolver.isolatedRuns().last();\n        topResolver.isolatedRuns().removeLast();\n        RenderObject* startObj = isolatedRun->object();\n        RenderInline* isolatedInline = toRenderInline(containingIsolate(startObj, currentRoot));\n         InlineBidiResolver isolatedResolver;\n         EUnicodeBidi unicodeBidi = isolatedInline->style()->unicodeBidi();\n        TextDirection direction = isolatedInline->style()->direction();\n        if (unicodeBidi == Plaintext)\n            direction = determinePlaintextDirectionality(isolatedInline, startObj);\n        else {\n            ASSERT(unicodeBidi == Isolate || unicodeBidi == IsolateOverride);\n            direction = isolatedInline->style()->direction();\n        }\n        isolatedResolver.setStatus(statusWithDirection(direction, isOverride(unicodeBidi)));\n        setupResolverToResumeInIsolate(isolatedResolver, isolatedInline, startObj);\n        InlineIterator iter = InlineIterator(isolatedInline, startObj, isolatedRun->m_start);\n        isolatedResolver.setPositionIgnoringNestedIsolates(iter);\n        isolatedResolver.createBidiRunsForLine(endOfRuns, NoVisualOverride, previousLineBrokeCleanly);\n        if (isolatedResolver.runs().runCount())\n            bidiRuns.replaceRunWithRuns(isolatedRun, isolatedResolver.runs());\n        if (!isolatedResolver.isolatedRuns().isEmpty()) {\n            topResolver.isolatedRuns().append(isolatedResolver.isolatedRuns());\n            isolatedResolver.isolatedRuns().clear();\n            currentRoot = isolatedInline;\n        }\n    }\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size)\n{\n    if (new_size > shaper->n_glyphs) {\n        if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||\n            !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))\n             return false;\n     }\n     return true;\n }", "target": 1}
{"code": "exsltSaxonLineNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlNodePtr cur = NULL;\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid arg expecting a node-set\\n\");\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewFloat(-1));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    int ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t\tcur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid number of args %d\\n\",\n\t\tnargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    valuePush(ctxt, xmlXPathNewFloat(xmlGetLineNo(cur)));\n    return;\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\n skip_error:\n \twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 1}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n    if (blit_is_unsafe(s, false))\n        return 0;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}", "target": 1}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n       }\n       s++;\n       ptmp = tmp;\n      while (*s && *s != '\\\"')\n         *ptmp++ = *s++;\n       if (*s != '\\\"')\n         return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n       s += 11;\n       SKIPWS(s);\n       ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n         *ptmp++ = *s++;\n       *ptmp = '\\0';\n       if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)\n{\n    struct zzip_file_header *header =\n        zzip_disk_entry_to_file_header(disk, entry);\n    if (! header)\n        return 0; \n    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file)\n        return 0; \n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->avail = zzip_file_header_usize(header);\n    if (! file->avail || zzip_file_header_data_stored(header))\n    { \n         file->stored = zzip_file_header_to_data (header);\n         DBG2(\"stored size %i\", (int) file->avail);\n         if (file->stored + file->avail >= disk->endbuf)\n             goto error;\n         return file; \n    }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize(header);\n    file->zlib.next_in = zzip_file_header_to_data(header);\n    DBG2(\"compressed size %i\", (int) file->zlib.avail_in);\n    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)\n         goto error;\n    if (! zzip_file_header_data_deflated(header))\n        goto error;\n    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)\n        goto error;\n    return file;\nerror:\n    free (file);\n    errno = EBADMSG;\n    return 0; \n    ____;\n}", "target": 1}
{"code": " void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n {\n \tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n \tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n \t}\n \tstats->read_char\t= p->rchar;\n \tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 1}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n \tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n \t\treturn ret_error;\n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n \t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n \t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n \t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n \t\t\t\t skb->len, skb->data);\n \t}\n}", "target": 1}
{"code": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\tcstate = 0;\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n \t\t\tjas_free(siz->comps);\n \t\t\treturn -1;\n \t\t}\n \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n \t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n {\n \tstruct mm_struct *mm = vma->vm_mm;\n \tstruct vm_area_struct *prev;\n\tint error;\n \taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n \tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n \tfor (i = 0; i < bin->nsects; i++) {\n \t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n \t\t\t\t\tsym = j;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n \t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n \t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \treturn ret;\n }", "target": 1}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n \t\t\t\t&digi, NULL, NULL);\n \t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MaxTextExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 1}
{"code": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\n exit:\n \tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n }", "target": 1}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n \t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n \t\t    rxent->client.s_addr == clip &&\n \t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n \t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n \t*prev = NULL;\t\n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }", "target": 1}
{"code": "void DelayedExecutor::delayedExecute(const QString &udi)\n{\n    Solid::Device device(udi);\n     QString exec = m_service.exec();\n     MacroExpander mx(device);\n    mx.expandMacros(exec);\n     KRun::runCommand(exec, QString(), m_service.icon(), 0);\n     deleteLater();\n}", "target": 1}
{"code": " int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n {\n \tstruct usb_descriptor_header *header;\n \twhile (size >= sizeof(struct usb_descriptor_header)) {\n \t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n \t\t\tprintk(KERN_ERR\n \t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n \t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n \t\t\treturn -1;\n \t\t}\n\t\tif (header->bDescriptorType == type) {\n \t\t\t*ptr = header;\n \t\t\treturn 0;\n \t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "int go7007_snd_init(struct go7007 *go)\n{\n\tstatic int dev;\n\tstruct go7007_snd *gosnd;\n\tint ret;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\tgosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);\n\tif (gosnd == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gosnd->lock);\n\tgosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;\n\tgosnd->capturing = 0;\n\tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n\t\t\t   &gosnd->card);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n\t\t\t&go7007_snd_device_ops);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n\tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n\tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n\t\tsizeof(gosnd->card->longname));\n\tgosnd->pcm->private_data = go;\n\tsnd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&go7007_snd_capture_ops);\n\tret = snd_card_register(gosnd->card);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tgosnd->substream = NULL;\n\tgo->snd_context = gosnd;\n\tv4l2_device_get(&go->v4l2_dev);\n\t++dev;\n\treturn 0;\n}", "target": 1}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n        assert(p);\n        assert(key);\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n         if (p->question->n_keys != 1)\n                 return 0;\n        return dns_resource_key_equal(p->question->keys[0], key);\n}", "target": 1}
{"code": "static void become_daemon(const char *pidfile)\n{\n#ifndef _WIN32\n    pid_t pid, sid;\n    pid = fork();\n    if (pid < 0) {\n        exit(EXIT_FAILURE);\n    }\n    if (pid > 0) {\n        exit(EXIT_SUCCESS);\n    }\n    if (pidfile) {\n        if (!ga_open_pidfile(pidfile)) {\n            g_critical(\"failed to create pidfile\");\n            exit(EXIT_FAILURE);\n         }\n     }\n    umask(0);\n     sid = setsid();\n     if (sid < 0) {\n         goto fail;\n    }\n    if ((chdir(\"/\")) < 0) {\n        goto fail;\n    }\n    reopen_fd_to_null(STDIN_FILENO);\n    reopen_fd_to_null(STDOUT_FILENO);\n    reopen_fd_to_null(STDERR_FILENO);\n    return;\nfail:\n    if (pidfile) {\n        unlink(pidfile);\n    }\n    g_critical(\"failed to daemonize\");\n    exit(EXIT_FAILURE);\n#endif\n}", "target": 1}
{"code": "evbuffer_expand(struct evbuffer *buf, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tif (buf->totallen >= need)\n\t\treturn (0);\n\tif (buf->misalign >= datlen) {\n\t\tevbuffer_align(buf);\n\t} else {\n\t\tvoid *newbuf;\n\t\tsize_t length = buf->totallen;\n\t\tif (length < 256)\n\t\t\tlength = 256;\n\t\twhile (length < need)\n\t\t\tlength <<= 1;\n\t\tif (buf->orig_buffer != buf->buffer)\n\t\t\tevbuffer_align(buf);\n\t\tif ((newbuf = realloc(buf->buffer, length)) == NULL)\n\t\t\treturn (-1);\n\t\tbuf->orig_buffer = buf->buffer = newbuf;\n\t\tbuf->totallen = length;\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static INLINE INT32 planar_skip_plane_rle(const BYTE* pSrcData, UINT32 SrcSize, UINT32 nWidth,\n                                          UINT32 nHeight)\n{\n\tUINT32 x, y;\n\tBYTE controlByte;\n\tconst BYTE* pRLE = pSrcData;\n\tconst BYTE* pEnd = &pSrcData[SrcSize];\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tfor (x = 0; x < nWidth;)\n\t\t{\n\t\t\tint cRawBytes;\n\t\t\tint nRunLength;\n\t\t\tif (pRLE >= pEnd)\n\t\t\t\treturn -1;\n\t\t\tcontrolByte = *pRLE++;\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\tpRLE += cRawBytes;\n\t\t\tx += cRawBytes;\n\t\t\tx += nRunLength;\n\t\t\tif (x > nWidth)\n\t\t\t\treturn -1;\n\t\t\tif (pRLE > pEnd)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (INT32)(pRLE - pSrcData);\n}", "target": 1}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n \tstatic u32 challenge_timestamp;\n \tstatic unsigned int challenge_count;\n \tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n \tif (tcp_oow_rate_limited(sock_net(sk), skb,\n \t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n \t\t\t\t &tp->last_oow_ack_time))\n \t\treturn;\n \tnow = jiffies / HZ;\n \tif (now != challenge_timestamp) {\n \t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n \t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n \t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n \t\ttcp_send_ack(sk);\n \t}\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n    n = (ngx_uint_t) t;\n    days = n / 86400;\n    wday = (4 + days) % 7;\n    n %= 86400;\n    hour = n / 3600;\n    n %= 3600;\n    min = n / 60;\n    sec = n % 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\tif(selector!=1) {\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\tif(selector==0) { \n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\tif(selector==0 || selector==1) {\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 1}
{"code": "static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MaxTextExtent];\n  unsigned int\n    foundiptc,\n    tagsfound;\n  unsigned char\n    recnum,\n    dataset;\n  unsigned char\n    *readable,\n    *str;\n  ssize_t\n    tagindx,\n    taglen;\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n  int\n    c;\n  foundiptc = 0; \n  tagsfound = 0; \n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MaxTextExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return 0;\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}", "target": 1}
{"code": " long keyctl_set_reqkey_keyring(int reqkey_defl)\n {\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n \tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n \t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n \t\tgoto set;\n \tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n     segment->nb_index_entries = avio_rb32(pb);\n     length = avio_rb32(pb);\n     if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n         !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n     }\n     for (i = 0; i < segment->nb_index_entries; i++) {\n         segment->temporal_offset_entries[i] = avio_r8(pb);\n         avio_r8(pb);                                        \n         segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 1}
{"code": " bool DebugOnStart::FindArgument(wchar_t* command_line, const char* argument_c) {\n  wchar_t argument[50];\n   for (int i = 0; argument_c[i]; ++i)\n     argument[i] = argument_c[i];\n  int argument_len = lstrlen(argument);\n  int command_line_len = lstrlen(command_line);\n  while (command_line_len > argument_len) {\n    wchar_t first_char = command_line[0];\n    wchar_t last_char = command_line[argument_len+1];\n    if ((first_char == L'-' || first_char == L'/') &&\n        (last_char == L' ' || last_char == 0 || last_char == L'=')) {\n      command_line[argument_len+1] = 0;\n      if (lstrcmpi(command_line+1, argument) == 0) {\n        command_line[argument_len+1] = last_char;\n        return true;\n      }\n      command_line[argument_len+1] = last_char;\n    }\n    ++command_line;\n    --command_line_len;\n  }\n  return false;\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  TfLiteIntArray* ret =\n      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n \tretval = copy_strings_kernel(1, &i_name, bprm);\n \tif (retval) return retval; \n \tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": " static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n {\n       const char *p, *s;\n        char *d;\n       size_t l;\n       p = s = src;\n        d = dst;\n       while (p - src < len) {\n               p += strcspn(p, \",=\\n\\r+<>#;\\\\\\\" \");\n               if (p - src == len) \n                       break;\n               memcpy(d, s, p - s);\n               d += (p - s); \n               switch (*p) {\n                case ' ':\n                       if (p == src || (p-src)==(len-1)) {\n                                *d++ = '\\\\';\n                               *d++ = *p++;                                     \n                        } else {\n                               *d++ = *p++;\n                        }\n                        break;\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = *p++;\t\t\t\t\t \n\t\t\t} else {\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tbreak;\n                case '?':\n                        *d++ = '\\\\';\n                       *d++ = *p++;\n                        break;\n               default: {\n                        unsigned char v;\n                        const char *hexbytes = \"0123456789ABCDEF\";\n                       v = *(const unsigned char *)p;\n                        *d++ = '\\\\';\n                        *d++ = hexbytes[v>>4];\n                        *d++ = hexbytes[v&0xF];\n                       p++;\n                        break;\n                }\n                }\n               s = p; \n        }", "target": 1}
{"code": "int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)\n{\n    size_t i, j;\n     i = c->num;\n     if (i != 0) {\n        if (i + len < MDC2_BLOCK) {\n             memcpy(&(c->data[i]), in, len);\n             c->num += (int)len;\n            return 1;\n        } else {\n            j = MDC2_BLOCK - i;\n            memcpy(&(c->data[i]), in, j);\n            len -= j;\n            in += j;\n            c->num = 0;\n            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);\n        }\n    }\n    i = len & ~((size_t)MDC2_BLOCK - 1);\n    if (i > 0)\n        mdc2_body(c, in, i);\n    j = len - i;\n    if (j > 0) {\n        memcpy(&(c->data[0]), &(in[i]), j);\n        c->num = (int)j;\n    }\n    return 1;\n}", "target": 1}
{"code": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}", "target": 1}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n     if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n         return (NULL);\n     }\n     if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n     } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 1}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n \t\tgoto err3;\n \t}\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 1}
{"code": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "valid_length(uint8_t option, int dl, int *type)\n{\n const struct dhcp_opt *opt;\n ssize_t sz;\n if (dl == 0)\n return -1;\n for (opt = dhcp_opts; opt->option; opt++) {\n if (opt->option != option)\n continue;\n \t\tif (type)\n \t\t\t*type = opt->type;\n \t\tif (opt->type == 0 ||\n \t\t    opt->type & (STRING | RFC3442 | RFC5969))\n \t\t\treturn 0;\n \t\tsz = 0;\n\t\tif (opt->type & (UINT32 | IPV4))\n \t\t\tsz = sizeof(uint32_t);\n\t\tif (opt->type & UINT16)\n \t\t\tsz = sizeof(uint16_t);\n\t\tif (opt->type & UINT8)\n \t\t\tsz = sizeof(uint8_t);\n\t\tif (opt->type & (IPV4 | ARRAY))\n\t\t\treturn dl % sz;\n\t\treturn (dl == sz ? 0 : -1);\n \t}\n return 0;\n}", "target": 1}
{"code": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n    MemSlot *slot;\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n    slot = &info->mem_slots[group_id][slot_id];\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n    return (void*)(uintptr_t)h_virt;\n}", "target": 1}
{"code": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static void serial_update_parameters(SerialState *s)\n{\n    int speed, parity, data_bits, stop_bits, frame_size;\n    QEMUSerialSetParams ssp;\n    if (s->divider == 0)\n        return;\n    frame_size = 1;\n    if (s->lcr & 0x08) {\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n    if (s->lcr & 0x04)\n        stop_bits = 2;\n    else\n        stop_bits = 1;\n    data_bits = (s->lcr & 0x03) + 5;\n    frame_size += data_bits + stop_bits;\n    speed = s->baudbase / s->divider;\n    ssp.speed = speed;\n    ssp.parity = parity;\n    ssp.data_bits = data_bits;\n    ssp.stop_bits = stop_bits;\n    s->char_transmit_time =  (NANOSECONDS_PER_SECOND / speed) * frame_size;\n    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);\n    DPRINTF(\"speed=%d parity=%c data=%d stop=%d\\n\",\n           speed, parity, data_bits, stop_bits);\n}", "target": 1}
{"code": "addMultirowsForm(Buffer *buf, AnchorList *al)\n{\n    int i, j, k, col, ecol, pos;\n    Anchor a_form, *a;\n    Line *l, *ls;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    for (i = 0; i < al->nanchor; i++) {\n\ta_form = al->anchors[i];\n\tal->anchors[i].rows = 1;\n\tif (a_form.hseq < 0 || a_form.rows <= 1)\n\t    continue;\n\tfor (l = buf->firstLine; l != NULL; l = l->next) {\n\t    if (l->linenumber == a_form.y)\n\t\tbreak;\n\t}\n\tif (!l)\n\t    continue;\n\tif (a_form.y == a_form.start.line)\n\t    ls = l;\n\telse {\n\t    for (ls = l; ls != NULL;\n\t\t ls = (a_form.y < a_form.start.line) ? ls->next : ls->prev) {\n\t\tif (ls->linenumber == a_form.start.line)\n\t\t    break;\n\t    }\n\t    if (!ls)\n\t\tcontinue;\n\t}\n\tcol = COLPOS(ls, a_form.start.pos);\n\tecol = COLPOS(ls, a_form.end.pos);\n\tfor (j = 0; l && j < a_form.rows; l = l->next, j++) {\n\t    pos = columnPos(l, col);\n\t    if (j == 0) {\n\t\tbuf->hmarklist->marks[a_form.hseq].line = l->linenumber;\n\t\tbuf->hmarklist->marks[a_form.hseq].pos = pos;\n\t    }\n\t    if (a_form.start.line == l->linenumber)\n\t\tcontinue;\n\t    buf->formitem = putAnchor(buf->formitem, a_form.url,\n\t\t\t\t      a_form.target, &a, NULL, NULL, '\\0',\n\t\t\t\t      l->linenumber, pos);\n\t    a->hseq = a_form.hseq;\n\t    a->y = a_form.y;\n\t    a->end.pos = pos + ecol - col;\n\t    l->lineBuf[pos - 1] = '[';\n\t    l->lineBuf[a->end.pos] = ']';\n\t    for (k = pos; k < a->end.pos; k++)\n\t\tl->propBuf[k] |= PE_FORM;\n\t}\n    }\n}", "target": 1}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n     return expr;\n }", "target": 1}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n \tif (err)\n \t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:\n\treturn err;\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,\n\t\t\t     u8 *res, unsigned long bufsize)\n{\n\tunsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *ms;\n\tcur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);\n\tms = gfn_to_memslot(kvm, cur_gfn);\n\targs->count = 0;\n\targs->start_gfn = cur_gfn;\n\tif (!ms)\n\t\treturn 0;\n\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\tmem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;\n\twhile (args->count < bufsize) {\n\t\thva = gfn_to_hva(kvm, cur_gfn);\n\t\tif (kvm_is_error_hva(hva))\n\t\t\treturn 0;\n\t\tif (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))\n\t\t\tatomic64_dec(&kvm->arch.cmma_dirty_pages);\n\t\tif (get_pgste(kvm->mm, hva, &pgstev) < 0)\n\t\t\tpgstev = 0;\n\t\tres[args->count++] = (pgstev >> 24) & 0x43;\n\t\tif (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)\n\t\t\treturn 0;\n\t\tif (cur_gfn == next_gfn)\n\t\t\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\t\tif ((next_gfn >= mem_end) ||\n\t\t    (next_gfn - args->start_gfn >= bufsize))\n\t\t\treturn 0;\n\t\tcur_gfn++;\n\t\tif (cur_gfn - ms->base_gfn >= ms->npages) {\n\t\t\tms = gfn_to_memslot(kvm, cur_gfn);\n\t\t\tif (!ms)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n \tstruct context context;\n \tint rc = 0;\n \tif (!ss_initialized) {\n \t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 1}
{"code": "static int ocsp_verify_signer(X509 *signer, int response,\n                              X509_STORE *st, unsigned long flags,\n                              STACK_OF(X509) *untrusted, STACK_OF(X509) **chain)\n{\n    X509_STORE_CTX *ctx = X509_STORE_CTX_new();\n    X509_VERIFY_PARAM *vp;\n    int ret = -1;\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);\n        goto end;\n    }\n    if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)\n        goto end;\n    if ((flags & OCSP_PARTIAL_CHAIN) != 0)\n        X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN);\n    if (response\n            && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0)\n        X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK);\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER);\n    X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST);\n    ret = X509_verify_cert(ctx);\n    if (ret <= 0) {\n        ret = X509_STORE_CTX_get_error(ctx);\n        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n                       \"Verify error: %s\", X509_verify_cert_error_string(ret));\n        goto end;\n    }\n    if (chain != NULL)\n        *chain = X509_STORE_CTX_get1_chain(ctx);\n end:\n    X509_STORE_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,\n\t\t\t\t       struct ext4_inode *raw_inode,\n\t\t\t\t       int isize_diff, size_t ifree,\n\t\t\t\t       size_t bfree, int *total_ino)\n{\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tstruct ext4_xattr_entry *small_entry;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *last;\n\tunsigned int entry_size;\t\n\tunsigned int total_size;\t\n\tunsigned int min_total_size;\n\tint error;\n\twhile (isize_diff > ifree) {\n\t\tentry = NULL;\n\t\tsmall_entry = NULL;\n\t\tmin_total_size = ~0U;\n\t\tlast = IFIRST(header);\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size = EXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (!last->e_value_inum)\n\t\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t       le32_to_cpu(last->e_value_size));\n\t\t\tif (total_size <= bfree &&\n\t\t\t    total_size < min_total_size) {\n\t\t\t\tif (total_size + ifree < isize_diff) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry == NULL)\n\t\t\t\treturn -ENOSPC;\n\t\t\tentry = small_entry;\n\t\t}\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ttotal_size = entry_size;\n\t\tif (!entry->e_value_inum)\n\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\terror = ext4_xattr_move_to_block(handle, inode, raw_inode,\n\t\t\t\t\t\t entry);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*total_ino -= entry_size;\n\t\tifree += total_size;\n\t\tbfree -= total_size;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n\tint groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n     free(data);\n    return ret;\n }", "target": 1}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}", "target": 1}
{"code": " ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n\tu_char *b, *s, *t, c;\n \tint i, proto;\n \tconst void *se;\n         if (length <= 0)\n                 return;\n\tb = (uint8_t *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n \t\t}\n \t\t*t++ = c;\n \t}\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n        if (length < 1)\n                goto trunc;\n        proto = *b; \n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 1}
{"code": "spa_base64_to_bits (char *out, int outlength, const char *in)\n{\n  int len = 0;\n  register uschar digit1, digit2, digit3, digit4;\n  if (in[0] == '+' && in[1] == ' ')\n    in += 2;\n  if (*in == '\\r')\n    return (0);\n  do\n    {\n      if (len >= outlength)                   \n        return (-1);                          \n      digit1 = in[0];\n      if (DECODE64 (digit1) == BAD)\n       return (-1);\n      digit2 = in[1];\n      if (DECODE64 (digit2) == BAD)\n       return (-1);\n      digit3 = in[2];\n      if (digit3 != '=' && DECODE64 (digit3) == BAD)\n       return (-1);\n      digit4 = in[3];\n      if (digit4 != '=' && DECODE64 (digit4) == BAD)\n       return (-1);\n      in += 4;\n      *out++ = (DECODE64 (digit1) << 2) | (DECODE64 (digit2) >> 4);\n      ++len;\n      if (digit3 != '=')\n       {\n         if (len >= outlength)                   \n           return (-1);                          \n         *out++ =\n           ((DECODE64 (digit2) << 4) & 0xf0) | (DECODE64 (digit3) >> 2);\n         ++len;\n         if (digit4 != '=')\n           {\n             if (len >= outlength)                   \n               return (-1);                          \n             *out++ = ((DECODE64 (digit3) << 6) & 0xc0) | DECODE64 (digit4);\n             ++len;\n           }\n       }\n    }\n  while (*in && *in != '\\r' && digit4 != '=');\n  return (len);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32_t code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 1}
{"code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\treturn lowbits;\n}", "target": 1}
{"code": "PHP_FUNCTION(oci_lob_load)\n{\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *buffer = NULL;\n\tub4 buffer_len;\n\tif (!getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {\n\t\t\treturn;\n\t\t}\t\n\t}\n\tif (strlen(filename) != filename_len) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\tif (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (buffer_len > 0) {\n\t\tRETURN_STRINGL(buffer, buffer_len, 0);\n\t}\n\telse {\n\t\tRETURN_EMPTY_STRING();\n\t}\n}", "target": 1}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n \tctl_dir = container_of(head, struct ctl_dir, header);\n \tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n \tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n \t\t\tbreak;\n \t\t}\n \t}\n \tsysctl_head_finish(head);\n \treturn 0;\n }", "target": 1}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t\n  int strsize;\t\t\t\n  int next_ch;\n  insize = 0;\n  strsize = s->ds_length;\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}", "target": 1}
{"code": "    void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; \n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n            io_->seek(resourceNameLength, BasicIo::cur);\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        \n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n    } ", "target": 1}
{"code": " void ipc_rcu_putref(void *ptr)\n {\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n \t\treturn;\n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        if (checklist.fastCheck().allowed() && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n         return false;\n     str = xkb_atom_text(ctx, field);\n     if (istreq(str, \"all\")) {\n         *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 1}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if (size < 2 || o > size-2) throw Error(kerNotACrwImage);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        for (uint16_t i = 0; i < count; ++i) {\n            if (o + 10 > size) throw Error(kerNotACrwImage);\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; \n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\t{\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}", "target": 1}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::UniquePtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::UniquePtr(new CiffDirectory); break;\n            default: m = CiffComponent::UniquePtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(std::move(m));\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "local int construct(struct huffman *h, boost::int16_t *length, int n)\n{\n    int symbol;         \n    int len;            \n    int left;           \n\t boost::int16_t offs[MAXBITS+1];      \n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   \n    if (h->count[0] == n)               \n        return 0;                       \n    left = 1;                           \n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     \n        left -= h->count[len];          \n        if (left < 0) return left;      \n    }                                   \n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n    return left;\n}", "target": 1}
{"code": " static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n {\n\tint ret;\n \tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n \t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n }", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,\n                                      const GURL& embedding_origin) {\n  DCHECK_EQ(requesting_origin, requesting_origin.GetOrigin());\n  DCHECK_EQ(embedding_origin, embedding_origin.GetOrigin());\n  if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return {};\n   std::vector<std::unique_ptr<Object>> results;\n  auto* info = new content_settings::SettingInfo();\n   std::unique_ptr<base::DictionaryValue> setting =\n      GetWebsiteSetting(requesting_origin, embedding_origin, info);\n   std::unique_ptr<base::Value> objects;\n   if (!setting->Remove(kObjectListKey, &objects))\n     return results;\n  std::unique_ptr<base::ListValue> object_list =\n      base::ListValue::From(std::move(objects));\n  if (!object_list)\n    return results;\n  for (auto& object : *object_list) {\n     base::DictionaryValue* object_dict;\n     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {\n       results.push_back(std::make_unique<Object>(\n          requesting_origin, embedding_origin, object_dict, info->source,\n           host_content_settings_map_->is_incognito()));\n     }\n   }\n  return results;\n}", "target": 1}
{"code": "bool ReturnsValidPath(int dir_type) {\n  base::FilePath path;\n  bool result = PathService::Get(dir_type, &path);\n  bool check_path_exists = true;\n#if defined(OS_POSIX)\n  if (dir_type == base::DIR_CACHE)\n    check_path_exists = false;\n#endif\n#if defined(OS_LINUX)\n  if (dir_type == base::DIR_USER_DESKTOP)\n    check_path_exists = false;\n#endif\n#if defined(OS_WIN)\n  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {\n    if (base::win::GetVersion() < base::win::VERSION_VISTA) {\n      wchar_t default_profile_path[MAX_PATH];\n      DWORD size = arraysize(default_profile_path);\n      return (result &&\n              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&\n              StartsWith(path.value(), default_profile_path, false));\n    }\n  } else if (dir_type == base::DIR_TASKBAR_PINS) {\n    if (base::win::GetVersion() < base::win::VERSION_WIN7)\n       check_path_exists = false;\n   }\n #endif\n#if defined(OS_MAC)\n   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&\n       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {\n     if (path.ReferencesParent())\n      return false;\n  }\n#else\n  if (path.ReferencesParent())\n    return false;\n#endif\n  return result && !path.empty() && (!check_path_exists ||\n                                     file_util::PathExists(path));\n}", "target": 1}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "HRESULT Http::HrReadHeaders()\n{\n\tHRESULT hr;\n\tstd::string strBuffer;\n\tULONG n = 0;\n\tstd::map<std::string, std::string>::iterator iHeader = mapHeaders.end();\n\tec_log_debug(\"Receiving headers:\");\n\tdo\n\t{\n\t\thr = m_lpChannel->HrReadLine(strBuffer);\n\t\tif (hr != hrSuccess)\n\t\t\treturn hr;\n\t\tif (strBuffer.empty())\n\t\t\tbreak;\n\t\tif (n == 0) {\n\t\t\tm_strAction = strBuffer;\n\t\t} else {\n\t\t\tauto pos = strBuffer.find(':');\n\t\t\tsize_t start = 0;\n\t\t\tif (strBuffer[0] == ' ' || strBuffer[0] == '\\t') {\n\t\t\t\tif (iHeader == mapHeaders.end())\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (strBuffer[start] == ' ' || strBuffer[start] == '\\t')\n\t\t\t\t\t++start;\n\t\t\t\tiHeader->second += strBuffer.substr(start);\n\t\t\t} else {\n\t\t\t\tauto r = mapHeaders.emplace(strBuffer.substr(0, pos), strBuffer.substr(pos + 2));\n\t\t\t\tiHeader = r.first;\n\t\t\t}\n\t\t}\n\t\tif (strBuffer.find(\"Authorization\") != std::string::npos)\n\t\t\tec_log_debug(\"< Authorization: <value hidden>\");\n\t\telse\n\t\t\tec_log_debug(\"< \"+strBuffer);\n\t\t++n;\n\t} while(hr == hrSuccess);\n\thr = HrParseHeaders();\n\tif (hr != hrSuccess)\n\t\thr_ldebug(hr, \"parsing headers failed\");\n\treturn hr;\n}", "target": 1}
{"code": "int tm_adopt(\n  char  *id,\n  int    adoptCmd,\n  pid_t  pid)\n  {\n  int rc = TM_SUCCESS;\n  int status, ret;\n  pid_t sid;\n  char *env;\n  struct tcp_chan *chan = NULL;\n  sid = getsid(pid);\n  if (init_done) return TM_BADINIT;\n  init_done = 1;\n  if ((tm_jobid = getenv(\"PBS_JOBID\")) == NULL)\n    tm_jobid = (char *)\"ADOPT JOB\";\n  tm_jobid_len = strlen(tm_jobid);\n  if ((tm_jobcookie = getenv(\"PBS_JOBCOOKIE\")) == NULL)\n    tm_jobcookie = (char *)\"ADOPT COOKIE\";\n  tm_jobcookie_len = strlen(tm_jobcookie);\n  tm_jobndid = 0;\n  tm_jobtid = 0;\n  if ((env = getenv(\"PBS_MOMPORT\")) == NULL || (tm_momport = atoi(env)) == 0)\n    tm_momport = PBS_MANAGER_SERVICE_PORT;\n  if (adoptCmd != TM_ADOPT_ALTID && adoptCmd != TM_ADOPT_JOBID)\n    return TM_EUNKNOWNCMD;\n  if (startcom(adoptCmd, TM_NULL_EVENT, &chan) != DIS_SUCCESS)\n    return TM_ESYSTEM;\n  if (diswsi(chan, sid) != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswsi(chan, pid) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswcs(chan, id, strlen(id)) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  DIS_tcp_wflush(chan);\n  status = disrsi(chan, &ret);\n  if (ret != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  tm_finalize();\n  if (local_conn > -1)\n    {\n    close(local_conn);\n    local_conn = -1;\n    }\n  DIS_tcp_cleanup(chan);\n  return (status == TM_OKAY ?\n          TM_SUCCESS :\n          TM_ENOTFOUND);\ntm_adopt_cleanup:\n  if (chan != NULL)\n    DIS_tcp_cleanup(chan);\n  return rc;\n  }", "target": 1}
{"code": "int main()\n{\n   initialize_environment();\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n   test_heap_overflow_vrend_renderer_transfer_write_iov();\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n   return 0;\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tinit_logging(tmate_settings->log_level);\n\tsetup_locale();\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}", "target": 1}
{"code": "static gint conv_jistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tgchar *out = outbuf;\n\tJISState state = JIS_ASCII;\n\twhile (*in != '\\0' && (out - outbuf) > outlen - 3) {\n\t\tif (*in == ESC) {\n\t\t\tin++;\n\t\t\tif (*in == '$') {\n\t\t\t\tif (*(in + 1) == '@' || *(in + 1) == 'B') {\n\t\t\t\t\tstate = JIS_KANJI;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == '(' &&\n\t\t\t\t\t   *(in + 2) == 'D') {\n\t\t\t\t\tstate = JIS_AUXKANJI;\n\t\t\t\t\tin += 3;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else if (*in == '(') {\n\t\t\t\tif (*(in + 1) == 'B' || *(in + 1) == 'J') {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == 'I') {\n\t\t\t\t\tstate = JIS_HWKANA;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate = JIS_ASCII;\n\t\t\t}\n\t\t} else if (*in == 0x0e) {\n\t\t\tstate = JIS_HWKANA;\n\t\t\tin++;\n\t\t} else if (*in == 0x0f) {\n\t\t\tstate = JIS_ASCII;\n\t\t\tin++;\n\t\t} else {\n\t\t\tswitch (state) {\n\t\t\tcase JIS_ASCII:\n\t\t\t\t*out++ = *in++;\n\t\t\t\tbreak;\n\t\t\tcase JIS_KANJI:\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_HWKANA:\n\t\t\t\t*out++ = 0x8e;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_AUXKANJI:\n\t\t\t\t*out++ = 0x8f;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "png_read_chunk_header(png_structrp png_ptr)\n{\n   png_byte buf[8];\n   png_uint_32 length;\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\n#endif\n   png_read_data(png_ptr, buf, 8);\n   length = png_get_uint_31(png_ptr, buf);\n   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n   png_debug2(0, \"Reading %lx chunk, length = %lu\",\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n   png_reset_crc(png_ptr);\n   png_calculate_crc(png_ptr, buf + 4, 4);\n   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n   if (png_ptr->chunk_name != png_IDAT)\n   {\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n      if (png_ptr->user_chunk_malloc_max > 0 &&\n          png_ptr->user_chunk_malloc_max < limit)\n         limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n      if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n         limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   }\n   else\n   {\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         limit=PNG_UINT_31_MAX;\n      else\n         limit = png_ptr->height * row_factor;\n      limit += 6 + 5*(limit/32566+1); \n      limit=limit < PNG_UINT_31_MAX? limit : PNG_UINT_31_MAX;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\n#endif\n   return length;\n}", "target": 1}
{"code": "static struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\tinode = base->d_inode;\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tdentry = cached_lookup(base, name, nd);\n\tif (!dentry) {\n\t\tstruct dentry *new = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}", "target": 1}
{"code": "int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\txfrm_pol_put(pol);\n\treturn 0;\nout:\n\treturn err;\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\treturn err;\n}", "target": 1}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n \t\tbreak;\n \tcase PTR_TO_STACK:\n \t\tpointer_desc = \"stack \";\n \t\tbreak;\n \tdefault:\n \t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n     delete frame;  \n     return mThumbnail;\n }", "target": 1}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "hufDecode\n    (const Int64 * \thcode,\t\n     const HufDec * \thdecod,\t\n     const char* \tin,\t\n     int\t\tni,\t\n     int\t\trlc,\t\n     int\t\tno,\t\n     unsigned short*\tout)\t\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; \n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\t    if (pl.len)\n\t    {\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); \n\t\tint j;\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\t\t    while (lc < l && in < ie)\t\n\t\t\tgetChar (c, lc, in);\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); \n\t    }\n\t}\n    }\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); \n\t}\n    }\n    if (out - outb != no)\n\tnotEnoughData ();\n}", "target": 1}
{"code": "static pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\tsize = ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tlong ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number of colors has to be greater than zero\");\n \t\tRETURN_FALSE;\n \t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n \tRETURN_TRUE;\n }", "target": 1}
{"code": " static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return((image->columns+7)/8);\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }", "target": 1}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n \tstruct iov_iter i;\n \tint ret;\n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n unmap_rq:\n \t__blk_rq_unmap_user(bio);\n \trq->bio = NULL;\n \treturn -EINVAL;\n }", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n     if (!c->synth_tile || !c->jpeg_tile ||\n         c->old_tile_w < c->tile_width ||\n         c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n         aligned_height = FFALIGN(c->tile_height,    16);\n         av_free(c->synth_tile);\n         av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n \tint rc;\n \tu64 base_addr, size;\n \tif (flags && (flags &\n \t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\treturn rc;\n}", "target": 1}
{"code": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n     Mutex::Autolock autoLock(mLock);\n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n \t}\n\tmsg->msg_namelen = sizeof(*sax);\n \tskb_free_datagram(sk, skb);\n \trelease_sock(sk);\n\treturn copied;\n}", "target": 1}
{"code": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n    if (stuff->num_events == 0)\n        return ret;\n     first = ((xEvent *) &stuff[1]);\n    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&\n          (first->u.u.type < lastEvent))) {\n        client->errorValue = first->u.u.type;\n        return BadValue;\n     }\n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n    return ret;\n}", "target": 1}
{"code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n \telf_xtregs_t *xtregs = uregs;\n \tint ret = 0;\n #if XTENSA_HAVE_COPROCESSORS\n \tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\treturn ret ? -EFAULT : 0;\n}", "target": 1}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n {\n \tuint8_t route_target[8];\n \tu_int plen;\n \tND_TCHECK(pptr[0]);\n \tplen = pptr[0];   \n \tif (0 == plen) {\n \t\tsnprintf(buf, buflen, \"default route target\");\n \t\treturn 1;\n \t}\n \tif (32 > plen)\n \t\treturn -1;\n         plen-=32; \n \tif (64 < plen)\n \t\treturn -1;\n \tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n \tif (plen % 8) {\n \t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n \t\t\t((0xff00 >> (plen % 8)) & 0xff);\n \t}\n \tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n \t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n \treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "unsigned long X509_issuer_and_serial_hash(X509 *a)\n{\n    unsigned long ret = 0;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned char md[16];\n    char *f;\n    if (ctx == NULL)\n        goto err;\n    f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0);\n    if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL))\n        goto err;\n    if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))\n        goto err;\n    OPENSSL_free(f);\n    if (!EVP_DigestUpdate\n        (ctx, (unsigned char *)a->cert_info.serialNumber.data,\n         (unsigned long)a->cert_info.serialNumber.length))\n        goto err;\n    if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL))\n        goto err;\n    ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\n           ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\n        ) & 0xffffffffL;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "int FFmpegVideoDecoder::GetVideoBuffer(AVCodecContext* codec_context,\n                                       AVFrame* frame) {\n  VideoFrame::Format format = PixelFormatToVideoFormat(codec_context->pix_fmt);\n  if (format == VideoFrame::UNKNOWN)\n    return AVERROR(EINVAL);\n  DCHECK(format == VideoFrame::YV12 || format == VideoFrame::YV16 ||\n          format == VideoFrame::YV12J);\n   gfx::Size size(codec_context->width, codec_context->height);\n  int ret;\n  if ((ret = av_image_check_size(size.width(), size.height(), 0, NULL)) < 0)\n     return ret;\n   gfx::Size natural_size;\n  if (codec_context->sample_aspect_ratio.num > 0) {\n    natural_size = GetNaturalSize(size,\n                                  codec_context->sample_aspect_ratio.num,\n                                  codec_context->sample_aspect_ratio.den);\n  } else {\n     natural_size = config_.natural_size();\n   }\n  if (!VideoFrame::IsValidConfig(format, size, gfx::Rect(size), natural_size))\n     return AVERROR(EINVAL);\n  scoped_refptr<VideoFrame> video_frame =\n      frame_pool_.CreateFrame(format, size, gfx::Rect(size),\n                              natural_size, kNoTimestamp());\n   for (int i = 0; i < 3; i++) {\n     frame->base[i] = video_frame->data(i);\n    frame->data[i] = video_frame->data(i);\n    frame->linesize[i] = video_frame->stride(i);\n  }\n   frame->opaque = NULL;\n   video_frame.swap(reinterpret_cast<VideoFrame**>(&frame->opaque));\n   frame->type = FF_BUFFER_TYPE_USER;\n  frame->width = codec_context->width;\n  frame->height = codec_context->height;\n   frame->format = codec_context->pix_fmt;\n   return 0;\n}", "target": 1}
{"code": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n \tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n \tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n \tunsigned int ovp_segments, reserved_segments;\n \ttotal = le32_to_cpu(raw_super->segment_count);\n \tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n \t\treturn 1;\n \t}\n \tif (unlikely(f2fs_cp_error(sbi))) {\n \t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n \t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* reverse_index_map_t;\n    const Tensor* grad_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"reverse_index_map\", &reverse_index_map_t));\n    OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n        errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                reverse_index_map_t->shape().DebugString()));\n    const auto reverse_index_map = reverse_index_map_t->vec<int64>();\n    const auto grad_values = grad_values_t->vec<T>();\n    const int64 N = reverse_index_map_t->shape().dim_size(0);\n    const int64 N_full = grad_values_t->shape().dim_size(0);\n    Tensor* d_values_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"d_values\", TensorShape({N}), &d_values_t));\n    auto d_values = d_values_t->vec<T>();\n    Tensor* d_default_value_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"d_default_value\", TensorShape({}),\n                                            &d_default_value_t));\n    T& d_default_value = d_default_value_t->scalar<T>()();\n    d_default_value = T();\n    Tensor visited_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(d) = visited.constant(false);\n    for (int i = 0; i < N; ++i) {\n      d_values(i) = grad_values(reverse_index_map(i));\n      visited(reverse_index_map(i)) = true;\n    }\n    for (int j = 0; j < N_full; ++j) {\n      if (!visited(j)) {\n        d_default_value += grad_values(j);\n      }\n    }\n  }", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\tzap = upayload;\n\tret = key_payload_reserve(key, datalen);\n \tif (ret == 0) {\n\t\tzap = key->payload.data[0];\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static ptrdiff_t finderrfunc(lua_State *L)\n{\n  cTValue *frame = L->base-1, *bot = tvref(L->stack);\n  void *cf = L->cframe;\n  while (frame > bot && cf) {\n    while (cframe_nres(cframe_raw(cf)) < 0) {  \n      if (frame >= restorestack(L, -cframe_nres(cf)))\n\tbreak;\n      if (cframe_errfunc(cf) >= 0)  \n\treturn cframe_errfunc(cf);\n      cf = cframe_prev(cf);  \n      if (cf == NULL)\n\treturn 0;\n    }\n    switch (frame_typep(frame)) {\n    case FRAME_LUA:\n    case FRAME_LUAP:\n      frame = frame_prevl(frame);\n      break;\n    case FRAME_C:\n      cf = cframe_prev(cf);\n    case FRAME_VARG:\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CONT:\n#if LJ_HASFFI\n      if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK)\n\tcf = cframe_prev(cf);\n#endif\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CP:\n      if (cframe_canyield(cf)) return 0;\n      if (cframe_errfunc(cf) >= 0)\n\treturn cframe_errfunc(cf);\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_PCALL:\n    case FRAME_PCALLH:\n      if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))  \n\treturn savestack(L, frame-1);  \n      return 0;\n    default:\n      lua_assert(0);\n      return 0;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    int atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  \n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize <= 0)\n       break;  \n     offset += atomsize;\n   }\n  return true;\n}", "target": 1}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 1}
{"code": "AcpiNsTerminate (\n     void)\n {\n     ACPI_STATUS             Status;\n     ACPI_FUNCTION_TRACE (NsTerminate);\n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; \n            AcpiUtRemoveReference (Prev);\n        }\n     }\n#endif\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}", "target": 1}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "_PUBLIC_ codepoint_t next_codepoint_handle_ext(\n\t\t\tstruct smb_iconv_handle *ic,\n\t\t\tconst char *str, size_t len,\n\t\t\tcharset_t src_charset,\n\t\t\tsize_t *bytes_consumed)\n{\n\tuint8_t buf[4];\n\tsmb_iconv_t descriptor;\n\tsize_t ilen_orig;\n\tsize_t ilen;\n        size_t olen;\n        char *outbuf;\n       if ((str[0] & 0x80) == 0) {\n                *bytes_consumed = 1;\n                return (codepoint_t)str[0];\n        }\n\t * This is OK as we only support codepoints up to 1M (U+100000)\n\t */\n\tilen_orig = MIN(len, 5);\n\tilen = ilen_orig;\n\tdescriptor = get_conv_handle(ic, src_charset, CH_UTF16);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\t*bytes_consumed = 1;\n\t\treturn INVALID_CODEPOINT;\n\t}\n\tolen = 2;\n\toutbuf = (char *)buf;\n\tsmb_iconv(descriptor, &str, &ilen, &outbuf, &olen);\n\tif (olen == 2) {\n\t\tolen = 4;\n\t\toutbuf = (char *)buf;\n\t\tsmb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);\n\t\tif (olen == 4) {\n\t\t\t*bytes_consumed = 1;\n\t\t\treturn INVALID_CODEPOINT;\n\t\t}\n\t\tolen = 4 - olen;\n\t} else {\n\t\tolen = 2 - olen;\n\t}\n\t*bytes_consumed = ilen_orig - ilen;\n\tif (olen == 2) {\n\t\treturn (codepoint_t)SVAL(buf, 0);\n\t}\n\tif (olen == 4) {\n\t\treturn (codepoint_t)0x10000 +\n\t\t\t(buf[2] | ((buf[3] & 0x3)<<8) |\n\t\t\t (buf[0]<<10) | ((buf[1] & 0x3)<<18));\n\t}\n\treturn INVALID_CODEPOINT;\n}", "target": 1}
{"code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n \t\tRETURN_FALSE;\n \t}\n \tZ_STRVAL_P(return_value) = emalloc(len + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n \tint res;\n \tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tunregister_netdev(sp->dev);\n}", "target": 1}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n \t    return(-1);\t\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n     }\n     return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n            if (lp - bn_data >= bn_data_num)\n                goto err;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    if (bn_data != NULL)\n        OPENSSL_free(bn_data);\n    if (t != NULL)\n        BN_free(t);\n    if (!ok && buf) {\n        OPENSSL_free(buf);\n        buf = NULL;\n    }\n    return (buf);\n}", "target": 1}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n   struct SParser *p = cast(struct SParser *, ud);\n   int c = luaZ_lookahead(p->z);\n   luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                              &p->buff, p->name);\n   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n   cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}", "target": 1}
{"code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}", "target": 1}
{"code": "sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const\n{\n if (mHeap == 0) {\n Parcel data, reply;\n        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());\n if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {\n            sp<IBinder> heap = reply.readStrongBinder();\n ssize_t o = reply.readInt32();\n size_t s = reply.readInt32();\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n                    mOffset = o;\n                    mSize = s;\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n    return mHeap;\n }", "target": 1}
{"code": " lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n \t\t  const unsigned int nlen)\n {\n\tstruct enamemem *tp;\n \tregister u_int i, j, k;\n \tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n \t\ti = j = k = 0;\n \ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n \t\t\treturn tp;\n \t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \treturn tp;\n}", "target": 1}
{"code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = udp_hdr(p);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\t\treturn pp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n \t\trcu_read_lock();\n \t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n \t\t\tifa = indev->ifa_list;\n \t\t\tnewdst = ifa->ifa_local;\n \t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n    return OPJ_FALSE;\n}", "target": 1}
{"code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n \t\t(serial->num_interrupt_in == 0))\n \t\treturn 0;\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\treturn 0;\n}", "target": 1}
{"code": "CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,\n                                       const char *domain, size_t domlen,\n                                       unsigned char *ntlmhash,\n                                       unsigned char *ntlmv2hash)\n{\n  size_t identity_len = (userlen + domlen) * 2;\n  unsigned char *identity = malloc(identity_len);\n  CURLcode result = CURLE_OK;\n  if(!identity)\n    return CURLE_OUT_OF_MEMORY;\n  ascii_uppercase_to_unicode_le(identity, user, userlen);\n  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);\n  result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len),\n                         ntlmv2hash);\n  free(identity);\n  return result;\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n \t\t\t\tif(!tmp)\t\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n             break;\n         c++;\n     }\n     if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n         return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 1}
{"code": "static int sony_init_ff(struct sony_sc *sc)\n{\n\tstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\n}", "target": 1}
{"code": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}", "target": 1}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "compile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n \t\treturn NULL;\n \t}\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\treturn key_pairs;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": " static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n \t\t\t\t       int rw, char __user *buf,\n \t\t\t\t       unsigned long *nr_segs,\n \t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n {\n \tif (unlikely(!access_ok(!rw, buf, len)))\n \t\treturn -EFAULT;\n \tiovec->iov_base = buf;\n \tiovec->iov_len = len;\n \t*nr_segs = 1;\n \treturn 0;\n }", "target": 1}
{"code": "int32_t PepperFlashRendererHost::OnNavigate(\n    ppapi::host::HostMessageContext* host_context,\n    const ppapi::URLRequestInfoData& data,\n    const std::string& target,\n    bool from_user_action) {\n  content::PepperPluginInstance* plugin_instance =\n      host_->GetPluginInstance(pp_instance());\n   if (!plugin_instance)\n     return PP_ERROR_FAILED;\n  ppapi::proxy::HostDispatcher* host_dispatcher =\n      ppapi::proxy::HostDispatcher::GetForInstance(pp_instance());\n  host_dispatcher->set_allow_plugin_reentrancy();\n  base::WeakPtr<PepperFlashRendererHost> weak_ptr = weak_factory_.GetWeakPtr();\n  navigate_replies_.push_back(host_context->MakeReplyMessageContext());\n  plugin_instance->Navigate(data, target.c_str(), from_user_action);\n  if (weak_ptr.get()) {\n    SendReply(navigate_replies_.back(), IPC::Message());\n    navigate_replies_.pop_back();\n  }\n  return PP_OK_COMPLETIONPENDING;\n}", "target": 1}
{"code": "fmtfloat(double value, char type, int forcesign, int leftjust,\n\t\t int minlen, int zpad, int precision, int pointflag,\n\t\t PrintfTarget *target)\n{\n\tint\t\t\tsignvalue = 0;\n\tint\t\t\tvallen;\n\tchar\t\tfmt[32];\n\tchar\t\tconvert[512];\n\tint\t\t\tpadlen = 0;\t\t\n\tif (pointflag)\n\t\tsprintf(fmt, \"%%.%d%c\", precision, type);\n\telse\n\t\tsprintf(fmt, \"%%%c\", type);\n\tif (adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tvallen = sprintf(convert, fmt, value);\n\tadjust_padlen(minlen, vallen, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\tdostr(convert, vallen, target);\n\ttrailing_pad(&padlen, target);\n}", "target": 1}
{"code": "PS_SERIALIZER_DECODE_FUNC(php_binary) \n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\t\tname = estrndup(p + 1, namelen);\n\t\tp += namelen + 1;\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": "static size_t oss_write(HWVoiceOut *hw, void *buf, size_t len)\n{\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n    size_t pos;\n    if (oss->mmapped) {\n        size_t total_len;\n        len = MIN(len, oss_get_available_bytes(oss));\n        total_len = len;\n        while (len) {\n            size_t to_copy = MIN(len, hw->size_emul - hw->pos_emul);\n            memcpy(hw->buf_emul + hw->pos_emul, buf, to_copy);\n            hw->pos_emul = (hw->pos_emul + to_copy) % hw->pos_emul;\n            buf += to_copy;\n            len -= to_copy;\n        }\n        return total_len;\n    }\n    pos = 0;\n    while (len) {\n        ssize_t bytes_written;\n        void *pcm = advance(buf, pos);\n        bytes_written = write(oss->fd, pcm, len);\n        if (bytes_written < 0) {\n            if (errno != EAGAIN) {\n                oss_logerr(errno, \"failed to write %zu bytes\\n\",\n                           len);\n            }\n            return pos;\n        }\n        pos += bytes_written;\n        if (bytes_written < len) {\n            break;\n        }\n        len -= bytes_written;\n    }\n    return pos;\n}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n\t\tint is_valid;\n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n \tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n \t\tstruct sk_buff *head = qp->q.fragments;\n \t\trcu_read_lock();\n \t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \t\tif (!head->dev)\n \t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n \t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n  MagickOffsetType\n    offset;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "  psh_glyph_find_strong_points( PSH_Glyph  glyph,\n                                FT_Int     dimension )\n  {\n    PSH_Hint_Table  table     = &glyph->hint_tables[dimension];\n    PS_Mask         mask      = table->hint_masks->masks;\n    FT_UInt         num_masks = table->hint_masks->num_masks;\n    FT_UInt         first     = 0;\n    FT_Int          major_dir = dimension == 0 ? PSH_DIR_VERTICAL\n                                               : PSH_DIR_HORIZONTAL;\n    PSH_Dimension   dim       = &glyph->globals->dimension[dimension];\n    FT_Fixed        scale     = dim->scale_mult;\n    FT_Int          threshold;\n    threshold = (FT_Int)FT_DivFix( PSH_STRONG_THRESHOLD, scale );\n    if ( threshold > PSH_STRONG_THRESHOLD_MAXIMUM )\n      threshold = PSH_STRONG_THRESHOLD_MAXIMUM;\n     if ( num_masks > 1 && glyph->num_points > 0 )\n     {\n      first = mask->end_point;\n       mask++;\n       for ( ; num_masks > 1; num_masks--, mask++ )\n       {\n        next  = mask->end_point;\n         FT_Int   count;\n        next  = mask->end_point;\n         count = next - first;\n         if ( count > 0 )\n         {\n                                             threshold, major_dir );\n        }\n        first = next;\n      }\n    }\n    if ( num_masks == 1 )\n    {\n      FT_UInt    count = glyph->num_points;\n      PSH_Point  point = glyph->points;\n      psh_hint_table_activate_mask( table, table->hint_masks->masks );\n      psh_hint_table_find_strong_points( table, point, count,\n                                         threshold, major_dir );\n    }\n    {\n      FT_UInt    count = glyph->num_points;\n      PSH_Point  point = glyph->points;\n      for ( ; count > 0; count--, point++ )\n        if ( point->hint && !psh_point_is_strong( point ) )\n          psh_point_set_strong( point );\n    }\n  }", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n \t\t\t}\n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\tunregister_candev(priv->netdev);\n\tfree_candev(priv->netdev);\n\tmcba_urb_unlink(priv);\n}", "target": 1}
{"code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n    ptr = (uint8_t *)client->buffer;\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n    return TRUE;\n}", "target": 1}
{"code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\tif (directory == NULL)\n\t\treturn TRUE;\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\tg_object_unref (enumerator);\n\treturn ! error_occurred;\n}", "target": 1}
{"code": "void ScriptLoader::executeScript(const ScriptSourceCode& sourceCode)\n{\n    ASSERT(m_alreadyStarted);\n    if (sourceCode.isEmpty())\n        return;\n    RefPtr<Document> elementDocument(m_element->document());\n    RefPtr<Document> contextDocument = elementDocument->contextDocument().get();\n    if (!contextDocument)\n        return;\n    LocalFrame* frame = contextDocument->frame();\n    bool shouldBypassMainWorldContentSecurityPolicy = (frame && frame->script().shouldBypassMainWorldContentSecurityPolicy()) || elementDocument->contentSecurityPolicy()->allowScriptNonce(m_element->fastGetAttribute(HTMLNames::nonceAttr)) || elementDocument->contentSecurityPolicy()->allowScriptHash(sourceCode.source());\n     if (!m_isExternalScript && (!shouldBypassMainWorldContentSecurityPolicy && !elementDocument->contentSecurityPolicy()->allowInlineScript(elementDocument->url(), m_startLineNumber)))\n         return;\n    if (m_isExternalScript && m_resource && !m_resource->mimeTypeAllowedByNosniff()) {\n        contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, \"Refused to execute script from '\" + m_resource->url().elidedString() + \"' because its MIME type ('\" + m_resource->mimeType() + \"') is not executable, and strict MIME type checking is enabled.\");\n        return;\n     }\n     if (frame) {\n        const bool isImportedScript = contextDocument != elementDocument;\n        IgnoreDestructiveWriteCountIncrementer ignoreDestructiveWriteCountIncrementer(m_isExternalScript || isImportedScript ? contextDocument.get() : 0);\n        if (isHTMLScriptLoader(m_element))\n            contextDocument->pushCurrentScript(toHTMLScriptElement(m_element));\n        AccessControlStatus corsCheck = NotSharableCrossOrigin;\n        if (sourceCode.resource() && sourceCode.resource()->passesAccessControlCheck(m_element->document().securityOrigin()))\n            corsCheck = SharableCrossOrigin;\n        frame->script().executeScriptInMainWorld(sourceCode, corsCheck);\n        if (isHTMLScriptLoader(m_element)) {\n            ASSERT(contextDocument->currentScript() == m_element);\n            contextDocument->popCurrentScript();\n        }\n    }\n}", "target": 1}
{"code": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n \t\thwc->event_base\t= 0;\n \t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n \t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n \t} else {\n \t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n \t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n    ptr = buf;\n    chunk = 3 * state->xsize;\n    for (;;) {\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\tptr += chunk;\n\tbytes -= chunk;\n    }\n}", "target": 1}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 1}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "bool ParamTraits<LOGFONT>::Read(const Message* m, PickleIterator* iter,\n                                 param_type* r) {\n   const char *data;\n   int data_size = 0;\n  bool result = m->ReadData(iter, &data, &data_size);\n  if (result && data_size == sizeof(LOGFONT)) {\n    memcpy(r, data, sizeof(LOGFONT));\n  } else {\n    result = false;\n    NOTREACHED();\n   }\n  return result;\n }", "target": 1}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n \t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n \t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n \t\t\tresult = (ioapic->ioregsel & 0x1) ?\n \t\t\t    (redir_content >> 32) & 0xffffffff :\n \t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}", "target": 0}
{"code": "int bio_add_pc_page(struct request_queue *q, struct bio *bio, struct page\n\t\t    *page, unsigned int len, unsigned int offset)\n{\n\tint retried_segments = 0;\n\tstruct bio_vec *bvec;\n\tif (unlikely(bio_flagged(bio, BIO_CLONED)))\n\t\treturn 0;\n\tif (((bio->bi_iter.bi_size + len) >> 9) > queue_max_hw_sectors(q))\n\t\treturn 0;\n\tif (bio->bi_vcnt > 0) {\n\t\tstruct bio_vec *prev = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\t\tif (page == prev->bv_page &&\n\t\t    offset == prev->bv_offset + prev->bv_len) {\n\t\t\tprev->bv_len += len;\n\t\t\tbio->bi_iter.bi_size += len;\n\t\t\tgoto done;\n\t\t}\n\t\tif (bvec_gap_to_prev(q, prev, offset))\n\t\t\treturn 0;\n\t}\n\tif (bio->bi_vcnt >= bio->bi_max_vecs)\n\t\treturn 0;\n\tbvec = &bio->bi_io_vec[bio->bi_vcnt];\n\tbvec->bv_page = page;\n\tbvec->bv_len = len;\n\tbvec->bv_offset = offset;\n\tbio->bi_vcnt++;\n\tbio->bi_phys_segments++;\n\tbio->bi_iter.bi_size += len;\n\twhile (bio->bi_phys_segments > queue_max_segments(q)) {\n\t\tif (retried_segments)\n\t\t\tgoto failed;\n\t\tretried_segments = 1;\n\t\tblk_recount_segments(q, bio);\n\t}\n\tif (bio->bi_vcnt > 1 && (BIOVEC_PHYS_MERGEABLE(bvec-1, bvec)))\n\t\tbio_clear_flag(bio, BIO_SEG_VALID);\n done:\n\treturn len;\n failed:\n\tbvec->bv_page = NULL;\n\tbvec->bv_len = 0;\n\tbvec->bv_offset = 0;\n\tbio->bi_vcnt--;\n\tbio->bi_iter.bi_size -= len;\n\tblk_recount_segments(q, bio);\n\treturn 0;\n}", "target": 0}
{"code": "const SSL_CIPHER *dtls1_get_cipher(unsigned int u)\n{\n    const SSL_CIPHER *ciph = ssl3_get_cipher(u);\n    if (ciph != NULL) {\n        if (ciph->algorithm_enc == SSL_RC4)\n            return NULL;\n    }\n    return ciph;\n}", "target": 0}
{"code": "static void bnx2x_udp_tunnel_add(struct net_device *netdev,\n\t\t\t\t struct udp_tunnel_info *ti)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu16 t_port = ntohs(ti->port);\n\tswitch (ti->type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\t__bnx2x_add_udp_port(bp, t_port, BNX2X_UDP_PORT_VXLAN);\n\t\tbreak;\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\t__bnx2x_add_udp_port(bp, t_port, BNX2X_UDP_PORT_GENEVE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static char * xstrdup(const char * s)\n{\n    char * t ;\n    size_t len ;\n    if (!s)\n        return NULL ;\n    len = strlen(s) + 1 ;\n    t = (char*) malloc(len) ;\n    if (t) {\n        memcpy(t, s, len) ;\n    }\n    return t ;\n}", "target": 0}
{"code": "void WebContentsImpl::OnFrameAttached(\n    int64 parent_frame_id,\n    int64 frame_id,\n    const std::string& frame_name) {\n  FrameTreeNode* parent = FindFrameTreeNodeByID(parent_frame_id);\n  if (!parent)\n    return;\n  FrameTreeNode* node = new FrameTreeNode(frame_id, frame_name);\n  parent->AddChild(node);\n}", "target": 0}
{"code": "cifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (server->tcpStatus == CifsNew)\n\t\t\tcontinue;\n\t\tif (!match_address(server, addr))\n\t\t\tcontinue;\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\t\t++server->srv_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 0}
{"code": "void gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor) {\n\t\treturn;\n\t}\n\tim->open[color] = 1;\n}", "target": 0}
{"code": "void WebProcessProxy::getNetworkProcessConnection(PassRefPtr<Messages::WebProcessProxy::GetNetworkProcessConnection::DelayedReply> reply)\n{\n    m_context->getNetworkProcessConnection(reply);\n}", "target": 0}
{"code": "    template<typename t>\n    void _eval(CImg<t>& output, CImg<T> *const img_output, const char *const expression,\n               const double x, const double y, const double z, const double c,\n               const CImgList<T> *const list_inputs, CImgList<T> *const list_outputs) const {\n      if (!expression || !*expression) { output.assign(1); *output = 0; }\n      if (!expression[1]) switch (*expression) { \n        case 'w' : output.assign(1); *output = (t)_width; break;\n        case 'h' : output.assign(1); *output = (t)_height; break;\n        case 'd' : output.assign(1); *output = (t)_depth; break;\n        case 's' : output.assign(1); *output = (t)_spectrum; break;\n        case 'r' : output.assign(1); *output = (t)_is_shared; break;\n        }\n      _cimg_math_parser mp(expression + (*expression=='>' || *expression=='<' ||\n                                         *expression=='*' || *expression==':'),\"eval\",\n                           *this,img_output,list_inputs,list_outputs,false);\n      output.assign(1,std::max(1U,mp.result_dim));\n      mp(x,y,z,c,output._data);\n      mp.end();", "target": 0}
{"code": "device_local_get_object_path (Device *device)\n{\n  return device->priv->object_path;\n}", "target": 0}
{"code": "void DelegatedFrameHost::MaybeCreateResizeLock() {\n  DCHECK(!resize_lock_);\n  if (!compositor_)\n    return;\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableResizeLock))\n    return;\n  if (!has_frame_)\n    return;\n  if (!client_->DelegatedFrameCanCreateResizeLock())\n    return;\n  gfx::Size desired_size = client_->DelegatedFrameHostDesiredSizeInDIP();\n  if (desired_size.IsEmpty())\n    return;\n  if (desired_size == current_frame_size_in_dip_)\n    return;\n  resize_lock_ = client_->DelegatedFrameHostCreateResizeLock();\n  bool locked = resize_lock_->Lock();\n  DCHECK(locked);\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\tSCTP_DEBUG_PRINTK(\"Timer T2 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\tif (!reply)\n\t\tgoto nomem;\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "static void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}", "target": 0}
{"code": "string DebugString(const GraphDef& instantiated_func_def) {\n  std::vector<const NodeDef*> ptrs;\n  for (const NodeDef& n : instantiated_func_def.node()) {\n    ptrs.push_back(&n);\n  }\n  return Print(ptrs);\n}", "target": 0}
{"code": "node_new_memory(int is_named)\n{\n  Node* node = node_new_enclosure(ENCLOSURE_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    NODE_STATUS_ADD(node, NST_NAMED_GROUP);\n  return node;\n}", "target": 0}
{"code": "zreadonly(i_ctx_t *i_ctx_p)\n{\n    return access_check(i_ctx_p, a_readonly, true);\n}", "target": 0}
{"code": "ExpressionDateToParts::ExpressionDateToParts(ExpressionContext* const expCtx,\n                                             intrusive_ptr<Expression> date,\n                                             intrusive_ptr<Expression> timeZone,\n                                             intrusive_ptr<Expression> iso8601)\n    : Expression(expCtx, {std::move(date), std::move(timeZone), std::move(iso8601)}),\n      _date(_children[0]),\n      _timeZone(_children[1]),\n      _iso8601(_children[2]) {}", "target": 0}
{"code": "double Item::val_real_from_decimal()\n{\n  double result;\n  my_decimal value_buff, *dec_val= val_decimal(&value_buff);\n  if (null_value)\n    return 0.0;\n  my_decimal2double(E_DEC_FATAL_ERROR, dec_val, &result);\n  return result;\n}", "target": 0}
{"code": "static int create_pin(void)\n{\n\tsc_path_t path;\n\tchar buf[80];\n\tif (opt_pin_num != 1 && opt_pin_num != 2) {\n\t\tfprintf(stderr, \"Invalid PIN number. Possible values: 1, 2.\\n\");\n\t\treturn 2;\n\t}\n\tstrcpy(buf, \"3F00\");\n\tif (opt_appdf != NULL)\n\t\tstrlcat(buf, opt_appdf, sizeof buf);\n\tsc_format_path(buf, &path);\n\treturn create_pin_file(&path, opt_pin_num, \"\");\n}", "target": 0}
{"code": "static int decode_close(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_CLOSE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_stateid(xdr, &res->stateid);\n\treturn status;\n}", "target": 0}
{"code": "  static inline float scale_over(float ec, float base)\n  {\n    float s = base * .4;\n    float o = ec - base;\n    return base + sqrt(s * (o + s)) - s;\n  }", "target": 0}
{"code": "static void avrcp_addressed_player_changed(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu)\n{\n\tstruct avrcp_player *player = session->controller->player;\n\tuint16_t id = get_be16(&pdu->params[1]);\n\tif (player != NULL && player->id == id)\n\t\treturn;\n\tplayer = find_ct_player(session, id);\n\tif (player == NULL) {\n\t\tplayer = create_ct_player(session, id);\n\t\tif (player == NULL)\n\t\t\treturn;\n\t}\n\tplayer->addressed = true;\n\tplayer->uid_counter = get_be16(&pdu->params[3]);\n\tset_ct_player(session, player);\n\tif (player->features != NULL)\n\t\treturn;\n\tavrcp_get_media_player_list(session);\n}", "target": 0}
{"code": "bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n    int render_view_id,\n    const GURL& url,\n    const GURL& top_origin_url,\n    const std::string& mime_type,\n    ChromeViewHostMsg_GetPluginInfo_Status* status,\n    WebPluginInfo* plugin,\n    std::string* actual_mime_type) const {\n  bool allow_wildcard = true;\n  std::vector<WebPluginInfo> matching_plugins;\n  std::vector<std::string> mime_types;\n  PluginService::GetInstance()->GetPluginInfoArray(\n      url, mime_type, allow_wildcard, &matching_plugins, &mime_types);\n  content::PluginServiceFilter* filter =\n      PluginService::GetInstance()->GetFilter();\n  bool found = false;\n  for (size_t i = 0; i < matching_plugins.size(); ++i) {\n    bool enabled = !filter || filter->ShouldUsePlugin(render_process_id_,\n                                                      render_view_id,\n                                                      resource_context_,\n                                                      url,\n                                                      top_origin_url,\n                                                      &matching_plugins[i]);\n    if (!found || enabled) {\n      *plugin = matching_plugins[i];\n      *actual_mime_type = mime_types[i];\n      if (enabled) {\n        return true;\n      }\n      found = true;\n    }\n  }\n  if (found)\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kDisabled;\n  else\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kNotFound;\n  return false;\n}", "target": 0}
{"code": "isofile_hd_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n\tconst struct hardlink *h = (const struct hardlink *)n;\n\treturn (strcmp(archive_entry_pathname(h->file_list.first->entry),\n\t\t       (const char *)key));\n}", "target": 0}
{"code": "callbacks_remove_layer_button_clicked (GtkButton *button, gpointer user_data)\n{\n\tgint index = callbacks_get_selected_row_index ();\n\tif ((index >= 0) && (index <= mainProject->last_loaded)) {\n\t\trender_remove_selected_objects_belonging_to_layer (\n\t\t\t\t&screen.selectionInfo,\n\t\t\t\tmainProject->file[index]->image);\n\t\tupdate_selected_object_message (FALSE);\n\t\tgerbv_unload_layer (mainProject, index);\n\t\tcallbacks_update_layer_tree ();\n\t\tindex = MAX(0, index - 1);\n\t\tcallbacks_select_layer_row (index);\n\t\tif (screenRenderInfo.renderType <= GERBV_RENDER_TYPE_GDK_XOR) {\n\t\t\trender_refresh_rendered_image_on_screen ();\n\t\t} else {\n\t\t\trender_recreate_composite_surface (screen.drawing_area);\n\t\t\tcallbacks_force_expose_event_for_screen ();\n\t\t}\n\t}\n}", "target": 0}
{"code": "BiquadFilterNode* BaseAudioContext::createBiquadFilter(\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return BiquadFilterNode::Create(*this, exception_state);\n}", "target": 0}
{"code": "static void ssi_sd_register_types(void)\n{\n    type_register_static(&ssi_sd_info);\n}", "target": 0}
{"code": "static int decode_sao_offset_abs(thread_context* tctx, int bitDepth)\n{\n  logtrace(LogSlice,\"# sao_offset_abs\\n\");\n  int cMax = (1<<(libde265_min(bitDepth,10)-5))-1;\n  int value = decode_CABAC_TU_bypass(&tctx->cabac_decoder, cMax);\n  logtrace(LogSymbols,\"$1 sao_offset_abs=%d\\n\",value);\n  return value;\n}", "target": 0}
{"code": "static int send_pptp_start_ctrl_conn_rply(struct pptp_conn_t *conn, int res_code, int err_code)\n{\n\tstruct pptp_start_ctrl_conn msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RPLY),\n\t\t.version = htons(PPTP_VERSION),\n\t\t.result_code = res_code,\n\t\t.error_code = err_code,\n\t\t.framing_cap = htonl(PPTP_FRAME_ANY),\n\t\t.bearer_cap = htonl(PPTP_BEARER_ANY),\n\t\t.max_channels = htons(1),\n\t\t.firmware_rev = htons(PPTP_FIRMWARE_VERSION),\n\t};\n\tmemset(msg.hostname, 0, sizeof(msg.hostname));\n\tstrcpy((char*)msg.hostname, PPTP_HOSTNAME);\n\tmemset(msg.vendor, 0, sizeof(msg.vendor));\n\tstrcpy((char*)msg.vendor, PPTP_VENDOR);\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Start-Ctrl-Conn-Reply <Version %i> <Result %i> <Error %i> <Framing %x> <Bearer %x> <Max-Chan %i>]\\n\", msg.version, msg.result_code, msg.error_code, ntohl(msg.framing_cap), ntohl(msg.bearer_cap), ntohs(msg.max_channels));\n\treturn post_msg(conn, &msg, sizeof(msg));\n}", "target": 0}
{"code": "static void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_enter_quickack_mode(sk);\n\t\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\n\t\t\t\tend_seq = tp->rcv_nxt;\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\n\t\t}\n\t}\n\ttcp_send_ack(sk);\n}", "target": 0}
{"code": "lexer_compare_identifier_to_chars (const uint8_t *left_p, \n                                   const uint8_t *right_p, \n                                   size_t size) \n{\n  uint8_t utf8_buf[6];\n  do\n  {\n    if (*left_p == *right_p)\n    {\n      left_p++;\n      right_p++;\n      size--;\n      continue;\n    }\n    size_t escape_size;\n    if (*left_p == LIT_CHAR_BACKSLASH)\n    {\n      left_p += 2;\n      lit_code_point_t code_point = lexer_unchecked_hex_to_character (&left_p);\n      escape_size = lit_code_point_to_cesu8_bytes (utf8_buf, code_point);\n    }\n    else if (*left_p >= LIT_UTF8_4_BYTE_MARKER)\n    {\n      lit_four_byte_utf8_char_to_cesu8 (utf8_buf, left_p);\n      escape_size = 3 * 2;\n      left_p += 4;\n    }\n    else\n    {\n      return false;\n    }\n    size -= escape_size;\n    uint8_t *utf8_p = utf8_buf;\n    do\n    {\n      if (*right_p++ != *utf8_p++)\n      {\n        return false;\n      }\n    } while (--escape_size > 0);\n  } while (size > 0);\n  return true;\n} ", "target": 0}
{"code": "update_info_mount_state (Device *device)\n{\n  MountMonitor *monitor;\n  GList *mounts;\n  gboolean was_mounted;\n  mounts = NULL;\n  if (device->priv->job_in_progress && g_strcmp0 (device->priv->job_id, \"FilesystemMount\") == 0)\n    goto out;\n  monitor = daemon_local_get_mount_monitor (device->priv->daemon);\n  mounts = mount_monitor_get_mounts_for_dev (monitor, device->priv->dev);\n  was_mounted = device->priv->device_is_mounted;\n  if (mounts != NULL)\n    {\n      GList *l;\n      guint n;\n      gchar **mount_paths;\n      mount_paths = g_new0 (gchar *, g_list_length (mounts) + 1);\n      for (l = mounts, n = 0; l != NULL; l = l->next, n++)\n        {\n          mount_paths[n] = g_strdup (mount_get_mount_path (MOUNT (l->data)));\n        }\n      device_set_device_is_mounted (device, TRUE);\n      device_set_device_mount_paths (device, mount_paths);\n      if (!was_mounted)\n        {\n          uid_t mounted_by_uid;\n          if (!mount_file_has_device (device->priv->device_file, &mounted_by_uid, NULL))\n            mounted_by_uid = 0;\n          device_set_device_mounted_by_uid (device, mounted_by_uid);\n        }\n      g_strfreev (mount_paths);\n    }\n  else\n    {\n      gboolean remove_dir_on_unmount;\n      gchar *old_mount_path;\n      old_mount_path = NULL;\n      if (device->priv->device_mount_paths->len > 0)\n        old_mount_path = g_strdup (((gchar **) device->priv->device_mount_paths->pdata)[0]);\n      device_set_device_is_mounted (device, FALSE);\n      device_set_device_mount_paths (device, NULL);\n      device_set_device_mounted_by_uid (device, 0);\n      remove_dir_on_unmount = FALSE;\n      if (was_mounted && mount_file_has_device (device->priv->device_file, NULL, &remove_dir_on_unmount))\n        {\n          mount_file_remove (device->priv->device_file, old_mount_path);\n          if (remove_dir_on_unmount)\n            {\n              if (g_rmdir (old_mount_path) != 0)\n                {\n                  g_warning (\"Error removing dir '%s' on unmount: %m\", old_mount_path);\n                }\n            }\n        }\n      g_free (old_mount_path);\n    }\n out:\n  g_list_foreach (mounts, (GFunc) g_object_unref, NULL);\n  g_list_free (mounts);\n  return TRUE;\n}", "target": 0}
{"code": "static inline void __nf_copy(struct sk_buff *dst, const struct sk_buff *src)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tdst->nfct = src->nfct;\n\tnf_conntrack_get(src->nfct);\n\tdst->nfctinfo = src->nfctinfo;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tdst->nfct_reasm = src->nfct_reasm;\n\tnf_conntrack_get_reasm(src->nfct_reasm);\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tdst->nf_bridge  = src->nf_bridge;\n\tnf_bridge_get(src->nf_bridge);\n#endif\n}", "target": 0}
{"code": "node_new_option(OnigOptionType option)\n{\n  Node* node = node_new_enclosure(ENCLOSURE_OPTION);\n  CHECK_NULL_RETURN(node);\n  ENCLOSURE_(node)->o.options = option;\n  return node;\n}", "target": 0}
{"code": "static __init int vdso_fixup_features(struct lib32_elfinfo *v32,\n\t\t\t\t      struct lib64_elfinfo *v64)\n{\n\tvoid *start32;\n\tunsigned long size32;\n#ifdef CONFIG_PPC64\n\tvoid *start64;\n\tunsigned long size64;\n\tstart64 = find_section64(v64->hdr, \"__ftr_fixup\", &size64);\n\tif (start64)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start64, start64 + size64);\n\tstart64 = find_section64(v64->hdr, \"__fw_ftr_fixup\", &size64);\n\tif (start64)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start64, start64 + size64);\n#endif \n\tstart32 = find_section32(v32->hdr, \"__ftr_fixup\", &size32);\n\tif (start32)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start32, start32 + size32);\n#ifdef CONFIG_PPC64\n\tstart32 = find_section32(v32->hdr, \"__fw_ftr_fixup\", &size32);\n\tif (start32)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start32, start32 + size32);\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "static const struct content_encoding *find_encoding(const char *name,\n                                                    size_t len)\n{\n  const struct content_encoding * const *cep;\n  for(cep = encodings; *cep; cep++) {\n    const struct content_encoding *ce = *cep;\n    if((strncasecompare(name, ce->name, len) && !ce->name[len]) ||\n       (ce->alias && strncasecompare(name, ce->alias, len) && !ce->alias[len]))\n      return ce;\n  }\n  return NULL;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::RevokeReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->RevokeReadRawCookies();\n}", "target": 0}
{"code": "  base::Time IncrementMockTime() {\n    ++mock_time_counter_;\n    return base::Time::FromDoubleT(mock_time_counter_ * 10.0);\n  }", "target": 0}
{"code": "DECLAREcpFunc(cpSeparateTiles2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "do_async_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tenum ctx_state prev_state;\n\tswitch (kvm_read_and_reset_pf_reason()) {\n\tdefault:\n\t\ttrace_do_page_fault(regs, error_code);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tprev_state = exception_enter();\n\t\texit_idle();\n\t\tkvm_async_pf_task_wait((u32)read_cr2());\n\t\texception_exit(prev_state);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\trcu_irq_enter();\n\t\texit_idle();\n\t\tkvm_async_pf_task_wake((u32)read_cr2());\n\t\trcu_irq_exit();\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static void compat_release_buffer(void *opaque, uint8_t *data)\n{\n    AVBufferRef *buf = opaque;\n    av_buffer_unref(&buf);\n}", "target": 0}
{"code": "yang_fill_extcomplex_uint8(struct lys_ext_instance_complex *ext, char *parent_name, char *node_name,\n                           LY_STMT stmt, uint8_t value)\n{\n    struct ly_ctx *ctx = ext->module->ctx;\n    uint8_t *val, **pp = NULL, *reallocated;\n    struct lyext_substmt *info;\n    int i = 0;\n    val = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!val) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node_name, parent_name);\n        return EXIT_FAILURE;\n    }\n    if (stmt == LY_STMT_DIGITS) {\n        if (info->cardinality < LY_STMT_CARD_SOME && *val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            pp = (uint8_t**)val;\n            if (!(*pp)) {\n                *pp = calloc(2, sizeof(uint8_t)); \n                LY_CHECK_ERR_RETURN(!*pp, LOGMEM(ctx), EXIT_FAILURE);\n            } else {\n                for (i = 0; (*pp)[i]; i++);\n            }\n            val = &(*pp)[i];\n        }\n        *val = value;\n        if (i) {\n            reallocated = realloc(*pp, (i + 2) * sizeof *val);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n            *pp = reallocated;\n            (*pp)[i + 1] = 0;\n        }\n    } else {\n        if (*val) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node_name, parent_name);\n            return EXIT_FAILURE;\n        }\n        if (stmt == LY_STMT_REQINSTANCE) {\n            *val = (value == 1) ? 1 : 2;\n        } else if (stmt == LY_STMT_MODIFIER) {\n            *val =  1;\n        } else {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "init_lockup_state(lookup_state_t *state,\n                  node_t *root,\n                  const char *path)\n{\n  apr_size_t len = strlen(path);\n  if (   (len > state->parent_path->len)\n      && state->parent_path->len\n      && (path[state->parent_path->len] == '/')\n      && !memcmp(path, state->parent_path->data, state->parent_path->len))\n    {\n      state->rights = state->parent_rights;\n      return path + state->parent_path->len;\n    }\n  state->rights = root->rights;\n  state->parent_rights = root->rights;\n  apr_array_clear(state->next);\n  apr_array_clear(state->current);\n  APR_ARRAY_PUSH(state->current, node_t *) = root;\n  if (root->pattern_sub_nodes && root->pattern_sub_nodes->any_var)\n   {\n      node_t *node = root->pattern_sub_nodes->any_var;\n      combine_access(&state->rights, &node->rights);\n      combine_right_limits(&state->rights, &node->rights);\n      APR_ARRAY_PUSH(state->current, node_t *) = node;\n   }\n  svn_stringbuf_setempty(state->parent_path);\n  svn_stringbuf_setempty(state->scratch_pad);\n  return path;\n}", "target": 0}
{"code": "static bool vmx_rdrand_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDRAND;\n}", "target": 0}
{"code": "buf_get_oldest_chunk_timestamp(const buf_t *buf, uint32_t now)\n{\n  if (buf->head) {\n    return now - buf->head->inserted_time;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": "void JSArray::setLength(unsigned newLength)\n{\n    ArrayStorage* storage = m_storage;\n#if CHECK_ARRAY_CONSISTENCY\n    if (!storage->m_inCompactInitialization)\n        checkConsistency();\n    else\n        storage->m_inCompactInitialization = false;\n#endif\n    unsigned length = storage->m_length;\n    if (newLength < length) {\n        unsigned usedVectorLength = min(length, m_vectorLength);\n        for (unsigned i = newLength; i < usedVectorLength; ++i) {\n            WriteBarrier<Unknown>& valueSlot = storage->m_vector[i];\n            bool hadValue = valueSlot;\n            valueSlot.clear();\n            storage->m_numValuesInVector -= hadValue;\n        }\n        if (SparseArrayValueMap* map = storage->m_sparseValueMap) {\n            SparseArrayValueMap copy = *map;\n            SparseArrayValueMap::iterator end = copy.end();\n            for (SparseArrayValueMap::iterator it = copy.begin(); it != end; ++it) {\n                if (it->first >= newLength)\n                    map->remove(it->first);\n            }\n            if (map->isEmpty()) {\n                delete map;\n                storage->m_sparseValueMap = 0;\n            }\n        }\n    }\n    storage->m_length = newLength;\n    checkConsistency();\n}", "target": 0}
{"code": "static int bnx2x_get_phys_port_id(struct net_device *netdev,\n\t\t\t\t  struct netdev_phys_item_id *ppid)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tif (!(bp->flags & HAS_PHYS_PORT_ID))\n\t\treturn -EOPNOTSUPP;\n\tppid->id_len = sizeof(bp->phys_port_id);\n\tmemcpy(ppid->id, bp->phys_port_id, ppid->id_len);\n\treturn 0;\n}", "target": 0}
{"code": "static int __init init_script_binfmt(void)\n{\n\treturn register_binfmt(&script_format);\n}", "target": 0}
{"code": "archive_read_format_rar_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct rar * rar = (struct rar *)_a->format->data;\n\t\tif (rar) {\n\t\t\treturn rar->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}", "target": 0}
{"code": "static int sqfs_read_entry(struct squashfs_directory_entry **dest, void *src)\n{\n\tstruct squashfs_directory_entry *tmp;\n\tu16 sz;\n\ttmp = src;\n\tsz = get_unaligned_le16(src + sizeof(*tmp) - sizeof(u16));\n\t*dest = malloc(sizeof(*tmp) + sz + 2);\n\tif (!*dest)\n\t\treturn -ENOMEM;\n\tmemcpy(*dest, src, sizeof(*tmp) + sz + 1);\n\t(*dest)->name[sz + 1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "void fz_cmm_drop_instance(fz_context *ctx)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->drop_instance(ctx->cmm_instance);\n}", "target": 0}
{"code": "passIsRightParen ()\n{\n  pass_Codes passCode = passGetScriptToken ();\n  if (passCode != pass_rightParen)\n    {\n      compileError (passNested, \"')' expected\");\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "      interp_canonicalize_mapping() {\n    return &interp_canonicalize_mapping_;\n  }", "target": 0}
{"code": "  explicit ExecutionAccess(Isolate* isolate) : isolate_(isolate) {\n    Lock(isolate);\n  }", "target": 0}
{"code": "void Document::WillChangeFrameOwnerProperties(int margin_width,\n                                              int margin_height,\n                                              ScrollbarMode scrolling_mode,\n                                              bool is_display_none) {\n  DCHECK(GetFrame() && GetFrame()->Owner());\n  FrameOwner* owner = GetFrame()->Owner();\n  if (RuntimeEnabledFeatures::DisplayNoneIFrameCreatesNoLayoutObjectEnabled()) {\n    if (documentElement()) {\n      if (is_display_none != owner->IsDisplayNone())\n        documentElement()->LazyReattachIfAttached();\n    }\n  }\n  if (!body())\n    return;\n  if (margin_width != owner->MarginWidth())\n    body()->SetIntegralAttribute(marginwidthAttr, margin_width);\n  if (margin_height != owner->MarginHeight())\n    body()->SetIntegralAttribute(marginheightAttr, margin_height);\n  if (scrolling_mode != owner->ScrollingMode() && View())\n    View()->SetNeedsLayout();\n}", "target": 0}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "bool ConnectDialogEdit::updateFromClipboard() {\n\tdelete m_si;\n\tm_si = ServerItem::fromMimeData(QApplication::clipboard()->mimeData(), false, NULL, true);\n\tbool hasServerData = m_si != NULL;\n\tif (hasServerData) {\n\t\tshowNotice(tr(\"You have an URL in your clipboard.\\nDo you want to fill the dialog with this data?\\nHost: %1 Port: %2\").arg(m_si->qsHostname).arg(m_si->usPort));\n\t\treturn true;\n\t} else {\n\t\tqwInlineNotice->hide();\n\t\tadjustSize();\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t  access | PFERR_FETCH_MASK,\n\t\t\t\t\t  exception);\n}", "target": 0}
{"code": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "bool Item_ref::send(Protocol *prot, String *tmp)\n{\n  if (result_field)\n    return prot->store(result_field);\n  return (*ref)->send(prot, tmp);\n}", "target": 0}
{"code": "GF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n    }\n    }\n}", "target": 0}
{"code": "    CImg<T> get_max(const T& val) const {\n      return (+*this).max(val);", "target": 0}
{"code": "static int php_snmp_write_exceptions_enabled(php_snmp_object *snmp_object, zval *newval)\n{\n\tzval ztmp;\n\tint ret = SUCCESS;\n\tif (Z_TYPE_P(newval) != IS_LONG) {\n\t\tZVAL_COPY(&ztmp, newval);\n\t\tconvert_to_long(&ztmp);\n\t\tnewval = &ztmp;\n\t}\n\tsnmp_object->exceptions_enabled = Z_LVAL_P(newval);\n\tif (newval == &ztmp) {\n\t\tzval_ptr_dtor(newval);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static NTSTATUS ldapsrv_expired(struct ldapsrv_call *call)\n{\n\tstruct ldapsrv_reply *reply = NULL;\n\tstruct ldap_ExtendedResponse *r = NULL;\n\tDBG_DEBUG(\"Sending connection expired message\\n\");\n\treply = ldapsrv_init_reply(call, LDAP_TAG_ExtendedResponse);\n\tif (reply == NULL) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\treply->msg->messageid = 0;\n\tr = &reply->msg->r.ExtendedResponse;\n\tr->response.resultcode = LDB_ERR_UNAVAILABLE;\n\tr->response.errormessage = \"The server has timed out this connection\";\n\tr->oid = \"1.3.6.1.4.1.1466.20036\"; \n\tldapsrv_queue_reply(call, reply);\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "SiteInstance* WebContentsImpl::GetPendingSiteInstance() const {\n  RenderViewHost* dest_rvh = render_manager_.pending_render_view_host() ?\n      render_manager_.pending_render_view_host() :\n      render_manager_.current_host();\n  return dest_rvh->GetSiteInstance();\n}", "target": 0}
{"code": "void PpapiPluginProcessHost::OnChannelConnected(int32 peer_pid) {\n  Send(new PpapiMsg_LoadPlugin(plugin_path_));\n  for (size_t i = 0; i < pending_requests_.size(); i++)\n    RequestPluginChannel(pending_requests_[i]);\n  pending_requests_.clear();\n}", "target": 0}
{"code": "void gdImageInterlace (gdImagePtr im, int interlaceArg)\n{\n\tim->interlace = interlaceArg;\n}", "target": 0}
{"code": "static const char *set_limit_req_body(cmd_parms *cmd, void *conf_,\n                                      const char *arg)\n{\n    core_dir_config *conf = conf_;\n    char *errp;\n    if (APR_SUCCESS != apr_strtoff(&conf->limit_req_body, arg, &errp, 10)) {\n        return \"LimitRequestBody argument is not parsable.\";\n    }\n    if (*errp || conf->limit_req_body < 0) {\n        return \"LimitRequestBody requires a non-negative integer.\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "    uint32_t PreviewImage::size() const\n    {\n        return size_;\n    }", "target": 0}
{"code": "static inline void unmap_mapping_range_list(struct list_head *head,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\nrestart:\n\tlist_for_each_entry(vma, head, shared.vm_set.list) {\n\t\tif (vma->vm_truncate_count == details->truncate_count)\n\t\t\tcontinue;\n\t\tdetails->nonlinear_vma = vma;\n\t\tif (unmap_mapping_range_vma(vma, vma->vm_start,\n\t\t\t\t\tvma->vm_end, details) < 0)\n\t\t\tgoto restart;\n\t}\n}", "target": 0}
{"code": "int LuaSettings::create_object(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tbool write_allowed = true;\n\tconst char* filename = luaL_checkstring(L, 1);\n\tCHECK_SECURE_PATH_POSSIBLE_WRITE(L, filename, &write_allowed);\n\tLuaSettings* o = new LuaSettings(filename, write_allowed);\n\t*(void **)(lua_newuserdata(L, sizeof(void *))) = o;\n\tluaL_getmetatable(L, className);\n\tlua_setmetatable(L, -2);\n\treturn 1;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NonTopLevelIndexedNegationMinQuery) {\n    addIndex(BSON(\"state\" << 1));\n    addIndex(BSON(\"is_draft\" << 1));\n    addIndex(BSON(\"published_date\" << 1));\n    BSONObj queryObj = fromjson(\"{$or:[{state:1, is_draft:1}, {published_date:{$ne: 1}}]}\");\n    runQuery(queryObj);\n}", "target": 0}
{"code": "   void DidGetUsageAndQuota(QuotaStatusCode status, int64 usage, int64 quota) {\n     quota_status_ = status;\n     usage_ = usage;\n    quota_ = quota;\n  }", "target": 0}
{"code": "static void tipc_node_delete(struct tipc_node *node)\n{\n\ttrace_tipc_node_delete(node, true, \" \");\n\ttipc_node_delete_from_list(node);\n\tdel_timer_sync(&node->timer);\n\ttipc_node_put(node);\n}", "target": 0}
{"code": "static int diskstats_show(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *gp = v;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *hd;\n\tchar buf[BDEVNAME_SIZE];\n\tint cpu;\n\tdisk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);\n\twhile ((hd = disk_part_iter_next(&piter))) {\n\t\tcpu = part_stat_lock();\n\t\tpart_round_stats(cpu, hd);\n\t\tpart_stat_unlock();\n\t\tseq_printf(seqf, \"%4d %7d %s %lu %lu %lu \"\n\t\t\t   \"%u %lu %lu %lu %u %u %u %u\\n\",\n\t\t\t   MAJOR(part_devt(hd)), MINOR(part_devt(hd)),\n\t\t\t   disk_name(gp, hd->partno, buf),\n\t\t\t   part_stat_read(hd, ios[READ]),\n\t\t\t   part_stat_read(hd, merges[READ]),\n\t\t\t   part_stat_read(hd, sectors[READ]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[READ])),\n\t\t\t   part_stat_read(hd, ios[WRITE]),\n\t\t\t   part_stat_read(hd, merges[WRITE]),\n\t\t\t   part_stat_read(hd, sectors[WRITE]),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),\n\t\t\t   part_in_flight(hd),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, io_ticks)),\n\t\t\t   jiffies_to_msecs(part_stat_read(hd, time_in_queue))\n\t\t\t);\n\t}\n\tdisk_part_iter_exit(&piter);\n\treturn 0;\n}", "target": 0}
{"code": "MATCHER_P(MapEqValue, rhs, \"\") {\n  const ProtobufWkt::Struct& obj = arg;\n  EXPECT_TRUE(!rhs.empty());\n  for (auto const& entry : rhs) {\n    EXPECT_TRUE(TestUtility::protoEqual(obj.fields().at(entry.first), entry.second));\n  }\n  return true;\n}", "target": 0}
{"code": "static void ldapsrv_call_wait_done(struct tevent_req *subreq)\n{\n\tstruct ldapsrv_call *call =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct ldapsrv_call);\n\tstruct ldapsrv_connection *conn = call->conn;\n\tNTSTATUS status;\n\tconn->active_call = NULL;\n\tstatus = call->wait_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tconst char *reason;\n\t\treason = talloc_asprintf(call, \"ldapsrv_call_wait_done: \"\n\t\t\t\t\t \"call->wait_recv() - %s\",\n\t\t\t\t\t nt_errstr(status));\n\t\tif (reason == NULL) {\n\t\t\treason = nt_errstr(status);\n\t\t}\n\t\tldapsrv_terminate_connection(conn, reason);\n\t\treturn;\n\t}\n\tldapsrv_call_writev_start(call);\n}", "target": 0}
{"code": "get_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(*bufferptr++,)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)],)\n  }\n  return 1;\n}", "target": 0}
{"code": "do_exmode(\n    int\t\timproved)\t    \n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = NORMAL;\n    trigger_modechanged();\n    if (global_busy)\n\treturn;\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    \n    ++no_wait_return;\t\t    \n#ifdef FEAT_GUI\n    ++hold_gui_events;\n#endif\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_emptybuf));\n\t    else\n\t\temsg(_(\"E501: At end-of-file\"));\n\t}\n    }\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    --RedrawingDisabled;\n    --no_wait_return;\n    update_screen(CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}", "target": 0}
{"code": "SPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"code": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (!parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM && next == end && !parser->m_parsingStatus.finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 0}
{"code": "void WebProcessProxy::getLaunchOptions(ProcessLauncher::LaunchOptions& launchOptions)\n{\n    launchOptions.processType = ProcessLauncher::WebProcess;\n    platformGetLaunchOptions(launchOptions);\n}", "target": 0}
{"code": "void PrintWebViewHelper::GetPageSizeAndContentAreaFromPageLayout(\n    const PageSizeMargins& page_layout_in_points,\n    gfx::Size* page_size,\n    gfx::Rect* content_area) {\n  *page_size = gfx::Size(\n      page_layout_in_points.content_width + page_layout_in_points.margin_right +\n          page_layout_in_points.margin_left,\n      page_layout_in_points.content_height + page_layout_in_points.margin_top +\n          page_layout_in_points.margin_bottom);\n  *content_area = gfx::Rect(page_layout_in_points.margin_left,\n                            page_layout_in_points.margin_top,\n                            page_layout_in_points.content_width,\n                            page_layout_in_points.content_height);\n}", "target": 0}
{"code": "  static inline float T(void) throw() { return 1.4f; }", "target": 0}
{"code": "TEST(LteOp, MatchesElement) {\n    BSONObj operand = BSON(\"$lte\" << 5);\n    BSONObj match = BSON(\"a\" << 4.5);\n    BSONObj equalMatch = BSON(\"a\" << 5);\n    BSONObj notMatch = BSON(\"a\" << 6);\n    BSONObj notMatchWrongType = BSON(\"a\"\n                                     << \"foo\");\n    LTEMatchExpression lte(\"\", operand[\"$lte\"]);\n    ASSERT(lte.matchesSingleElement(match.firstElement()));\n    ASSERT(lte.matchesSingleElement(equalMatch.firstElement()));\n    ASSERT(!lte.matchesSingleElement(notMatch.firstElement()));\n    ASSERT(!lte.matchesSingleElement(notMatchWrongType.firstElement()));\n}", "target": 0}
{"code": "decompileSTRINGCONCAT(int n, SWF_ACTION *actions, int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"concat\",\"(\", 2,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "irc_nick_free_all (struct t_irc_server *server, struct t_irc_channel *channel)\n{\n    if (!channel)\n        return;\n    while (channel->nicks)\n    {\n        irc_nick_free (server, channel, channel->nicks);\n    }\n    weechat_nicklist_remove_all (channel->buffer);\n    channel->nicks_count = 0;\n}", "target": 0}
{"code": "static PHP_FUNCTION(libxml_get_errors)\n{\n\txmlErrorPtr error;\n\tif (array_init(return_value) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (LIBXML(error_list)) {\n\t\terror = zend_llist_get_first(LIBXML(error_list));\n\t\twhile (error != NULL) {\n\t\t\tzval *z_error;\n\t\t\tMAKE_STD_ZVAL(z_error);\n\t\t\tobject_init_ex(z_error, libxmlerror_class_entry);\n\t\t\tadd_property_long(z_error, \"level\", error->level);\n\t\t\tadd_property_long(z_error, \"code\", error->code);\n\t\t\tadd_property_long(z_error, \"column\", error->int2);\n\t\t\tif (error->message) {\n\t\t\t\tadd_property_string(z_error, \"message\", error->message, 1);\n\t\t\t} else {\n\t\t\t\tadd_property_stringl(z_error, \"message\", \"\", 0, 1);\n\t\t\t}\n\t\t\tif (error->file) {\n\t\t\t\tadd_property_string(z_error, \"file\", error->file, 1);\n\t\t\t} else {\n\t\t\t\tadd_property_stringl(z_error, \"file\", \"\", 0, 1);\n\t\t\t}\n\t\t\tadd_property_long(z_error, \"line\", error->line);\n\t\t\tadd_next_index_zval(return_value, z_error);\n\t\t\terror = zend_llist_get_next(LIBXML(error_list));\n\t\t}\n\t}\n}", "target": 0}
{"code": "void sock_rfree(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tskb_truesize_check(skb);\n\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n\tsk_mem_uncharge(skb->sk, skb->truesize);\n}", "target": 0}
{"code": "    void _set_colormap(Colormap& _colormap, const unsigned int dim) {\n      XColor *const colormap = new XColor[256];\n      switch (dim) {\n      case 1 : { \n        for (unsigned int index = 0; index<256; ++index) {\n          colormap[index].pixel = index;\n          colormap[index].red = colormap[index].green = colormap[index].blue = (unsigned short)(index<<8);\n          colormap[index].flags = DoRed | DoGreen | DoBlue;\n        }\n      } break;\n      case 2 : { \n        for (unsigned int index = 0, r = 8; r<256; r+=16)\n          for (unsigned int g = 8; g<256; g+=16) {\n            colormap[index].pixel = index;\n            colormap[index].red = colormap[index].blue = (unsigned short)(r<<8);\n            colormap[index].green = (unsigned short)(g<<8);\n            colormap[index++].flags = DoRed | DoGreen | DoBlue;\n          }\n      } break;\n      default : { \n        for (unsigned int index = 0, r = 16; r<256; r+=32)\n          for (unsigned int g = 16; g<256; g+=32)\n            for (unsigned int b = 32; b<256; b+=64) {\n              colormap[index].pixel = index;\n              colormap[index].red = (unsigned short)(r<<8);\n              colormap[index].green = (unsigned short)(g<<8);\n              colormap[index].blue = (unsigned short)(b<<8);\n              colormap[index++].flags = DoRed | DoGreen | DoBlue;\n            }\n      }\n      }\n      XStoreColors(cimg::X11_attr().display,_colormap,colormap,256);\n      delete[] colormap;", "target": 0}
{"code": "static int decode_lock(struct xdr_stream *xdr, struct nfs_lock_res *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LOCK);\n\tif (status == -EIO)\n\t\tgoto out;\n\tif (status == 0) {\n\t\tstatus = decode_stateid(xdr, &res->stateid);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t} else if (status == -NFS4ERR_DENIED)\n\t\tstatus = decode_lock_denied(xdr, NULL);\n\tif (res->open_seqid != NULL)\n\t\tnfs_increment_open_seqid(status, res->open_seqid);\n\tnfs_increment_lock_seqid(status, res->lock_seqid);\nout:\n\treturn status;\n}", "target": 0}
{"code": "void ConnectDialog::on_qaFavoriteRemove_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType != ServerItem::FavoriteType))\n\t\treturn;\n\tstopDns(si);\n\tqlItems.removeAll(si);\n\tdelete si;\n}", "target": 0}
{"code": "static void m_stop(struct seq_file *seq, void *v)\n{\n\treturn;\n}", "target": 0}
{"code": "sort_version_list(smartlist_t *versions, int remove_duplicates)\n{\n  smartlist_sort(versions, compare_tor_version_str_ptr_);\n  if (remove_duplicates)\n    smartlist_uniq(versions, compare_tor_version_str_ptr_, tor_free_);\n}", "target": 0}
{"code": "double Item_string::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  return double_from_string_with_check(str_value.charset(),\n                                       str_value.ptr(), \n                                       str_value.ptr() +\n                                       str_value.length());\n}", "target": 0}
{"code": "void _WM_do_patch(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (!mdi->channel[ch].isdrum) {\n        mdi->channel[ch].patch = _WM_get_patch_data(mdi,\n                                                ((mdi->channel[ch].bank << 8) | data->data.value));\n    } else {\n        mdi->channel[ch].bank = data->data.value;\n    }\n}", "target": 0}
{"code": "bool RenderView::allowScript(WebFrame* frame, bool enabled_per_settings) {\n  if (enabled_per_settings &&\n      AllowContentType(CONTENT_SETTINGS_TYPE_JAVASCRIPT))\n    return true;\n  if (IsWhitelistedForContentSettings(frame))\n    return true;\n  return false;  \n}", "target": 0}
{"code": "static inline int pageblock_free(struct page *page)\n{\n\treturn PageBuddy(page) && page_order(page) >= pageblock_order;\n}", "target": 0}
{"code": "join_read_next(READ_RECORD *info)\n{\n  int error;\n  if ((error= info->table->file->ha_index_next(info->record)))\n    return report_error(info->table, error);\n  return 0;\n}", "target": 0}
{"code": "inline int32_t byteswap(int32_t value) { return _af_byteswap_int32(value); }", "target": 0}
{"code": "static __printf(3, 4) void slab_err(struct kmem_cache *s, struct page *page,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[100];\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tslab_bug(s, \"%s\", buf);\n\tprint_page_info(page);\n\tdump_stack();\n}", "target": 0}
{"code": "int sock_no_mmap(struct file *file, struct socket *sock, struct vm_area_struct *vma)\n{\n\treturn -ENODEV;\n}", "target": 0}
{"code": "vte_sequence_handler_application_keypad (VteTerminal *terminal, GValueArray *params)\n{\n\t_vte_debug_print(VTE_DEBUG_KEYBOARD,\n\t\t\t\"Entering application keypad mode.\\n\");\n\tterminal->pvt->keypad_mode = VTE_KEYMODE_APPLICATION;\n}", "target": 0}
{"code": "const char *cli_read_statistics(MYSQL *mysql)\n{\n  mysql->net.read_pos[mysql->packet_length]=0;\t\n  if (!mysql->net.read_pos[0])\n  {\n    set_mysql_error(mysql, CR_WRONG_HOST_INFO, unknown_sqlstate);\n    return mysql->net.last_error;\n  }\n  return (char*) mysql->net.read_pos;\n}", "target": 0}
{"code": "MOCK_IMPL(const char *,\ndirvote_get_pending_detached_signatures, (void))\n{\n  return pending_consensus_signatures;\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, Denied) {\n  useAccessLog(\"%RESPONSE_CODE_DETAILS%\");\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"403\", response->headers().getStatusValue());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              testing::HasSubstr(\"rbac_access_denied_matched_policy[none]\"));\n}", "target": 0}
{"code": "void lodepng_state_init(LodePNGState* state)\n{\n#ifdef LODEPNG_COMPILE_DECODER\n  lodepng_decoder_settings_init(&state->decoder);\n#endif \n#ifdef LODEPNG_COMPILE_ENCODER\n  lodepng_encoder_settings_init(&state->encoder);\n#endif \n  lodepng_color_mode_init(&state->info_raw);\n  lodepng_info_init(&state->info_png);\n  state->error = 1;\n}", "target": 0}
{"code": "static int ssl_check_record_type( uint8_t record_type )\n{\n    if( record_type != MBEDTLS_SSL_MSG_HANDSHAKE &&\n        record_type != MBEDTLS_SSL_MSG_ALERT &&\n        record_type != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&\n        record_type != MBEDTLS_SSL_MSG_APPLICATION_DATA )\n    {\n        return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "static void addrconf_add_mroute(struct net_device *dev)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = RT6_TABLE_LOCAL,\n\t\t.fc_metric = IP6_RT_PRIO_ADDRCONF,\n\t\t.fc_ifindex = dev->ifindex,\n\t\t.fc_dst_len = 8,\n\t\t.fc_flags = RTF_UP,\n\t\t.fc_nlinfo.nl_net = dev_net(dev),\n\t};\n\tipv6_addr_set(&cfg.fc_dst, htonl(0xFF000000), 0, 0, 0);\n\tip6_route_add(&cfg);\n}", "target": 0}
{"code": "void stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "seamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\twarning(\"SeamlessRDP: Invalid request:%s\\n\", line);\n\t}\n\treturn True;\n}", "target": 0}
{"code": "static int acl_childClasses(struct ldb_module *module,\n\t\t\t    const struct dsdb_schema *schema,\n\t\t\t    struct ldb_message *sd_msg,\n\t\t\t    struct ldb_message *msg,\n\t\t\t    const char *attrName)\n{\n\tstruct ldb_message_element *oc_el;\n\tstruct ldb_message_element *allowedClasses;\n\tconst struct dsdb_class *sclass;\n\tunsigned int i, j;\n\tint ret;\n\tif (schema == NULL) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(module), \"cannot add childClassesEffective to %s because no schema is loaded\", ldb_dn_get_linearized(msg->dn));\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tldb_msg_remove_attr(msg, attrName);\n\tret = ldb_msg_add_empty(msg, attrName, 0, &allowedClasses);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\toc_el = ldb_msg_find_element(sd_msg, \"objectClass\");\n\tfor (i=0; oc_el && i < oc_el->num_values; i++) {\n\t\tsclass = dsdb_class_by_lDAPDisplayName_ldb_val(schema, &oc_el->values[i]);\n\t\tif (!sclass) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; sclass->possibleInferiors && sclass->possibleInferiors[j]; j++) {\n\t\t\tldb_msg_add_string(msg, attrName, sclass->possibleInferiors[j]);\n\t\t}\n\t}\n\tif (allowedClasses->num_values > 1) {\n\t\tTYPESAFE_QSORT(allowedClasses->values, allowedClasses->num_values, data_blob_cmp);\n\t\tfor (i=1 ; i < allowedClasses->num_values; i++) {\n\t\t\tstruct ldb_val *val1 = &allowedClasses->values[i-1];\n\t\t\tstruct ldb_val *val2 = &allowedClasses->values[i];\n\t\t\tif (data_blob_cmp(val1, val2) == 0) {\n\t\t\t\tmemmove(val1, val2, (allowedClasses->num_values - i) * sizeof(struct ldb_val));\n\t\t\t\tallowedClasses->num_values--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "static int tls1_alpn_handle_client_hello(SSL *s, const unsigned char *data,\n\t\t\t\t\t unsigned data_len, int *al)\n\t{\n\tunsigned i;\n\tunsigned proto_len;\n\tconst unsigned char *selected;\n\tunsigned char selected_len;\n\tint r;\n\tif (s->ctx->alpn_select_cb == NULL)\n\t\treturn 0;\n\tif (data_len < 2)\n\t\tgoto parse_error;\n\ti = ((unsigned) data[0]) << 8 |\n\t    ((unsigned) data[1]);\n\tdata_len -= 2;\n\tdata += 2;\n\tif (data_len != i)\n\t\tgoto parse_error;\n\tif (data_len < 2)\n\t\tgoto parse_error;\n\tfor (i = 0; i < data_len;)\n\t\t{\n\t\tproto_len = data[i];\n\t\ti++;\n\t\tif (proto_len == 0)\n\t\t\tgoto parse_error;\n\t\tif (i + proto_len < i || i + proto_len > data_len)\n\t\t\tgoto parse_error;\n\t\ti += proto_len;\n\t\t}\n\tr = s->ctx->alpn_select_cb(s, &selected, &selected_len, data, data_len,\n\t\t\t\t   s->ctx->alpn_select_cb_arg);\n\tif (r == SSL_TLSEXT_ERR_OK) {\n\t\tif (s->s3->alpn_selected)\n\t\t\tOPENSSL_free(s->s3->alpn_selected);\n\t\ts->s3->alpn_selected = OPENSSL_malloc(selected_len);\n\t\tif (!s->s3->alpn_selected)\n\t\t\t{\n\t\t\t*al = SSL_AD_INTERNAL_ERROR;\n\t\t\treturn -1;\n\t\t\t}\n\t\tmemcpy(s->s3->alpn_selected, selected, selected_len);\n\t\ts->s3->alpn_selected_len = selected_len;\n\t}\n\treturn 0;\nparse_error:\n\t*al = SSL_AD_DECODE_ERROR;\n\treturn -1;\n\t}", "target": 0}
{"code": "sigalrm_handler(int sig)\n{\nsig = sig;            \nsigalrm_seen = TRUE;\n}", "target": 0}
{"code": "static uint16_t nvme_flush(NvmeCtrl *n, NvmeRequest *req)\n{\n    NvmeFlushAIOCB *iocb;\n    uint32_t nsid = le32_to_cpu(req->cmd.nsid);\n    uint16_t status;\n    iocb = qemu_aio_get(&nvme_flush_aiocb_info, NULL, nvme_misc_cb, req);\n    iocb->req = req;\n    iocb->bh = qemu_bh_new(nvme_flush_bh, iocb);\n    iocb->ret = 0;\n    iocb->ns = NULL;\n    iocb->nsid = 0;\n    iocb->broadcast = (nsid == NVME_NSID_BROADCAST);\n    if (!iocb->broadcast) {\n        if (!nvme_nsid_valid(n, nsid)) {\n            status = NVME_INVALID_NSID | NVME_DNR;\n            goto out;\n        }\n        iocb->ns = nvme_ns(n, nsid);\n        if (!iocb->ns) {\n            status = NVME_INVALID_FIELD | NVME_DNR;\n            goto out;\n        }\n        iocb->nsid = nsid;\n    }\n    req->aiocb = &iocb->common;\n    qemu_bh_schedule(iocb->bh);\n    return NVME_NO_COMPLETE;\nout:\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    qemu_aio_unref(iocb);\n    return status;\n}", "target": 0}
{"code": "void WebProcessProxy::removeWebPage(uint64_t pageID)\n{\n    m_pageMap.remove(pageID);\n    globalPageMap().remove(pageID);\n#if PLATFORM(MAC)\n    m_processSuppressiblePages.remove(pageID);\n    updateProcessSuppressionState();\n#endif\n}", "target": 0}
{"code": "date_s__httpdate(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, opt;\n    rb_scan_args(argc, argv, \"1:\", &str, &opt);\n    check_limit(str, opt);\n    return date__httpdate(str);\n}", "target": 0}
{"code": "RenderViewHost* InterstitialPage::CreateRenderViewHost() {\n  RenderViewHost* render_view_host = new RenderViewHost(\n      SiteInstance::CreateSiteInstance(tab()->profile()),\n      this, MSG_ROUTING_NONE, kInvalidSessionStorageNamespaceId);\n  return render_view_host;\n}", "target": 0}
{"code": "rb_wakeups(struct ring_buffer *buffer, struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tbool pagebusy;\n\tif (buffer->irq_work.waiters_pending) {\n\t\tbuffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&buffer->irq_work.work);\n\t}\n\tif (cpu_buffer->irq_work.waiters_pending) {\n\t\tcpu_buffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n\tif (!pagebusy && cpu_buffer->irq_work.full_waiters_pending) {\n\t\tcpu_buffer->irq_work.wakeup_full = true;\n\t\tcpu_buffer->irq_work.full_waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n}", "target": 0}
{"code": "  void set_additional_callback_count(int c) { additional_callback_count_ = c; }", "target": 0}
{"code": "  virtual void Run() {\n    switch (action_) {\n      case BLOCK:\n        resource_dispatcher_host_->BlockRequestsForRoute(\n            process_id_, render_view_host_id_);\n        break;\n      case RESUME:\n        resource_dispatcher_host_->ResumeBlockedRequestsForRoute(\n            process_id_, render_view_host_id_);\n        break;\n      case CANCEL:\n        resource_dispatcher_host_->CancelBlockedRequestsForRoute(\n            process_id_, render_view_host_id_);\n        break;\n      default:\n        NOTREACHED();\n    }\n  }", "target": 0}
{"code": "_dbus_get_shm_name (DBusString *out,const char *scope)\n{\n  return _dbus_get_address_string (out,cDBusDaemonAddressInfo,scope);\n}", "target": 0}
{"code": "static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)\n{\n    const uint32_t old_size = det_ctx->tx_candidates_size;\n    uint32_t new_size = needed;\n    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));\n    if (ptmp == NULL) {\n        FatalError(SC_ERR_MEM_ALLOC, \"failed to expand to %\"PRIu64\" bytes\",\n                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));\n    }\n    det_ctx->tx_candidates = ptmp;\n    det_ctx->tx_candidates_size = new_size;\n    SCLogDebug(\"array expanded from %u to %u elements (%\"PRIu64\" bytes -> %\"PRIu64\" bytes)\",\n            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),\n            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;\n    return 1;\n}", "target": 0}
{"code": "static int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\tfault = check_bytes(start, value, bytes);\n\tif (!fault)\n\t\treturn 1;\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\tslab_bug(s, \"%s overwritten\", what);\n\tprintk(KERN_ERR \"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}", "target": 0}
{"code": "virgl_cmd_transfer_from_host_3d(VuGpu *g,\n                                struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_transfer_host_3d tf3d;\n    VUGPU_FILL_CMD(tf3d);\n    virgl_renderer_transfer_read_iov(tf3d.resource_id,\n                                     tf3d.hdr.ctx_id,\n                                     tf3d.level,\n                                     tf3d.stride,\n                                     tf3d.layer_stride,\n                                     (struct virgl_box *)&tf3d.box,\n                                     tf3d.offset, NULL, 0);\n}", "target": 0}
{"code": "append_null (struct growable *dest)\n{\n  GROW (dest, 1);\n  *TAIL (dest) = 0;\n}", "target": 0}
{"code": "win_redraw_last_status(frame_T *frp)\n{\n    if (frp->fr_layout == FR_LEAF)\n\tfrp->fr_win->w_redr_status = TRUE;\n    else if (frp->fr_layout == FR_ROW)\n    {\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    win_redraw_last_status(frp);\n    }\n    else \n    {\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\twin_redraw_last_status(frp);\n    }\n}", "target": 0}
{"code": "static int my_kill(int pid, int sig)\n{\n#ifdef __WIN__\n  HANDLE proc;\n  if ((proc= OpenProcess(SYNCHRONIZE|PROCESS_TERMINATE, FALSE, pid)) == NULL)\n    return -1;\n  if (sig == 0)\n  {\n    DWORD wait_result= WaitForSingleObject(proc, 0);\n    CloseHandle(proc);\n    return wait_result == WAIT_OBJECT_0?-1:0;\n  }\n  (void)TerminateProcess(proc, 201);\n  CloseHandle(proc);\n  return 1;\n#else\n  return kill(pid, sig);\n#endif\n}", "target": 0}
{"code": "ZEND_METHOD(error_exception, __construct)\n{\n\tchar  *message = NULL, *filename = NULL;\n\tlong   code = 0, severity = E_ERROR, lineno;\n\tzval  *object, *previous = NULL;\n\tint    argc = ZEND_NUM_ARGS(), message_len, filename_len;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC, \"|sllslO!\", &message, &message_len, &code, &severity, &filename, &filename_len, &lineno, &previous, default_exception_ce) == FAILURE) {\n\t\tzend_error(E_ERROR, \"Wrong parameters for ErrorException([string $exception [, long $code, [ long $severity, [ string $filename, [ long $lineno  [, Exception $previous = NULL]]]]]])\");\n\t}\n\tobject = getThis();\n\tif (message) {\n\t\tzend_update_property_string(default_exception_ce, object, \"message\", sizeof(\"message\")-1, message TSRMLS_CC);\n\t}\n\tif (code) {\n\t\tzend_update_property_long(default_exception_ce, object, \"code\", sizeof(\"code\")-1, code TSRMLS_CC);\n\t}\n\tif (previous) {\n\t\tzend_update_property(default_exception_ce, object, \"previous\", sizeof(\"previous\")-1, previous TSRMLS_CC);\n\t}\n\tzend_update_property_long(default_exception_ce, object, \"severity\", sizeof(\"severity\")-1, severity TSRMLS_CC);\n\tif (argc >= 4) {\n\t    zend_update_property_string(default_exception_ce, object, \"file\", sizeof(\"file\")-1, filename TSRMLS_CC);\n    \tif (argc < 5) {\n    \t    lineno = 0; \n    \t}\n    \tzend_update_property_long(default_exception_ce, object, \"line\", sizeof(\"line\")-1, lineno TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "TEST(QuantizedInt8PoolingOpTest, MaxPoolActivationRelu6) {\n  SymmetricQuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_INT8, {1, 2, 4, 1}, -15.9375, 15.8130},\n      2, 2,\n      {TensorType_INT8, {}, -15.9375, 15.8130}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU6);\n  m.SetInput({\n      0, -6, 12, 4,   \n      -3, -2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 6.0}, 0.025)));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128 - 128, 176 - 128}));\n  m.SetInput({\n      0, 4.5, 12, 4,  \n      3, 2, 10, 7,    \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({4.5, 6.0}, 0.025)));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({164 - 128, 176 - 128}));\n}", "target": 0}
{"code": "PHP_FUNCTION(pclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tFG(pclose_wait) = 1;\n\tzend_list_delete(stream->rsrc_id);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}", "target": 0}
{"code": "    static uint32_t byteSwap_(uint32_t value,bool bSwap)\n    {\n        uint32_t result = 0;\n        result |= (value & 0x000000FF) << 24;\n        result |= (value & 0x0000FF00) << 8;\n        result |= (value & 0x00FF0000) >> 8;\n        result |= (value & 0xFF000000) >> 24;\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "static long kvm_vcpu_compat_ioctl(struct file *filp,\n\t\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = compat_ptr(arg);\n\tint r;\n\tif (vcpu->kvm->mm != current->mm)\n\t\treturn -EIO;\n\tswitch (ioctl) {\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tcompat_sigset_t csigset;\n\t\tsigset_t sigset;\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(csigset))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&csigset, sigmask_arg->sigset,\n\t\t\t\t\t   sizeof(csigset)))\n\t\t\t\tgoto out;\n\t\t\tsigset_from_compat(&sigset, &csigset);\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, &sigset);\n\t\t} else\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vcpu_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "void ExtensionPrefs::DeleteExtensionPrefs(const std::string& extension_id) {\n  DictionaryPrefUpdate update(prefs_, kExtensionsPref);\n  DictionaryValue* dict = update.Get();\n  if (dict->HasKey(extension_id)) {\n    dict->Remove(extension_id, NULL);\n    SavePrefs();\n  }\n  extension_pref_value_map_->UnregisterExtension(extension_id);\n  content_settings_store_->UnregisterExtension(extension_id);\n}", "target": 0}
{"code": "static int inet6_netconf_msgsize_devconf(int type)\n{\n\tint size =  NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t    + nla_total_size(4);\t\n\tif (type == -1 || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n#ifdef CONFIG_IPV6_MROUTE\n\tif (type == -1 || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n#endif\n\treturn size;\n}", "target": 0}
{"code": "SupportsClient2Server(rfbClient* client, int messageType)\n{\n    return (client->supportedMessages.client2server[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);\n}", "target": 0}
{"code": "cgiGetFile(void)\n{\n  return (form_file);\n}", "target": 0}
{"code": "rgba2la(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4, out += 4) {\n        out[0] = out[1] = out[2] = L24(in) >> 16;\n        out[3] = in[3];\n    }\n}", "target": 0}
{"code": "close_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    \n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n    ++RedrawingDisabled;\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\tbreak;\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n    --RedrawingDisabled;\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}", "target": 0}
{"code": "onig_get_right_range_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->right_range;\n}", "target": 0}
{"code": "decrypt_header(zip_source_t *src, struct winzip_aes *ctx)\n{\n    zip_uint8_t header[MAX_HEADER_LENGTH];\n    zip_uint8_t password_verification[PWD_VER_LENGTH];\n    zip_uint8_t headerlen;\n    zip_int64_t n;\n    unsigned char key[16];\n    headerlen = PWD_VER_LENGTH + salt_length[ctx->mode];\n    if ((n=zip_source_read(src, header, headerlen)) < 0) {\n\t_zip_error_set_from_source(&ctx->error, src);\n\treturn -1;\n    }\n    if (n != headerlen) {\n\tzip_error_set(&ctx->error, ZIP_ER_EOF, 0);\n\treturn -1;\n    }\n    if (_zip_fcrypt_init(ctx->mode, ctx->password, strlen(ctx->password), header, password_verification, &ctx->fcrypt_ctx) != 0) {\n\tzip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);\n\treturn -1;\n    }\n    if (memcmp(password_verification, header + salt_length[ctx->mode], PWD_VER_LENGTH) != 0) {\n\tzip_error_set(&ctx->error, ZIP_ER_WRONGPASSWD, 0);\n\treturn -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "UsageTracker::~UsageTracker() {\n  STLDeleteValues(&client_tracker_map_);\n}", "target": 0}
{"code": "KURL Document::OpenSearchDescriptionURL() {\n  static const char kOpenSearchMIMEType[] =\n      \"application/opensearchdescription+xml\";\n  static const char kOpenSearchRelation[] = \"search\";\n  if (!GetFrame() || GetFrame()->Tree().Parent())\n    return KURL();\n  if (!LoadEventFinished())\n    return KURL();\n  if (!head())\n    return KURL();\n  for (HTMLLinkElement* link_element =\n           Traversal<HTMLLinkElement>::FirstChild(*head());\n       link_element;\n       link_element = Traversal<HTMLLinkElement>::NextSibling(*link_element)) {\n    if (!DeprecatedEqualIgnoringCase(link_element->GetType(),\n                                     kOpenSearchMIMEType) ||\n        !DeprecatedEqualIgnoringCase(link_element->Rel(), kOpenSearchRelation))\n      continue;\n    if (link_element->Href().IsEmpty())\n      continue;\n    WebFeature osd_disposition;\n    scoped_refptr<SecurityOrigin> target =\n        SecurityOrigin::Create(link_element->Href());\n    if (IsSecureContext()) {\n      osd_disposition = target->IsPotentiallyTrustworthy()\n                            ? WebFeature::kOpenSearchSecureOriginSecureTarget\n                            : WebFeature::kOpenSearchSecureOriginInsecureTarget;\n    } else {\n      osd_disposition =\n          target->IsPotentiallyTrustworthy()\n              ? WebFeature::kOpenSearchInsecureOriginSecureTarget\n              : WebFeature::kOpenSearchInsecureOriginInsecureTarget;\n    }\n    UseCounter::Count(*this, osd_disposition);\n    return link_element->Href();\n  }\n  return KURL();\n}", "target": 0}
{"code": "DLLEXPORT tjhandle DLLCALL tjInitDecompress(void)\n{\n\ttjinstance *this;\n\tif((this=(tjinstance *)malloc(sizeof(tjinstance)))==NULL)\n\t{\n\t\tsnprintf(errStr, JMSG_LENGTH_MAX,\n\t\t\t\"tjInitDecompress(): Memory allocation failure\");\n\t\treturn NULL;\n\t}\n\tMEMZERO(this, sizeof(tjinstance));\n\tsnprintf(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n\treturn _tjInitDecompress(this);\n}", "target": 0}
{"code": "RGWOp *RGWHandler_REST_Bucket_S3::get_obj_op(bool get_data)\n{\n  if (get_data) {\n    return new RGWListBucket_ObjStore_S3;\n  } else {\n    return new RGWStatBucket_ObjStore_S3;\n  }\n}", "target": 0}
{"code": "  MaybeObject** scheduled_exception_address() {\n    return &thread_local_top_.scheduled_exception_;\n  }", "target": 0}
{"code": "static void sock_def_write_space(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\trcu_read_lock();\n\tif ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf) {\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq_has_sleeper(wq))\n\t\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\tPOLLWRNORM | POLLWRBAND);\n\t\tif (sock_writeable(sk))\n\t\t\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::IsRendering() const {\n  return state_ == RENDERING || state_ == DONE;\n}", "target": 0}
{"code": "static bool avrcp_event_registered(struct avrcp *session, uint8_t event)\n{\n\treturn session->registered_events & (1 << event);\n}", "target": 0}
{"code": "onigenc_mb2_is_code_ctype(OnigEncoding enc, OnigCodePoint code,\n\t\t\t  unsigned int ctype)\n{\n  if (code < 128)\n    return ONIGENC_IS_ASCII_CODE_CTYPE(code, ctype);\n  else {\n    if (CTYPE_IS_WORD_GRAPH_PRINT(ctype)) {\n      return (ONIGENC_CODE_TO_MBCLEN(enc, code) > 1 ? TRUE : FALSE);\n    }\n  }\n  return FALSE;\n}", "target": 0}
{"code": "static unsigned int map_operations (int commandbyte )\n{\n\tunsigned int op = (unsigned int)-1;\n\tswitch ( (commandbyte & 0xfe) ) {\n\t\tcase 0xe2:    op = SC_AC_OP_UPDATE; break;\n\t\tcase 0x24:  op = SC_AC_OP_UPDATE; break;\n\t\tcase 0xe0:           op = SC_AC_OP_CREATE; break;\n\t\tcase 0xe4:           op = SC_AC_OP_DELETE; break;\n\t\tcase 0xe8:      op = SC_AC_OP_WRITE; break;\n\t\tcase 0x82:    op = SC_AC_OP_READ; break;\n\t\tcase 0xe6:      op = SC_AC_OP_WRITE; break;\n\t\tcase 0x88:    op = SC_AC_OP_READ; break;\n\t\tcase 0x04:       op = SC_AC_OP_INVALIDATE; break;\n\t\tcase 0x2a:  op = SC_AC_OP_SELECT; break;\n\t\tcase 0xb0:      op = SC_AC_OP_READ; break;\n\t\tcase 0xb2:      op = SC_AC_OP_READ; break;\n\t\tcase 0x44:     op = SC_AC_OP_REHABILITATE; break;\n\t\tcase 0xa4:           op = SC_AC_OP_SELECT; break;\n\t\tcase 0xee:    op = SC_AC_OP_CREATE; break;\n\t\tcase 0x2c: op = SC_AC_OP_WRITE; break;\n\t\tcase 0xd6:    op = SC_AC_OP_WRITE; break;\n\t\tcase 0xdc:    op = SC_AC_OP_WRITE; break;\n\t\tcase 0x20:  op = SC_AC_OP_SELECT; break;\n\t\tcase 0x60:      op = SC_AC_OP_CREATE; break;\n\t}\n\treturn op;\n}", "target": 0}
{"code": "static void sysfs_add_func(struct work_struct *w)\n{\n\tstruct kmem_cache *s;\n\tdown_write(&slub_lock);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tif (s->flags & __SYSFS_ADD_DEFERRED) {\n\t\t\ts->flags &= ~__SYSFS_ADD_DEFERRED;\n\t\t\tsysfs_slab_add(s);\n\t\t}\n\t}\n\tup_write(&slub_lock);\n}", "target": 0}
{"code": "static int map_files_d_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint status = 0;\n\tif (nd && nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tstatus = -EACCES;\n\t\tgoto out_notask;\n\t}\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out;\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tdown_read(&mm->mmap_sem);\n\t\texact_vma_exists = !!find_exact_vma(mm, vm_start, vm_end);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\tmmput(mm);\n\tif (exact_vma_exists) {\n\t\tif (task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = 0;\n\t\t\tinode->i_gid = 0;\n\t\t}\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\nout:\n\tput_task_struct(task);\nout_notask:\n\tif (status <= 0)\n\t\td_drop(dentry);\n\treturn status;\n}", "target": 0}
{"code": "static bool stack_slot_scratched(const struct bpf_verifier_env *env, u64 regno)\n{\n\treturn (env->scratched_stack_slots >> regno) & 1;\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> log10(const CImg<T>& instance) {\n    return instance.get_log10();", "target": 0}
{"code": "    std::string Exifdatum::toString(long n) const\n    {\n        return value_.get() == 0 ? \"\" : value_->toString(n);\n    }", "target": 0}
{"code": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\tkref_put(&user->refcount, free_user);\n\treturn 0;\n}", "target": 0}
{"code": "static int hns_roce_setup_mtu_mac(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tu8 i;\n\tfor (i = 0; i < hr_dev->caps.num_ports; i++) {\n\t\tif (hr_dev->hw->set_mtu)\n\t\t\thr_dev->hw->set_mtu(hr_dev, hr_dev->iboe.phy_port[i],\n\t\t\t\t\t    hr_dev->caps.max_mtu);\n\t\tret = hns_roce_set_mac(hr_dev, i,\n\t\t\t\t       hr_dev->iboe.netdevs[i]->dev_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}", "target": 0}
{"code": "static void packet_discard(struct gps_packet_t *lexer)\n{\n    size_t discard = lexer->inbufptr - lexer->inbuffer;\n    size_t remaining = lexer->inbuflen - discard;\n    lexer->inbufptr = memmove(lexer->inbuffer, lexer->inbufptr, remaining);\n    lexer->inbuflen = remaining;\n    if (lexer->debug >= LOG_RAW+1)\n\tgpsd_report(LOG_RAW + 1,\n\t\t    \"Packet discard of %zu, chars remaining is %zu = %s\\n\",\n\t\t    discard, remaining,\n\t\t    gpsd_packetdump((char *)lexer->inbuffer, lexer->inbuflen));\n}", "target": 0}
{"code": "innodb_allocate(\n\tENGINE_HANDLE*\thandle,\t\t\n\tconst void*\tcookie,\t\t\n\titem **\t\titem,\t\t\n\tconst void*\tkey,\t\t\n\tconst size_t\tnkey,\t\t\n\tconst size_t\tnbytes,\t\t\n\tconst int\tflags,\t\t\n\tconst rel_time_t exptime)\t\n{\n\tsize_t\t\t\tlen;\n\tstruct innodb_engine*\tinnodb_eng = innodb_handle(handle);\n\tstruct default_engine*\tdef_eng = default_handle(innodb_eng);\n\tinnodb_conn_data_t*\tconn_data;\n\thash_item*\t\tit = NULL;\n\tmeta_cfg_info_t*\tmeta_info = innodb_eng->meta_info;\n\tconn_data = innodb_eng->server.cookie->get_engine_specific(cookie);\n\tif (!conn_data) {\n\t\tconn_data = innodb_conn_init(innodb_eng, cookie,\n\t\t\t\t\t     CONN_MODE_WRITE,\n\t\t\t\t\t     IB_LOCK_X, false, NULL);\n\t\tif (!conn_data) {\n\t\t\treturn(ENGINE_TMPFAIL);\n\t\t}\n\t}\n\tif (meta_info->set_option == META_CACHE_OPT_DEFAULT\n            || meta_info->set_option == META_CACHE_OPT_MIX) {\n\t\tconn_data->use_default_mem = true;\n\t\tconn_data->in_use = false;\n\t\treturn(def_eng->engine.allocate(\n\t\t\tinnodb_eng->default_engine,\n\t\t\tcookie, item, key, nkey, nbytes,\n\t\t\tflags, exptime));\n\t}\n\tconn_data->use_default_mem = false;\n\tlen = sizeof(*it) + nkey + nbytes + sizeof(uint64_t);\n\tif (len > conn_data->cmd_buf_len) {\n\t\tfree(conn_data->cmd_buf);\n\t\tconn_data->cmd_buf = malloc(len);\n\t\tconn_data->cmd_buf_len = len;\n\t}\n\tit = (hash_item*) conn_data->cmd_buf;\n\tit->next = it->prev = it->h_next = 0;\n\tit->refcount = 1;\n\tit->iflag = def_eng->config.use_cas ? ITEM_WITH_CAS : 0;\n\tit->nkey = nkey;\n\tit->nbytes = nbytes;\n\tit->flags = flags;\n\tit->slabs_clsid = 1;\n\tmemcpy((void*) item_get_key(it), key, nkey);\n\tit->exptime = exptime;\n\t*item = it;\n\tconn_data->in_use = false;\n\treturn(ENGINE_SUCCESS);\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "gfx::SwapResult GLSurfaceOzoneSurfaceless::SwapBuffers() {\n  glFlush();\n  if (has_implicit_external_sync_) {\n    EGLSyncKHR fence = InsertFence();\n    if (!fence)\n      return SwapResult::SWAP_FAILED;\n    EGLDisplay display = GetDisplay();\n    WaitForFence(display, fence);\n    eglDestroySyncKHR(display, fence);\n  }\n  unsubmitted_frames_.back()->ScheduleOverlayPlanes(widget_);\n  unsubmitted_frames_.back()->overlays.clear();\n  if (ozone_surface_->IsUniversalDisplayLinkDevice())\n    glFinish();\n  return ozone_surface_->OnSwapBuffers() ? gfx::SwapResult::SWAP_ACK\n                                         : gfx::SwapResult::SWAP_FAILED;\n}", "target": 0}
{"code": "  size_t check_bom_chars(const char* src, const char *end, const unsigned char* bom, size_t len)\n  {\n    size_t skip = 0;\n    if (src + len > end) return 0;\n    for (size_t i = 0; i < len; ++i, ++skip) {\n      if ((unsigned char) src[i] != bom[i]) return 0;\n    }\n    return skip;\n  }", "target": 0}
{"code": "static int seed_constraint_attributes(void)\n{\n\tint i;\n\tint ret;\n\tfor (i = 0; i < MAX_CONSTRAINTS_PER_ZONE; ++i) {\n\t\tret = create_constraint_attribute(i, \"power_limit_uw\",\n\t\t\t\t\tS_IWUSR | S_IRUGO,\n\t\t\t\t\t&constraint_attrs[i].power_limit_attr,\n\t\t\t\t\tshow_constraint_power_limit_uw,\n\t\t\t\t\tstore_constraint_power_limit_uw);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"time_window_us\",\n\t\t\t\t\tS_IWUSR | S_IRUGO,\n\t\t\t\t\t&constraint_attrs[i].time_window_attr,\n\t\t\t\t\tshow_constraint_time_window_us,\n\t\t\t\t\tstore_constraint_time_window_us);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"name\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].name_attr,\n\t\t\t\tshow_constraint_name,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"max_power_uw\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].max_power_attr,\n\t\t\t\tshow_constraint_max_power_uw,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"min_power_uw\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].min_power_attr,\n\t\t\t\tshow_constraint_min_power_uw,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"max_time_window_us\",\n\t\t\t\tS_IRUGO,\n\t\t\t\t&constraint_attrs[i].max_time_window_attr,\n\t\t\t\tshow_constraint_max_time_window_us,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"min_time_window_us\",\n\t\t\t\tS_IRUGO,\n\t\t\t\t&constraint_attrs[i].min_time_window_attr,\n\t\t\t\tshow_constraint_min_time_window_us,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t}\n\treturn 0;\nerr_alloc:\n\tfree_constraint_attributes();\n\treturn ret;\n}", "target": 0}
{"code": "    void MrwImage::writeMetadata()\n    {\n        throw(Error(kerWritingImageFormatUnsupported, \"MRW\"));\n    } ", "target": 0}
{"code": "    float Iptcdatum::toFloat(long n) const\n    {\n        return value_.get() == 0 ? -1 : value_->toFloat(n);\n    }", "target": 0}
{"code": "static int can_go_on_limited_pmc(struct perf_event *event, u64 ev,\n\t\t\t\t unsigned int flags)\n{\n\tint n;\n\tu64 alt[MAX_EVENT_ALTERNATIVES];\n\tif (event->attr.exclude_user\n\t    || event->attr.exclude_kernel\n\t    || event->attr.exclude_hv\n\t    || event->attr.sample_period)\n\t\treturn 0;\n\tif (ppmu->limited_pmc_event(ev))\n\t\treturn 1;\n\tif (!ppmu->get_alternatives)\n\t\treturn 0;\n\tflags |= PPMU_LIMITED_PMC_OK | PPMU_LIMITED_PMC_REQD;\n\tn = ppmu->get_alternatives(ev, flags, alt);\n\treturn n > 0;\n}", "target": 0}
{"code": "clamp_default_icc(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfz_iccprofile *profile = cs->data;\n\tfor (i = 0; i < profile->num_devcomp; i++)\n\t\tdst[i] = fz_clamp(src[i], 0, 1);\n}", "target": 0}
{"code": "EXPORTED int end_resp_headers(struct transaction_t *txn, long code)\n{\n    int r = 0;\n    if (txn->flags.ver == VER_2) {\n        r = http2_end_headers(txn, code);\n    }\n    else {\n        prot_puts(txn->conn->pout, \"\\r\\n\");\n    }\n    return r;\n}", "target": 0}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "uint64_t HTMLMediaElement::webkitAudioDecodedByteCount() const {\n  if (!GetWebMediaPlayer())\n    return 0;\n  return GetWebMediaPlayer()->AudioDecodedByteCount();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CompoundIndexWithEqualityPredicatesProvidesSort) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuerySortProj(fromjson(\"{a: 1, b: 1}\"), fromjson(\"{b: 1}\"), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {filter: null,\"\n        \"pattern: {a: 1, b: 1}, \"\n        \"bounds: {a:[[1,1,true,true]], b:[[1,1,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static void clear_translation_pre_enabled(struct intel_iommu *iommu)\n{\n\tiommu->flags &= ~VTD_FLAG_TRANS_PRE_ENABLED;\n}", "target": 0}
{"code": "void utf8_snprintf(gchar *dst, gsize byte_len, const gchar *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tgchar *str = g_strdup_vprintf(fmt, ap); \n\tva_end(ap);\n\tutf8_strncpy(dst, str, byte_len);\n\tg_free(str);\n}", "target": 0}
{"code": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (kasan_reset_tag(p) - addr) / s->size;\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesElementMultipleFlags) {\n    BSONObj matchMultilineDotAll = BSON(\"x\"\n                                        << \"\\na\\nb\");\n    RegexMatchExpression regex(\"\", \"^a.b\", \"ms\");\n    ASSERT(regex.matchesSingleElement(matchMultilineDotAll.firstElement()));\n}", "target": 0}
{"code": "static void test_prepare_noparam()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  MYSQL_RES  *result;\n  char query[MAX_TEST_QUERY_LENGTH];\n  myheader(\"test_prepare_noparam\");\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS my_prepare\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"CREATE TABLE my_prepare(col1 int, col2 varchar(50))\");\n  myquery(rc);\n  strmov(query, \"INSERT INTO my_prepare VALUES(10, 'venu')\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n  verify_param_count(stmt, 0);\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n  mysql_stmt_close(stmt);\n  rc= mysql_commit(mysql);\n  myquery(rc);\n  rc= mysql_query(mysql, \"SELECT * FROM my_prepare\");\n  myquery(rc);\n  result= mysql_store_result(mysql);\n  mytest(result);\n  rc= my_process_result_set(result);\n  DIE_UNLESS(rc == 1);\n  mysql_free_result(result);\n}", "target": 0}
{"code": "static void dump_buffer_page(struct buffer_data_page *bpage,\n\t\t\t     struct rb_event_info *info,\n\t\t\t     unsigned long tail)\n{\n\tstruct ring_buffer_event *event;\n\tu64 ts, delta;\n\tint e;\n\tts = bpage->time_stamp;\n\tpr_warn(\"  [%lld] PAGE TIME STAMP\\n\", ts);\n\tfor (e = 0; e < tail; e += rb_event_length(event)) {\n\t\tevent = (struct ring_buffer_event *)(bpage->data + e);\n\t\tswitch (event->type_len) {\n\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\tdelta = rb_event_time_stamp(event);\n\t\t\tts += delta;\n\t\t\tpr_warn(\"  [%lld] delta:%lld TIME EXTEND\\n\", ts, delta);\n\t\t\tbreak;\n\t\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\t\tdelta = rb_event_time_stamp(event);\n\t\t\tts = delta;\n\t\t\tpr_warn(\"  [%lld] absolute:%lld TIME STAMP\\n\", ts, delta);\n\t\t\tbreak;\n\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\tts += event->time_delta;\n\t\t\tpr_warn(\"  [%lld] delta:%d PADDING\\n\", ts, event->time_delta);\n\t\t\tbreak;\n\t\tcase RINGBUF_TYPE_DATA:\n\t\t\tts += event->time_delta;\n\t\t\tpr_warn(\"  [%lld] delta:%d\\n\", ts, event->time_delta);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "void WriteFromUrlOperation::OnURLFetchComplete(const net::URLFetcher* source) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n  if (source->GetStatus().is_success() && source->GetResponseCode() == 200) {\n    SetProgress(kProgressComplete);\n    download_continuation_.Run();\n    download_continuation_ = base::Closure();\n  } else {\n    Error(error::kDownloadInterrupted);\n  }\n}", "target": 0}
{"code": "static int hog_disconnect(struct btd_service *service)\n{\n\tstruct hog_device *dev = btd_service_get_user_data(service);\n\tbt_hog_detach(dev->hog);\n\tbt_hog_unref(dev->hog);\n\tdev->hog = NULL;\n\tbtd_service_disconnecting_complete(service, 0);\n\treturn 0;\n}", "target": 0}
{"code": "static int sqliteProcessJoin(Parse *pParse, Select *p){\n  SrcList *pSrc;                  \n  int i, j;                       \n  struct SrcList_item *pLeft;     \n  struct SrcList_item *pRight;    \n  pSrc = p->pSrc;\n  pLeft = &pSrc->a[0];\n  pRight = &pLeft[1];\n  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){\n    Table *pRightTab = pRight->pTab;\n    int isOuter;\n    if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;\n    isOuter = (pRight->fg.jointype & JT_OUTER)!=0;\n    if( pRight->fg.jointype & JT_NATURAL ){\n      if( pRight->pOn || pRight->pUsing ){\n        sqlite3ErrorMsg(pParse, \"a NATURAL join may not have \"\n           \"an ON or USING clause\", 0);\n        return 1;\n      }\n      for(j=0; j<pRightTab->nCol; j++){\n        char *zName;   \n        int iLeft;     \n        int iLeftCol;  \n        zName = pRightTab->aCol[j].zName;\n        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){\n          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,\n                       isOuter, &p->pWhere);\n        }\n      }\n    }\n    if( pRight->pOn && pRight->pUsing ){\n      sqlite3ErrorMsg(pParse, \"cannot have both ON and USING \"\n        \"clauses in the same join\");\n      return 1;\n    }\n    if( pRight->pOn ){\n      if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor);\n      p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn);\n      pRight->pOn = 0;\n    }\n    if( pRight->pUsing ){\n      IdList *pList = pRight->pUsing;\n      for(j=0; j<pList->nId; j++){\n        char *zName;     \n        int iLeft;       \n        int iLeftCol;    \n        int iRightCol;   \n        zName = pList->a[j].zName;\n        iRightCol = columnIndex(pRightTab, zName);\n        if( iRightCol<0\n         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)\n        ){\n          sqlite3ErrorMsg(pParse, \"cannot join using column %s - column \"\n            \"not present in both tables\", zName);\n          return 1;\n        }\n        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,\n                     isOuter, &p->pWhere);\n      }\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "void InlineFlowBox::adjustMaxAscentAndDescent(int& maxAscent, int& maxDescent, int maxPositionTop, int maxPositionBottom)\n{\n    for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {\n        if (curr->renderer()->isPositioned())\n            continue; \n        if (curr->verticalAlign() == TOP || curr->verticalAlign() == BOTTOM) {\n            int lineHeight = curr->lineHeight();\n            if (curr->verticalAlign() == TOP) {\n                if (maxAscent + maxDescent < lineHeight)\n                    maxDescent = lineHeight - maxAscent;\n            }\n            else {\n                if (maxAscent + maxDescent < lineHeight)\n                    maxAscent = lineHeight - maxDescent;\n            }\n            if (maxAscent + maxDescent >= max(maxPositionTop, maxPositionBottom))\n                break;\n        }\n        if (curr->isInlineFlowBox())\n            static_cast<InlineFlowBox*>(curr)->adjustMaxAscentAndDescent(maxAscent, maxDescent, maxPositionTop, maxPositionBottom);\n    }\n}", "target": 0}
{"code": "njs_function_value_copy(njs_vm_t *vm, njs_value_t *value)\n{\n    njs_function_t     *function, *copy;\n    njs_object_type_t  type;\n    function = njs_function(value);\n    if (!function->object.shared) {\n        return function;\n    }\n    copy = njs_function_copy(vm, function);\n    if (njs_slow_path(copy == NULL)) {\n        njs_memory_error(vm);\n        return NULL;\n    }\n    type = njs_function_object_type(vm, function);\n    if (copy->ctor) {\n        copy->object.shared_hash = vm->shared->function_instance_hash;\n    } else if (type == NJS_OBJ_TYPE_ASYNC_FUNCTION) {\n        copy->object.shared_hash = vm->shared->async_function_instance_hash;\n    } else {\n        copy->object.shared_hash = vm->shared->arrow_instance_hash;\n    }\n    value->data.u.function = copy;\n    return copy;\n}", "target": 0}
{"code": "static const char *set_work_tree(const char *dir)\n{\n\tchar buffer[PATH_MAX + 1];\n\tif (!getcwd(buffer, sizeof(buffer)))\n\t\tdie (\"Could not get the current working directory\");\n\tgit_work_tree_cfg = xstrdup(buffer);\n\tinside_work_tree = 1;\n\treturn NULL;\n}", "target": 0}
{"code": "static void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}", "target": 0}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "acl_fetch_chdr_val(struct proxy *px, struct session *l4, void *l7, int dir,\n\t\t   struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->req.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tif (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)\n\t\treturn 0;\n\treturn acl_fetch_hdr_val(px, l4, txn, txn->req.sol, expr, test);\n}", "target": 0}
{"code": "check_CLEAR_ACTIONS(const struct ofpact_null *a OVS_UNUSED,\n                    const struct ofpact_check_params *cp OVS_UNUSED)\n{\n    return 0;\n}", "target": 0}
{"code": "static inline void ModulateLCHuv(const double percent_luma,\n  const double percent_chroma,const double percent_hue,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n  ConvertRGBToLCHuv(*red,*green,*blue,&luma,&chroma,&hue);\n  luma*=0.01*percent_luma;\n  chroma*=0.01*percent_chroma;\n  hue+=0.5*(0.01*percent_hue-1.0);\n  ConvertLCHuvToRGB(luma,chroma,hue,red,green,blue);\n}", "target": 0}
{"code": "void vc_uniscr_copy_line(struct vc_data *vc, void *dest, int viewed,\n\t\t\t unsigned int row, unsigned int col, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tint offset = row * vc->vc_size_row + col * 2;\n\tunsigned long pos;\n\tBUG_ON(!uniscr);\n\tpos = (unsigned long)screenpos(vc, offset, viewed);\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\trow = (pos - vc->vc_origin) / vc->vc_size_row;\n\t\tcol = ((pos - vc->vc_origin) % vc->vc_size_row) / 2;\n\t\tmemcpy(dest, &uniscr->lines[row][col], nr * sizeof(char32_t));\n\t} else {\n\t\tu16 *p = (u16 *)pos;\n\t\tint mask = vc->vc_hi_font_mask | 0xff;\n\t\tchar32_t *uni_buf = dest;\n\t\twhile (nr--) {\n\t\t\tu16 glyph = scr_readw(p++) & mask;\n\t\t\t*uni_buf++ = inverse_translate(vc, glyph, true);\n\t\t}\n\t}\n}", "target": 0}
{"code": "LIBDE265_INLINE static int luma_pos_to_ctbAddrRS(const seq_parameter_set* sps, int x,int y)\n{\n  int ctbX = x >> sps->Log2CtbSizeY;\n  int ctbY = y >> sps->Log2CtbSizeY;\n  return ctbY * sps->PicWidthInCtbsY + ctbX;\n}", "target": 0}
{"code": "void FrameLoader::commitIconURLToIconDatabase(const KURL& icon)\n{\n    ASSERT(iconDatabase());\n    LOG(IconDatabase, \"Committing iconURL %s to database for pageURLs %s and %s\", icon.string().ascii().data(), m_URL.string().ascii().data(), originalRequestURL().string().ascii().data());\n    iconDatabase()->setIconURLForPageURL(icon.string(), m_URL.string());\n    iconDatabase()->setIconURLForPageURL(icon.string(), originalRequestURL().string());\n}", "target": 0}
{"code": "int PDFiumEngine::GetDuplexType() {\n  return static_cast<int>(FPDF_VIEWERREF_GetDuplex(doc_));\n}", "target": 0}
{"code": "static void bnx2x_handle_eee_event(struct bnx2x *bp)\n{\n\tDP(BNX2X_MSG_MCP, \"EEE - LLDP event\\n\");\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_EEE_RESULTS_ACK, 0);\n}", "target": 0}
{"code": "_dbus_get_is_errno_eagain_or_ewouldblock (void)\n{\n  return errno == WSAEWOULDBLOCK;\n}", "target": 0}
{"code": "static u64 svm_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\ttsc = svm_scale_tsc(vcpu, native_read_tsc());\n\treturn target_tsc - tsc;\n}", "target": 0}
{"code": "static struct resource *register_memory_resource(u64 start, u64 size)\n{\n\tstruct resource *res;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(!res);\n\tres->name = \"System RAM\";\n\tres->start = start;\n\tres->end = start + size - 1;\n\tres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tif (request_resource(&iomem_resource, res) < 0) {\n\t\tprintk(\"System RAM resource %pR cannot be added\\n\", res);\n\t\tkfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "coolkey_make_public_key(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tint r;\n\tkey = calloc(1, sizeof(struct sc_pkcs15_pubkey));\n\tif (!key)\n\t\treturn NULL;\n\tswitch (key_type) {\n\tcase CKK_RSA:\n\t\tkey->algorithm = SC_ALGORITHM_RSA;\n\t\tr = coolkey_get_attribute_lv(card, obj, CKA_MODULUS, &key->u.rsa.modulus);\n\t\tif (r != SC_SUCCESS) {\n\t\t\tgoto fail;\n\t\t}\n\t\tr = coolkey_get_attribute_lv(card, obj, CKA_PUBLIC_EXPONENT, &key->u.rsa.exponent);\n\t\tif (r != SC_SUCCESS) {\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tcase CKK_EC:\n\t\tkey->algorithm = SC_ALGORITHM_EC;\n\t\tr = coolkey_get_attribute_bytes_alloc(card, obj, CKA_EC_POINT, &key->u.ec.ecpointQ.value, &key->u.ec.ecpointQ.len);\n\t    if(r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tr = coolkey_get_attribute_bytes_alloc(card, obj, CKA_EC_PARAMS,\n\t\t\t\t&key->u.ec.params.der.value, &key->u.ec.params.der.len);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tr = sc_pkcs15_fix_ec_parameters(card->ctx, &key->u.ec.params);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\t}\n\treturn key;\nfail:\n\tsc_pkcs15_free_pubkey(key);\n\treturn NULL;\n}", "target": 0}
{"code": "static int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys)\n{\n    krb5_keyblock *keys;\n    int ret, i;\n    keys = (krb5_keyblock *) malloc(n_key_data*sizeof(krb5_keyblock));\n    if (keys == NULL)\n        return ENOMEM;\n    memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &keys[i],\n                                        NULL);\n        if (ret) {\n            for (; i >= 0; i--) {\n                if (keys[i].contents) {\n                    memset (keys[i].contents, 0, keys[i].length);\n                    free( keys[i].contents );\n                }\n            }\n            memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n            free(keys);\n            return ret;\n        }\n    }\n    *keyblocks = keys;\n    if (n_keys)\n        *n_keys = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "static int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\txdr_decode_hyper(p, &maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static void zynq_slcr_ps_clk_callback(void *opaque)\n{\n    ZynqSLCRState *s = (ZynqSLCRState *) opaque;\n    zynq_slcr_compute_clocks(s);\n    zynq_slcr_propagate_clocks(s);\n}", "target": 0}
{"code": "static int decode_getfh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tuint32_t len;\n\tint status;\n\tmemset(fh, 0, sizeof(*fh));\n\tstatus = decode_op_hdr(xdr, OP_GETFH);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tlen = be32_to_cpup(p);\n\tif (len > NFS4_FHSIZE)\n\t\treturn -EIO;\n\tfh->size = len;\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tmemcpy(fh->data, p, len);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "vte_sequence_handler_ll (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tscreen->cursor_current.row = MAX(screen->insert_delta,\n\t\t\t\t\t screen->insert_delta +\n\t\t\t\t\t terminal->row_count - 1);\n\tscreen->cursor_current.col = 0;\n}", "target": 0}
{"code": "void WifiNetwork::Clear() {\n  WirelessNetwork::Clear();\n  encryption_ = SECURITY_NONE;\n  passphrase_.clear();\n  identity_.clear();\n  cert_path_.clear();\n}", "target": 0}
{"code": "c_valid_time_p(int h, int min, int s, int *rh, int *rmin, int *rs)\n{\n    if (h < 0)\n\th += 24;\n    if (min < 0)\n\tmin += 60;\n    if (s < 0)\n\ts += 60;\n    *rh = h;\n    *rmin = min;\n    *rs = s;\n    return !(h   < 0 || h   > 24 ||\n\t     min < 0 || min > 59 ||\n\t     s   < 0 || s   > 59 ||\n\t     (h == 24 && (min > 0 || s > 0)));\n}", "target": 0}
{"code": "    **/\n    CImg<T>& boxfilter(const float boxsize, const int order, const char axis='x',\n                       const bool boundary_conditions=true,\n                       const unsigned int nb_iter=1) {\n      if (is_empty() || !boxsize || (boxsize<=1 && !order)) return *this;\n      const char naxis = cimg::lowercase(axis);\n      const float nboxsize = boxsize>=0?boxsize:-boxsize*\n        (naxis=='x'?_width:naxis=='y'?_height:naxis=='z'?_depth:_spectrum)/100;\n      switch (naxis) {\n      case 'x' : {\n        cimg_pragma_openmp(parallel for collapse(3) cimg_openmp_if(_width>=256 && _height*_depth*_spectrum>=16))\n        cimg_forYZC(*this,y,z,c)\n          _cimg_blur_box_apply(data(0,y,z,c),nboxsize,_width,1U,order,boundary_conditions,nb_iter);\n      } break;\n      case 'y' : {\n        cimg_pragma_openmp(parallel for collapse(3) cimg_openmp_if(_width>=256 && _height*_depth*_spectrum>=16))\n        cimg_forXZC(*this,x,z,c)\n          _cimg_blur_box_apply(data(x,0,z,c),nboxsize,_height,(ulongT)_width,order,boundary_conditions,nb_iter);\n      } break;\n      case 'z' : {\n        cimg_pragma_openmp(parallel for collapse(3) cimg_openmp_if(_width>=256 && _height*_depth*_spectrum>=16))\n        cimg_forXYC(*this,x,y,c)\n          _cimg_blur_box_apply(data(x,y,0,c),nboxsize,_depth,(ulongT)_width*_height,order,boundary_conditions,nb_iter);\n      } break;\n      default : {\n        cimg_pragma_openmp(parallel for collapse(3) cimg_openmp_if(_width>=256 && _height*_depth*_spectrum>=16))\n        cimg_forXYZ(*this,x,y,z)\n          _cimg_blur_box_apply(data(x,y,z,0),nboxsize,_spectrum,(ulongT)_width*_height*_depth,\n                               order,boundary_conditions,nb_iter);\n      }\n      }\n      return *this;", "target": 0}
{"code": "exit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}", "target": 0}
{"code": "nf_tables_afinfo_lookup(struct net *net, int family, bool autoload)\n{\n\tstruct nft_af_info *afi;\n\tafi = nft_afinfo_lookup(net, family);\n\tif (afi != NULL)\n\t\treturn afi;\n#ifdef CONFIG_MODULES\n\tif (autoload) {\n\t\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\t\trequest_module(\"nft-afinfo-%u\", family);\n\t\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\t\tafi = nft_afinfo_lookup(net, family);\n\t\tif (afi != NULL)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}", "target": 0}
{"code": "Value ExpressionReplaceBase::serialize(bool explain) const {\n    return Value(Document{{getOpName(),\n                           Document{{\"input\", _input->serialize(explain)},\n                                    {\"find\", _find->serialize(explain)},\n                                    {\"replacement\", _replacement->serialize(explain)}}}});\n}", "target": 0}
{"code": "static int perf_fasync(int fd, struct file *filp, int on)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct perf_event *event = filp->private_data;\n\tint retval;\n\tmutex_lock(&inode->i_mutex);\n\tretval = fasync_helper(fd, filp, on, &event->fasync);\n\tmutex_unlock(&inode->i_mutex);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn 0;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_request_continuing(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tstruct pending_pdu *pending;\n\tif (len != 1 || session->pending_pdu == NULL)\n\t\tgoto err;\n\tpending = session->pending_pdu;\n\tif (pending->pdu_id != pdu->params[0])\n\t\tgoto err;\n\tlen = 0;\n\tpending->attr_ids = player_fill_media_attribute(player,\n\t\t\t\t\t\t\tpending->attr_ids,\n\t\t\t\t\t\t\tpdu->params, &len,\n\t\t\t\t\t\t\t&pending->offset);\n\tpdu->pdu_id = pending->pdu_id;\n\tif (pending->attr_ids == NULL) {\n\t\tg_free(session->pending_pdu);\n\t\tsession->pending_pdu = NULL;\n\t\tpdu->packet_type = AVRCP_PACKET_TYPE_END;\n\t} else {\n\t\tpdu->packet_type = AVRCP_PACKET_TYPE_CONTINUING;\n\t}\n\tpdu->params_len = htons(len);\n\treturn AVC_CTYPE_STABLE;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "static MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const ChannelType channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n  FourierInfo\n    fourier_info;\n  MagickBooleanType\n    status;\n  MemoryInfo\n    *inverse_info;\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}", "target": 0}
{"code": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    return;\n  }\n  ClearPowerSaveBlockers(rvh);\n  SetIsLoading(false, NULL);\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n  GetView()->OnTabCrashed(GetCrashedStatus(), crashed_error_code_);\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    RenderProcessGone(GetCrashedStatus()));\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_8_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "PartitionInstallUdfChildHandles (\n  IN  EFI_DRIVER_BINDING_PROTOCOL  *This,\n  IN  EFI_HANDLE                   Handle,\n  IN  EFI_DISK_IO_PROTOCOL         *DiskIo,\n  IN  EFI_DISK_IO2_PROTOCOL        *DiskIo2,\n  IN  EFI_BLOCK_IO_PROTOCOL        *BlockIo,\n  IN  EFI_BLOCK_IO2_PROTOCOL       *BlockIo2,\n  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath\n  )\n{\n  UINT32                       RemainderByMediaBlockSize;\n  EFI_STATUS                   Status;\n  EFI_BLOCK_IO_MEDIA           *Media;\n  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;\n  EFI_LBA                      StartingLBA;\n  EFI_LBA                      EndingLBA;\n  BOOLEAN                      ChildCreated;\n  Media = BlockIo->Media;\n  ChildCreated = FALSE;\n  DivU64x32Remainder (\n    UDF_LOGICAL_SECTOR_SIZE,   \n    Media->BlockSize,          \n    &RemainderByMediaBlockSize \n    );\n  if (RemainderByMediaBlockSize != 0) {\n    return EFI_NOT_FOUND;\n  }\n  Status = PartitionInstallElToritoChildHandles (\n             This,\n             Handle,\n             DiskIo,\n             DiskIo2,\n             BlockIo,\n             BlockIo2,\n             DevicePath\n             );\n  if (!EFI_ERROR (Status)) {\n    DEBUG ((DEBUG_INFO, \"PartitionDxe: El Torito standard found on handle 0x%p.\\n\", Handle));\n    ChildCreated = TRUE;\n  }\n  Status = FindUdfFileSystem (BlockIo, DiskIo, &StartingLBA, &EndingLBA);\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : EFI_NOT_FOUND);\n  }\n  ZeroMem (&PartitionInfo, sizeof (EFI_PARTITION_INFO_PROTOCOL));\n  PartitionInfo.Revision = EFI_PARTITION_INFO_PROTOCOL_REVISION;\n  PartitionInfo.Type = PARTITION_TYPE_OTHER;\n  Status = PartitionInstallChildHandle (\n    This,\n    Handle,\n    DiskIo,\n    DiskIo2,\n    BlockIo,\n    BlockIo2,\n    DevicePath,\n    (EFI_DEVICE_PATH_PROTOCOL *)&gUdfDevicePath,\n    &PartitionInfo,\n    StartingLBA,\n    EndingLBA,\n    Media->BlockSize,\n    NULL\n    );\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : Status);\n  }\n  return EFI_SUCCESS;\n}", "target": 0}
{"code": "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)\n{\n\tif ((unsigned int)size <= sysctl_optmem_max &&\n\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {\n\t\tvoid *mem;\n\t\tatomic_add(size, &sk->sk_omem_alloc);\n\t\tmem = kmalloc(size, priority);\n\t\tif (mem)\n\t\t\treturn mem;\n\t\tatomic_sub(size, &sk->sk_omem_alloc);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void vnc_zrle_clear(VncState *vs)\n{\n    if (vs->zrle->stream.opaque) {\n        deflateEnd(&vs->zrle->stream);\n    }\n    buffer_free(&vs->zrle->zrle);\n    buffer_free(&vs->zrle->fb);\n    buffer_free(&vs->zrle->zlib);\n}", "target": 0}
{"code": "static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){\n  if( pCsr->nRowAvg==0 ){\n    int rc;\n    Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;\n    sqlite3_stmt *pStmt;\n    sqlite3_int64 nDoc = 0;\n    sqlite3_int64 nByte = 0;\n    const char *pEnd;\n    const char *a;\n    rc = sqlite3Fts3SelectDoctotal(p, &pStmt);\n    if( rc!=SQLITE_OK ) return rc;\n    a = sqlite3_column_blob(pStmt, 0);\n    assert( a );\n    pEnd = &a[sqlite3_column_bytes(pStmt, 0)];\n    a += sqlite3Fts3GetVarint(a, &nDoc);\n    while( a<pEnd ){\n      a += sqlite3Fts3GetVarint(a, &nByte);\n    }\n    if( nDoc==0 || nByte==0 ){\n      sqlite3_reset(pStmt);\n      return FTS_CORRUPT_VTAB;\n    }\n    pCsr->nDoc = nDoc;\n    pCsr->nRowAvg = (int)(((nByte / nDoc) + p->nPgsz) / p->nPgsz);\n    assert( pCsr->nRowAvg>0 ); \n    rc = sqlite3_reset(pStmt);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  *pnPage = pCsr->nRowAvg;\n  return SQLITE_OK;\n}", "target": 0}
{"code": "static inline u32 nfsd4_setclientid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}", "target": 0}
{"code": "HTMLMediaElement::~HTMLMediaElement() {\n  BLINK_MEDIA_LOG << \"~HTMLMediaElement(\" << (void*)this << \")\";\n  DCHECK(!audio_source_node_);\n}", "target": 0}
{"code": "uint64_t WasmBinaryBuilder::getU64LEB() {\n  BYN_TRACE(\"<==\\n\");\n  U64LEB ret;\n  ret.read([&]() { return getInt8(); });\n  BYN_TRACE(\"getU64LEB: \" << ret.value << \" ==>\\n\");\n  return ret.value;\n}", "target": 0}
{"code": "int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\n\t\t unsigned long nr_pages)\n{\n\tunsigned long i, ret = 0;\n\tint sections_to_remove;\n\tBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\n\tBUG_ON(nr_pages % PAGES_PER_SECTION);\n\tsections_to_remove = nr_pages / PAGES_PER_SECTION;\n\tfor (i = 0; i < sections_to_remove; i++) {\n\t\tunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\n\t\trelease_mem_region(pfn << PAGE_SHIFT,\n\t\t\t\t   PAGES_PER_SECTION << PAGE_SHIFT);\n\t\tret = __remove_section(zone, __pfn_to_section(pfn));\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "String FrameLoader::userAgent(const KURL& url) const\n{\n    return m_client->userAgent(url);\n}", "target": 0}
{"code": "void Browser::BeforeUnloadFired(WebContents* web_contents,\n                                bool proceed,\n                                bool* proceed_to_fire_unload) {\n  if (is_devtools() && DevToolsWindow::HandleBeforeUnload(web_contents,\n        proceed, proceed_to_fire_unload))\n    return;\n  if (IsFastTabUnloadEnabled()) {\n    *proceed_to_fire_unload =\n        fast_unload_controller_->BeforeUnloadFired(web_contents, proceed);\n  } else {\n    *proceed_to_fire_unload =\n        unload_controller_->BeforeUnloadFired(web_contents, proceed);\n  }\n }", "target": 0}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "imap_client_notify_disconnect(struct client *client,\n\t\t\t      enum client_disconnect_reason reason,\n\t\t\t      const char *text)\n{\n\tif (reason == CLIENT_DISCONNECT_INTERNAL_ERROR) {\n\t\tclient_send_reply_code(client, IMAP_CMD_REPLY_BYE,\n\t\t\t\t       IMAP_RESP_CODE_UNAVAILABLE, text);\n\t} else {\n\t\tclient_send_reply_code(client, IMAP_CMD_REPLY_BYE, NULL, text);\n\t}\n}", "target": 0}
{"code": "rb_memsearch_qchar(const unsigned char *xs, long m, const unsigned char *ys, long n)\n{\n    const unsigned char *x = xs, x0 = *xs, *y = ys;\n    enum {char_size = 4};\n    for (n -= m; n >= 0; n -= char_size, y += char_size) {\n\tif (x0 == *y && memcmp(x+1, y+1, m-1) == 0)\n\t    return y - ys;\n    }\n    return -1;\n}", "target": 0}
{"code": "PassRefPtrWillBeRawPtr<Node> ContainerNode::replaceChild(PassRefPtrWillBeRawPtr<Node> newChild, PassRefPtrWillBeRawPtr<Node> oldChild, ExceptionState& exceptionState)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n    RefPtrWillBeRawPtr<Node> protect(this);\n    if (oldChild == newChild) \n        return oldChild;\n    if (!oldChild) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is null.\");\n        return nullptr;\n    }\n    RefPtrWillBeRawPtr<Node> child = oldChild;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is not a child of this node.\");\n        return nullptr;\n    }\n    ChildListMutationScope mutation(*this);\n    RefPtrWillBeRawPtr<Node> next = child->nextSibling();\n    removeChild(child, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n    if (next && (next->previousSibling() == newChild || next == newChild)) \n        return child;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(*newChild, targets, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    InspectorInstrumentation::willInsertDOMNode(this);\n    for (const auto& targetNode : targets) {\n        ASSERT(targetNode);\n        Node& child = *targetNode;\n        if (next && next->parentNode() != this)\n            break;\n        if (child.parentNode())\n            break;\n        treeScope().adoptIfNeeded(child);\n        {\n            EventDispatchForbiddenScope assertNoEventDispatch;\n            if (next)\n                insertBeforeCommon(*next, child);\n            else\n                appendChildCommon(child);\n        }\n        updateTreeAfterInsertion(child);\n    }\n    dispatchSubtreeModifiedEvent();\n    return child;\n}", "target": 0}
{"code": "  void DidDeleteOriginData(QuotaStatusCode status) {\n    DCHECK_GT(remaining_clients_, 0);\n    if (status != kQuotaStatusOk)\n      ++error_count_;\n    if (--remaining_clients_ == 0)\n      CallCompleted();\n  }", "target": 0}
{"code": "    int Insert::insertIccProfile(const std::string& path, Exiv2::DataBuf& iccProfileBlob) const\n    {\n        int rc = 0;\n        if (!Exiv2::fileExists(path, true)) {\n            std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n            rc = -1;\n        }\n        if (rc == 0) {\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            image->clearIccProfile();\n            if (iccProfileBlob.size_) {\n                image->setIccProfile(iccProfileBlob);\n            }\n            image->writeMetadata();\n        }\n        return rc;\n    }", "target": 0}
{"code": "static char *sqfs_dirname(char *path)\n{\n\tchar *fname;\n\tfname = sqfs_basename(path);\n\t--fname;\n\t*fname = '\\0';\n\treturn path;\n}", "target": 0}
{"code": "static int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "void PDFiumEngine::GetTextRunInfo(int page_index,\n                                  int start_char_index,\n                                  uint32_t* out_len,\n                                  double* out_font_size,\n                                  pp::FloatRect* out_bounds) {\n  DCHECK(page_index >= 0 && page_index < static_cast<int>(pages_.size()));\n  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,\n                                            out_font_size, out_bounds);\n}", "target": 0}
{"code": "    CImg<T> get_min(const T& val) const {\n      return (+*this).min(val);", "target": 0}
{"code": "void HTMLTextAreaElement::setDefaultValue(const String& defaultValue)\n{\n    RefPtr<Node> protectFromMutationEvents(this);\n    Vector<RefPtr<Node> > textNodes;\n    for (Node* n = firstChild(); n; n = n->nextSibling()) {\n        if (n->isTextNode())\n            textNodes.append(n);\n    }\n    size_t size = textNodes.size();\n    for (size_t i = 0; i < size; ++i)\n        removeChild(textNodes[i].get(), IGNORE_EXCEPTION);\n    String value = defaultValue;\n    value.replace(\"\\r\\n\", \"\\n\");\n    value.replace('\\r', '\\n');\n    insertBefore(document().createTextNode(value), firstChild(), IGNORE_EXCEPTION);\n    if (!m_isDirty)\n        setNonDirtyValue(value);\n}", "target": 0}
{"code": "acl_fetch_url(struct proxy *px, struct session *l4, void *l7, int dir,\n              struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->req.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tif (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)\n\t\treturn 0;\n\ttest->len = txn->req.sl.rq.u_l;\n\ttest->ptr = txn->req.sol + txn->req.sl.rq.u;\n\ttest->flags = ACL_TEST_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "static int mctp_serial_open(struct tty_struct *tty)\n{\n\tstruct mctp_serial *dev;\n\tstruct net_device *ndev;\n\tchar name[32];\n\tint idx, rc;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tidx = ida_alloc(&mctp_serial_ida, GFP_KERNEL);\n\tif (idx < 0)\n\t\treturn idx;\n\tsnprintf(name, sizeof(name), \"mctpserial%d\", idx);\n\tndev = alloc_netdev(sizeof(*dev), name, NET_NAME_ENUM,\n\t\t\t    mctp_serial_setup);\n\tif (!ndev) {\n\t\trc = -ENOMEM;\n\t\tgoto free_ida;\n\t}\n\tdev = netdev_priv(ndev);\n\tdev->idx = idx;\n\tdev->tty = tty;\n\tdev->netdev = ndev;\n\tdev->txstate = STATE_IDLE;\n\tdev->rxstate = STATE_IDLE;\n\tspin_lock_init(&dev->lock);\n\tINIT_WORK(&dev->tx_work, mctp_serial_tx_work);\n\trc = register_netdev(ndev);\n\tif (rc)\n\t\tgoto free_netdev;\n\ttty->receive_room = 64 * 1024;\n\ttty->disc_data = dev;\n\treturn 0;\nfree_netdev:\n\tfree_netdev(ndev);\nfree_ida:\n\tida_free(&mctp_serial_ida, idx);\n\treturn rc;\n}", "target": 0}
{"code": "ChildProcessSecurityPolicy::~ChildProcessSecurityPolicy() {\n  web_safe_schemes_.clear();\n  pseudo_schemes_.clear();\n  STLDeleteContainerPairSecondPointers(security_state_.begin(),\n                                       security_state_.end());\n  security_state_.clear();\n}", "target": 0}
{"code": "static GF_ISOSAPType sap_type_from_nal_type(u8 nal_type) {\n\tswitch (nal_type) {\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn SAP_TYPE_3;\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\treturn SAP_TYPE_1;\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\treturn SAP_TYPE_2;\n\tdefault:\n\t\treturn RAP_NO;\n\t}\n}", "target": 0}
{"code": "encode_SET_ETH_SRC(const struct ofpact_mac *mac, enum ofp_version ofp_version,\n                   struct ofpbuf *out)\n{\n    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_SRC, MFF_ETH_SRC,\n                        out);\n}", "target": 0}
{"code": "isoent_new(struct isofile *file)\n{\n\tstruct isoent *isoent;\n\tstatic const struct archive_rb_tree_ops rb_ops = {\n\t\tisoent_cmp_node, isoent_cmp_key,\n\t};\n\tisoent = calloc(1, sizeof(*isoent));\n\tif (isoent == NULL)\n\t\treturn (NULL);\n\tisoent->file = file;\n\tisoent->children.first = NULL;\n\tisoent->children.last = &(isoent->children.first);\n\t__archive_rb_tree_init(&(isoent->rbtree), &rb_ops);\n\tisoent->subdirs.first = NULL;\n\tisoent->subdirs.last = &(isoent->subdirs.first);\n\tisoent->extr_rec_list.first = NULL;\n\tisoent->extr_rec_list.last = &(isoent->extr_rec_list.first);\n\tisoent->extr_rec_list.current = NULL;\n\tif (archive_entry_filetype(file->entry) == AE_IFDIR)\n\t\tisoent->dir = 1;\n\treturn (isoent);\n}", "target": 0}
{"code": "static inline int scrub_nr_raid_mirrors(struct btrfs_bio *bbio)\n{\n\tif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\n\t\treturn 2;\n\telse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\n\t\treturn 3;\n\telse\n\t\treturn (int)bbio->num_stripes;\n}", "target": 0}
{"code": "ipa_get_jf_arith_result (enum tree_code opcode, tree input, tree operand,\n\t\t\t tree res_type)\n{\n  tree res;\n  if (opcode == NOP_EXPR)\n    return input;\n  if (!is_gimple_ip_invariant (input))\n    return NULL_TREE;\n  if (!res_type)\n    {\n      if (TREE_CODE_CLASS (opcode) == tcc_comparison)\n\tres_type = boolean_type_node;\n      else if (expr_type_first_operand_type_p (opcode))\n\tres_type = TREE_TYPE (input);\n      else\n\treturn NULL_TREE;\n    }\n  if (TREE_CODE_CLASS (opcode) == tcc_unary)\n    res = fold_unary (opcode, res_type, input);\n  else\n    res = fold_binary (opcode, res_type, input, operand);\n  if (res && !is_gimple_ip_invariant (res))\n    return NULL_TREE;\n  return res;\n}", "target": 0}
{"code": "get_smb2_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\t    const struct cifs_fid *cifsfid, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc = -EOPNOTSUPP;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\txid = get_xid();\n\tcifs_dbg(FYI, \"trying to get acl\\n\");\n\trc = SMB2_query_acl(xid, tlink_tcon(tlink), cifsfid->persistent_fid,\n\t\t\t    cifsfid->volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t    info);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "callbacks_drawingarea_configure_event (GtkWidget *widget, GdkEventConfigure *event)\n{\n\tGdkDrawable *drawable = widget->window;\n\tgdk_drawable_get_size (drawable, &screenRenderInfo.displayWidth, &screenRenderInfo.displayHeight);\n\tint x_off=0, y_off=0;\n\tif (GDK_IS_WINDOW(widget->window)) {\n\t\tGdkWindow *window = GDK_WINDOW(widget->window);\n\t      gdk_window_get_internal_paint_info (window, &drawable, &x_off, &y_off);\n\t}\n\tif (screen.windowSurface)\n\t\tcairo_surface_destroy ((cairo_surface_t *)\n\t\t\tscreen.windowSurface);\n#if defined(WIN32) || defined(QUARTZ)\n\tcairo_t *cairoTarget = gdk_cairo_create (GDK_WINDOW(widget->window));\n\tscreen.windowSurface = cairo_get_target (cairoTarget);\n\tscreen.windowSurface = cairo_surface_reference (screen.windowSurface);\n\tcairo_destroy (cairoTarget);\n#else\n\tGdkVisual *visual = gdk_drawable_get_visual (drawable);\n\tscreen.windowSurface = (gpointer) cairo_xlib_surface_create (GDK_DRAWABLE_XDISPLAY (drawable),\n                                          GDK_DRAWABLE_XID (drawable),\n                                          GDK_VISUAL_XVISUAL (visual),\n                                          screenRenderInfo.displayWidth,\n                                          screenRenderInfo.displayHeight);\n#endif\n\tif ((screenRenderInfo.scaleFactorX < 0.001)||(screenRenderInfo.scaleFactorY < 0.001)) {\n\t\tgerbv_render_zoom_to_fit_display (mainProject, &screenRenderInfo);\n\t}\n\trender_refresh_rendered_image_on_screen();\n\treturn TRUE;\n}", "target": 0}
{"code": "device_filesystem_set_label (Device *device,\n                             const char *new_label,\n                             DBusGMethodInvocation *context)\n{\n  const Filesystem *fs_details;\n  GError *error;\n  error = NULL;\n  if (device->priv->id_usage == NULL || strcmp (device->priv->id_usage, \"filesystem\") != 0)\n    {\n      throw_error (context, ERROR_FAILED, \"Not a mountable file system\");\n      goto out;\n    }\n  fs_details = daemon_local_get_fs_details (device->priv->daemon, device->priv->id_type);\n  if (fs_details == NULL)\n    {\n      throw_error (context, ERROR_BUSY, \"Unknown filesystem\");\n      goto out;\n    }\n  if (!fs_details->supports_online_label_rename)\n    {\n      if (device_local_is_busy (device, FALSE, &error))\n        {\n          dbus_g_method_return_error (context, error);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           device->priv->device_is_system_internal ? \"org.freedesktop.udisks.change-system-internal\"\n                           : \"org.freedesktop.udisks.change\",\n                           \"FilesystemSetLabel\",\n                           TRUE,\n                           device_filesystem_set_label_authorized_cb,\n                           context,\n                           1,\n                           g_strdup (new_label),\n                           g_free);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "static bool check_args_pair_invalid(enum bpf_arg_type arg_curr,\n\t\t\t\t    enum bpf_arg_type arg_next)\n{\n\treturn (arg_type_is_mem_ptr(arg_curr) &&\n\t        !arg_type_is_mem_size(arg_next)) ||\n\t       (!arg_type_is_mem_ptr(arg_curr) &&\n\t\targ_type_is_mem_size(arg_next));\n}", "target": 0}
{"code": "\tvoid destroy() {\n\t\tif (owner) {\n\t\t\tGenerationPtr newestGeneration;\n\t\t\ttry {\n\t\t\t\tnewestGeneration = getNewestGeneration();\n\t\t\t} catch (const FileSystemException &e) {\n\t\t\t\tif (e.code() == ENOENT) {\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newestGeneration == NULL) {\n\t\t\t\tremoveDirTree(path);\n\t\t\t}\n\t\t}\n\t}", "target": 0}
{"code": "encode_DEBUG_SLOW(const struct ofpact_null *n OVS_UNUSED,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    put_NXAST_DEBUG_SLOW(out);\n}", "target": 0}
{"code": "add_converter(struct archive_string_conv *sc, int (*converter)\n    (struct archive_string *, const void *, size_t,\n     struct archive_string_conv *))\n{\n\tif (sc == NULL || sc->nconverter >= 2)\n\t\t__archive_errx(1, \"Programing error\");\n\tsc->converter[sc->nconverter++] = converter;\n}", "target": 0}
{"code": "void DefaultAudioDestinationHandler::StopRendering() {\n  DCHECK(IsMainThread());\n   StopPlatformDestination();\n }", "target": 0}
{"code": "void ChromeGeolocationPermissionContext::RegisterUserPrefs(\n    PrefService *user_prefs) {\n#if defined(OS_ANDROID)\n  user_prefs->RegisterBooleanPref(prefs::kGeolocationEnabled, true,\n                                  PrefService::UNSYNCABLE_PREF);\n#endif\n}", "target": 0}
{"code": "static inline struct sk_buff *skb_queue_next(const struct sk_buff_head *list,\n\t\t\t\t\t     const struct sk_buff *skb)\n{\n\tBUG_ON(skb_queue_is_last(list, skb));\n\treturn skb->next;\n}", "target": 0}
{"code": "    JpegBase::JpegBase(ImageType type, BasicIo::UniquePtr io, bool create,\n                       const byte initData[], long dataSize)\n        : Image(type, mdExif | mdIptc | mdXmp | mdComment, std::move(io))\n    {\n        if (create) {\n            initImage(initData, dataSize);\n        }\n    }", "target": 0}
{"code": "static int __init disable_acpi_pci(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of pci=noacpi\\n\",\n\t\t       d->ident);\n\t\tacpi_disable_pci();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ssl_load_buffered_record( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_handshake_params * const hs = ssl->handshake;\n    unsigned char * rec;\n    size_t rec_len;\n    unsigned rec_epoch;\n#if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)\n    size_t in_buf_len = ssl->in_buf_len;\n#else\n    size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;\n#endif\n    if( ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        return( 0 );\n    if( hs == NULL )\n        return( 0 );\n    rec       = hs->buffering.future_record.data;\n    rec_len   = hs->buffering.future_record.len;\n    rec_epoch = hs->buffering.future_record.epoch;\n    if( rec == NULL )\n        return( 0 );\n    if( ssl_next_record_is_in_datagram( ssl ) == 1 )\n        return( 0 );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_load_buffered_record\" ) );\n    if( rec_epoch != ssl->in_epoch )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Buffered record not from current epoch.\" ) );\n        goto exit;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Found buffered record from current epoch - load\" ) );\n    if( rec_len > in_buf_len - (size_t)( ssl->in_hdr - ssl->in_buf ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    memcpy( ssl->in_hdr, rec, rec_len );\n    ssl->in_left = rec_len;\n    ssl->next_record_offset = 0;\n    ssl_free_buffered_record( ssl );\nexit:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_load_buffered_record\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "PHP_RINIT_FUNCTION(spl) \n{\n\tSPL_G(autoload_extensions) = NULL;\n\tSPL_G(autoload_extensions_len) = 0;\n\tSPL_G(autoload_functions) = NULL;\n\tSPL_G(hash_mask_init) = 0;\n\treturn SUCCESS;", "target": 0}
{"code": "static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,\n                                     unsigned w, unsigned h, const LodePNGInfo* info_png)\n{\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  if(bpp == 0) return 31; \n  if(info_png->interlace_method == 0)\n  {\n    if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\n    {\n      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));\n      removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);\n    }\n    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));\n  }\n  else \n  {\n    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned i;\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n    for(i = 0; i < 7; i++)\n    {\n      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));\n      if(bpp < 8)\n      {\n        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,\n                          ((passw[i] * bpp + 7) / 8) * 8, passh[i]);\n      }\n    }\n    Adam7_deinterlace(out, in, w, h, bpp);\n  }\n  return 0;\n}", "target": 0}
{"code": "static base::TimeDelta GetSwapDelay() {\n  CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n  int delay = 0;\n  if (cmd_line->HasSwitch(switches::kGpuSwapDelay)) {\n    base::StringToInt(cmd_line->GetSwitchValueNative(\n        switches::kGpuSwapDelay).c_str(), &delay);\n  }\n  return base::TimeDelta::FromMilliseconds(delay);\n}", "target": 0}
{"code": "fbCombineConjointXorU (CARD32 *dest, const CARD32 *src, int width)\n{\n    fbCombineConjointGeneralU (dest, src, width, CombineXor);\n}", "target": 0}
{"code": "static AVStream* mxf_get_opatom_stream(MXFContext *mxf)\n{\n    int i;\n    if (mxf->op != OPAtom)\n        return NULL;\n    for (i = 0; i < mxf->fc->nb_streams; i++) {\n        if (mxf->fc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_DATA)\n            continue;\n        return mxf->fc->streams[i];\n    }\n    return NULL;\n}", "target": 0}
{"code": "int mbedtls_ssl_check_record( mbedtls_ssl_context const *ssl,\n                              unsigned char *buf,\n                              size_t buflen )\n{\n    int ret = 0;\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"=> mbedtls_ssl_check_record\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"record buffer\", buf, buflen );\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )\n    {\n        ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    else\n    {\n        mbedtls_record rec;\n        ret = ssl_parse_record_header( ssl, buf, buflen, &rec );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 3, \"ssl_parse_record_header\", ret );\n            goto exit;\n        }\n        if( ssl->transform_in != NULL )\n        {\n            ret = mbedtls_ssl_decrypt_buf( ssl, ssl->transform_in, &rec );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 3, \"mbedtls_ssl_decrypt_buf\", ret );\n                goto exit;\n            }\n        }\n    }\n#endif \nexit:\n    mbedtls_platform_zeroize( buf, buflen );\n    if( ret == MBEDTLS_ERR_SSL_UNEXPECTED_CID ||\n        ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE )\n    {\n        ret = MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"<= mbedtls_ssl_check_record\" ) );\n    return( ret );\n}", "target": 0}
{"code": "static bool create_db_dir(char *fnam)\n{\n\tint ret;\n\tchar *p;\n\tsize_t len;\n\tlen = strlen(fnam);\n\tp = alloca(len + 1);\n\t(void)strlcpy(p, fnam, len + 1);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/')\n\t\tp++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tret = mkdir(fnam, 0755);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tusernic_error(\"Failed to create %s: %s\\n\", fnam,\n\t\t\t      strerror(errno));\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}", "target": 0}
{"code": "coolkey_v1_get_attribute_len(const u8 *attr, size_t buf_len, size_t *len, int encoded_len)\n{\n\tcoolkey_attribute_header_t *attribute_head = (coolkey_attribute_header_t *)attr;\n\t*len = 0;\n\tif (buf_len < sizeof(coolkey_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tswitch (attribute_head->attribute_data_type) {\n\tcase COOLKEY_ATTR_TYPE_STRING:\n\t\tif (buf_len < (sizeof(coolkey_attribute_header_t) +2)) {\n\t\t\tbreak;\n\t\t}\n\t\t*len = bebytes2ushort(attr + sizeof(coolkey_attribute_header_t));\n\t\tif (encoded_len) {\n\t\t\t*len += 2;\n\t\t}\n\t\treturn SC_SUCCESS;\n\tcase COOLKEY_ATTR_TYPE_BOOL_FALSE:\n\tcase COOLKEY_ATTR_TYPE_BOOL_TRUE:\n\t\t*len = encoded_len ? 0: 1;\n\t\treturn SC_SUCCESS;\n\t\tbreak;\n\tcase COOLKEY_ATTR_TYPE_INTEGER:\n\t\t*len = 4; \n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn SC_ERROR_CORRUPTED_DATA;\n}", "target": 0}
{"code": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}", "target": 0}
{"code": "static int ieee80211_is_multicast_robust_mgmt_frame(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tif (!is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\treturn ieee80211_is_robust_mgmt_frame(skb);\n}", "target": 0}
{"code": "ssize_t proc_projid_map_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\treturn map_write(file, buf, size, ppos, -1,\n\t\t\t &ns->projid_map, &ns->parent->projid_map);\n}", "target": 0}
{"code": "int32_t FontData::BoundOffset(int32_t offset) {\n  return offset + bound_offset_;\n}", "target": 0}
{"code": "static int bnx2x_func_stop(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tint rc;\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_STOP;\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\treturn rc;\n#else\n\t\tBNX2X_ERR(\"FUNC_STOP ramrod failed. Running a dry transaction\\n\");\n\t\t__set_bit(RAMROD_DRV_CLR_ONLY, &func_params.ramrod_flags);\n\t\treturn bnx2x_func_state_change(bp, &func_params);\n#endif\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)\n{\n  MYSQL_RES   *result;\n  MYSQL_FIELD *fields;\n  char\t     buff[258],*end;\n  DBUG_ENTER(\"mysql_list_fields\");\n  DBUG_PRINT(\"enter\",(\"table: '%s'  wild: '%s'\",table,wild ? wild : \"\"));\n  end=strmake(strmake(buff, table,128)+1,wild ? wild : \"\",128);\n  free_old_query(mysql);\n  if (simple_command(mysql, COM_FIELD_LIST, (uchar*) buff,\n                     (ulong) (end-buff), 1) ||\n      !(fields= (*mysql->methods->list_fields)(mysql)))\n    DBUG_RETURN(NULL);\n  if (!(result = (MYSQL_RES *) my_malloc(sizeof(MYSQL_RES),\n\t\t\t\t\t MYF(MY_WME | MY_ZEROFILL))))\n    DBUG_RETURN(NULL);\n  result->methods= mysql->methods;\n  result->field_alloc=mysql->field_alloc;\n  mysql->fields=0;\n  result->field_count = mysql->field_count;\n  result->fields= fields;\n  result->eof=1;\n  DBUG_RETURN(result);\n}", "target": 0}
{"code": "static long evdev_ioctl_compat(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\treturn evdev_ioctl_handler(file, cmd, compat_ptr(arg), 1);\n}", "target": 0}
{"code": "bool FrameLoader::requestFrame(HTMLFrameOwnerElement* ownerElement, const String& urlString, const AtomicString& frameName)\n{\n    KURL scriptURL;\n    KURL url;\n    if (protocolIsJavaScript(urlString)) {\n        scriptURL = completeURL(urlString); \n        url = blankURL();\n    } else\n        url = completeURL(urlString);\n    Frame* frame = ownerElement->contentFrame();\n    if (frame)\n        frame->redirectScheduler()->scheduleLocationChange(url.string(), m_outgoingReferrer, true, true, isProcessingUserGesture());\n    else\n        frame = loadSubframe(ownerElement, url, frameName, m_outgoingReferrer);\n    if (!frame)\n        return false;\n    if (!scriptURL.isEmpty())\n        frame->script()->executeIfJavaScriptURL(scriptURL);\n    return true;\n}", "target": 0}
{"code": "\tlazy_entry const* lazy_entry::dict_find_dict(std::string const& name) const\n\t{\n\t\tlazy_entry const* e = dict_find(name);\n\t\tif (e == 0 || e->type() != lazy_entry::dict_t) return 0;\n\t\treturn e;\n\t}", "target": 0}
{"code": "multiply_alpha (int alpha, int color)\n{\n\tint temp = (alpha * color) + 0x80;\n\treturn ((temp + (temp >> 8)) >> 8);\n}", "target": 0}
{"code": "static inline void skb_set_inner_transport_header(struct sk_buff *skb,\n\t\t\t\t\t\t   const int offset)\n{\n\tskb_reset_inner_transport_header(skb);\n\tskb->inner_transport_header += offset;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\terror = sctp_eat_data(asoc, chunk, commands );\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\tif (chunk->end_of_packet) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 0}
{"code": "static inline u32 smca_ctl_reg(int bank)\n{\n\treturn MSR_AMD64_SMCA_MCx_CTL(bank);\n}", "target": 0}
{"code": "gx_default_composite_adjust_ctm(gs_composite_t *pcte, int x0, int y0, gs_gstate *pgs)\n{\n    return 0;\n}", "target": 0}
{"code": "void LibRaw::kodak_c330_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n  try\n  {\n    for (row = 0; row < height; row++)\n    {\n      checkCancel();\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n  free(pixel);\n  maximum = curve[0xff];\n}", "target": 0}
{"code": "void change_client_state(PgSocket *client, SocketState newstate)\n{\n\tPgPool *pool = client->pool;\n\tswitch (client->state) {\n\tcase CL_FREE:\n\t\tbreak;\n\tcase CL_JUSTFREE:\n\t\tstatlist_remove(&justfree_client_list, &client->head);\n\t\tbreak;\n\tcase CL_LOGIN:\n\t\tstatlist_remove(&login_client_list, &client->head);\n\t\tbreak;\n\tcase CL_WAITING:\n\t\tstatlist_remove(&pool->waiting_client_list, &client->head);\n\t\tbreak;\n\tcase CL_ACTIVE:\n\t\tstatlist_remove(&pool->active_client_list, &client->head);\n\t\tbreak;\n\tcase CL_CANCEL:\n\t\tstatlist_remove(&pool->cancel_req_list, &client->head);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"bad cur client state: %d\", client->state);\n\t}\n\tclient->state = newstate;\n\tswitch (client->state) {\n\tcase CL_FREE:\n\t\tvarcache_clean(&client->vars);\n\t\tslab_free(client_cache, client);\n\t\tbreak;\n\tcase CL_JUSTFREE:\n\t\tstatlist_append(&justfree_client_list, &client->head);\n\t\tbreak;\n\tcase CL_LOGIN:\n\t\tstatlist_append(&login_client_list, &client->head);\n\t\tbreak;\n\tcase CL_WAITING:\n\t\tstatlist_append(&pool->waiting_client_list, &client->head);\n\t\tbreak;\n\tcase CL_ACTIVE:\n\t\tstatlist_append(&pool->active_client_list, &client->head);\n\t\tbreak;\n\tcase CL_CANCEL:\n\t\tstatlist_append(&pool->cancel_req_list, &client->head);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"bad new client state: %d\", client->state);\n\t}\n}", "target": 0}
{"code": "int selinux_netlbl_socket_connect(struct sock *sk, struct sockaddr *addr)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\tif (sksec->nlbl_state != NLBL_REQSKB &&\n\t    sksec->nlbl_state != NLBL_CONNLABELED)\n\t\treturn 0;\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\tif (addr->sa_family == AF_UNSPEC) {\n\t\tnetlbl_sock_delattr(sk);\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tgoto socket_connect_return;\n\t}\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto socket_connect_return;\n\t}\n\trc = netlbl_conn_setattr(sk, addr, secattr);\n\tif (rc == 0)\n\t\tsksec->nlbl_state = NLBL_CONNLABELED;\nsocket_connect_return:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\treturn rc;\n}", "target": 0}
{"code": "static int devid_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct btrfs_device *dev1, *dev2;\n\tdev1 = list_entry(a, struct btrfs_device, dev_list);\n\tdev2 = list_entry(b, struct btrfs_device, dev_list);\n\tif (dev1->devid < dev2->devid)\n\t\treturn -1;\n\telse if (dev1->devid > dev2->devid)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i, k;\n\tp = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\tfor (i=0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\t\tfor (k = 1; ; k++) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (!(aalg_tmpl_set(t, aalg) && aalg->available))\n\t\t\t\tcontinue;\n\t\t\tc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}", "target": 0}
{"code": "void AutoFillManager::GetBillingProfileSuggestions(\n    FormStructure* form,\n    const FormField& field,\n    AutoFillType type,\n    std::vector<string16>* values,\n    std::vector<string16>* labels,\n    std::vector<int>* unique_ids) {\n  std::vector<CreditCard*> matching_creditcards;\n  std::vector<AutoFillProfile*> matching_profiles;\n  std::vector<string16> cc_values;\n  std::vector<string16> cc_labels;\n  if (!FormIsHTTPS(form)) {\n    GetProfileSuggestions(form, field, type, false, values, labels, unique_ids);\n    return;\n  }\n  for (std::vector<CreditCard*>::const_iterator cc =\n           personal_data_->credit_cards().begin();\n       cc != personal_data_->credit_cards().end(); ++cc) {\n    string16 label = (*cc)->billing_address();\n    AutoFillProfile* billing_profile = NULL;\n    string16 profile_field_value;\n    for (std::vector<AutoFillProfile*>::const_iterator iter =\n             personal_data_->profiles().begin();\n         iter != personal_data_->profiles().end(); ++iter) {\n      AutoFillProfile* profile = *iter;\n      if (profile->Label() == label &&\n          !profile->GetFieldText(type).empty() &&\n          StartsWith(profile->GetFieldText(type), field.value(), false)) {\n        billing_profile = profile;\n        break;\n      }\n    }\n    if (!billing_profile)\n      continue;\n    for (std::vector<AutoFillProfile*>::const_iterator iter =\n             personal_data_->profiles().begin();\n         iter != personal_data_->profiles().end(); ++iter) {\n      values->push_back(billing_profile->GetFieldText(type));\n      string16 label = (*iter)->Label() +\n                       ASCIIToUTF16(\"; \") +\n                       (*cc)->LastFourDigits();\n      labels->push_back(label);\n      unique_ids->push_back((*iter)->unique_id());\n    }\n  }\n}", "target": 0}
{"code": "GF_Err vpcc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *)s;\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tpos = gf_bs_get_position(bs);\n\tptr->config = gf_odf_vp_cfg_read_bs(bs, ptr->version == 0);\n\tpos = gf_bs_get_position(bs) - pos ;\n\tif (pos < ptr->size)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox: read only \"LLU\" bytes (expected \"LLU\").\\n\", pos, ptr->size));\n\tif (pos > ptr->size)\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] VPConfigurationBox overflow read \"LLU\" bytes, of box size \"LLU\".\\n\", pos, ptr->size));\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}", "target": 0}
{"code": "int ExtensionPrefs::GetNextAppLaunchIndex() {\n  const DictionaryValue* extensions = prefs_->GetDictionary(kExtensionsPref);\n  if (!extensions)\n    return 0;\n  int max_value = -1;\n  for (DictionaryValue::key_iterator extension_id = extensions->begin_keys();\n       extension_id != extensions->end_keys(); ++extension_id) {\n    int value = GetAppLaunchIndex(*extension_id);\n    if (value > max_value)\n      max_value = value;\n  }\n  return max_value + 1;\n}", "target": 0}
{"code": "Opal::Call::answer ()\n{\n  if (!is_outgoing () && !IsEstablished ()) {\n    PSafePtr<OpalPCSSConnection> connection = GetConnectionAs<OpalPCSSConnection>();\n    if (connection != NULL) {\n      connection->AcceptIncoming();\n    }\n  }\n}", "target": 0}
{"code": "\tvirtual void sync2() { }", "target": 0}
{"code": "check_method_noarg(mrb_state *mrb, const mrb_callinfo *ci)\n{\n  int argc = ci->n == CALL_MAXARGS ? RARRAY_LEN(ci->stack[1]) : ci->n;\n  if (ci->nk > 0) {\n    mrb_value kdict = ci->stack[mrb_ci_kidx(ci)];\n    if (!(mrb_hash_p(kdict) && mrb_hash_empty_p(mrb, kdict))) {\n      argc++;\n    }\n  }\n  if (argc > 0) {\n    mrb_argnum_error(mrb, argc, 0, 0);\n  }\n}", "target": 0}
{"code": "bool PasswordAutofillAgent::TextFieldDidEndEditing(\n    const blink::WebInputElement& element) {\n  WebInputToPasswordInfoMap::const_iterator iter =\n      web_input_to_password_info_.find(element);\n  if (iter == web_input_to_password_info_.end())\n    return false;\n  const PasswordInfo& password_info = iter->second;\n  if (password_info.password_was_edited_last)\n    return false;\n  const PasswordFormFillData& fill_data = password_info.fill_data;\n  if (!fill_data.wait_for_username)\n    return false;\n  blink::WebInputElement password = password_info.password_field;\n  if (!IsElementEditable(password))\n    return false;\n  blink::WebInputElement username = element;  \n  FillUserNameAndPassword(&username, &password, fill_data, true, false,\n                          &nonscript_modified_values_,\n                          base::Bind(&PasswordValueGatekeeper::RegisterElement,\n                                     base::Unretained(&gatekeeper_)),\n                          nullptr);\n  return true;\n}", "target": 0}
{"code": "void kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}", "target": 0}
{"code": "njs_string_split_part_add(njs_vm_t *vm, njs_array_t *array, njs_utf8_t utf8,\n    const u_char *start, size_t size)\n{\n    ssize_t  length;\n    length = njs_string_calc_length(utf8, start, size);\n    return njs_array_string_add(vm, array, start, size, length);\n}", "target": 0}
{"code": "int sldns_str2wire_b64_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tsize_t sz = sldns_b64_pton_calculate_size(strlen(str));\n\tint n;\n\tif(strcmp(str, \"0\") == 0) {\n\t\t*len = 0;\n\t\treturn LDNS_WIREPARSE_ERR_OK;\n\t}\n\tif(*len < sz)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tn = sldns_b64_pton(str, rd, *len);\n\tif(n < 0)\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_B64;\n\t*len = (size_t)n;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "int fz_colorspace_is_indexed(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_INDEXED);\n}", "target": 0}
{"code": "static void btrfs_double_inode_lock(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 < inode2)\n\t\tswap(inode1, inode2);\n\tinode_lock_nested(inode1, I_MUTEX_PARENT);\n\tinode_lock_nested(inode2, I_MUTEX_CHILD);\n}", "target": 0}
{"code": "winzip_aes_new(int mode, const char *password) {\n    struct winzip_aes *ctx;\n    if ((ctx = (struct winzip_aes *)malloc(sizeof(*ctx))) == NULL) {\n\treturn NULL;\n    }\n    if ((ctx->password = strdup(password)) == NULL) {\n\tfree(ctx);\n\treturn NULL;\n    }\n    ctx->mode = mode;\n    zip_error_init(&ctx->error);\n    return ctx;\n}", "target": 0}
{"code": "    void CiffDirectory::doRemove(CrwDirs& crwDirs, uint16_t crwTagId)\n    {\n        const Components::iterator b = components_.begin();\n        const Components::iterator e = components_.end();\n        Components::iterator i;\n        if (!crwDirs.empty()) {\n            CrwSubDir csd = crwDirs.top();\n            crwDirs.pop();\n            for (i = b; i != e; ++i) {\n                if ((*i)->tag() == csd.crwDir_) {\n                    (*i)->remove(crwDirs, crwTagId);\n                    if ((*i)->empty()) components_.erase(i);\n                    break;\n                }\n            }\n        }\n        else {\n            for (i = b; i != e; ++i) {\n                if ((*i)->tagId() == crwTagId) {\n                    delete *i;\n                    components_.erase(i);\n                    break;\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "struct dst_entry * ip6_route_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t    int flags)\n{\n\treturn fib6_rule_lookup(net, fl6, flags, ip6_pol_route_lookup);\n}", "target": 0}
{"code": "static void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\toffline_node = marg->status_change_nid_normal;\n\tif (offline_node < 0)\n\t\treturn;\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmem_cache_node, n);\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n}", "target": 0}
{"code": "void GfxSeparationColorSpace::createMapping(std::vector<GfxSeparationColorSpace *> *separationList, int maxSepComps)\n{\n    if (nonMarking)\n        return;\n    mapping = (int *)gmalloc(sizeof(int));\n    switch (overprintMask) {\n    case 0x01:\n        *mapping = 0;\n        break;\n    case 0x02:\n        *mapping = 1;\n        break;\n    case 0x04:\n        *mapping = 2;\n        break;\n    case 0x08:\n        *mapping = 3;\n        break;\n    default:\n        unsigned int newOverprintMask = 0x10;\n        for (std::size_t i = 0; i < separationList->size(); i++) {\n            GfxSeparationColorSpace *sepCS = (*separationList)[i];\n            if (!sepCS->getName()->cmp(name)) {\n                if (sepCS->getFunc()->hasDifferentResultSet(func)) {\n                    error(errSyntaxWarning, -1, \"Different functions found for '{0:t}', convert immediately\", name);\n                    gfree(mapping);\n                    mapping = nullptr;\n                    return;\n                }\n                *mapping = i + 4;\n                overprintMask = newOverprintMask;\n                return;\n            }\n            newOverprintMask <<= 1;\n        }\n        if ((int)separationList->size() == maxSepComps) {\n            error(errSyntaxWarning, -1, \"Too many ({0:d}) spots, convert '{1:t}' immediately\", maxSepComps, name);\n            gfree(mapping);\n            mapping = nullptr;\n            return;\n        }\n        *mapping = separationList->size() + 4;\n        separationList->push_back((GfxSeparationColorSpace *)copy());\n        overprintMask = newOverprintMask;\n        break;\n    }\n}", "target": 0}
{"code": "struct vm_area_struct *get_gate_vma(struct task_struct *tsk)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "static void storm_memset_eq_prod(struct bnx2x *bp, u16 eq_prod,\n\t\t\t\t u16 pfid)\n{\n\tu32 addr = BAR_CSTRORM_INTMEM + CSTORM_EVENT_RING_PROD_OFFSET(pfid);\n\tREG_WR16(bp, addr, eq_prod);\n}", "target": 0}
{"code": "  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }", "target": 0}
{"code": "static void *rose_node_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (v == SEQ_START_TOKEN) ? rose_node_list\n\t\t: ((struct rose_node *)v)->next;\n}", "target": 0}
{"code": "static int wcd9335_codec_enable_rx_bias(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kc, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\twcd->rx_bias_count++;\n\t\tif (wcd->rx_bias_count == 1) {\n\t\t\twcd9335_codec_init_flyback(comp);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t\tWCD9335_ANA_RX_SUPPLIES,\n\t\t\t\t\t\tWCD9335_ANA_RX_BIAS_ENABLE_MASK,\n\t\t\t\t\t\tWCD9335_ANA_RX_BIAS_ENABLE);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\twcd->rx_bias_count--;\n\t\tif (!wcd->rx_bias_count)\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9335_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9335_ANA_RX_BIAS_ENABLE_MASK,\n\t\t\t\t\tWCD9335_ANA_RX_BIAS_DISABLE);\n\t\tbreak;\n\t};\n\treturn 0;\n}", "target": 0}
{"code": "static void dump_backtrace(void)\n{\n  struct st_connection *conn= cur_con;\n  fprintf(stderr, \"read_command_buf (%p): \", read_command_buf);\n  my_safe_print_str(read_command_buf, sizeof(read_command_buf));\n  fputc('\\n', stderr);\n  if (conn)\n  {\n    fprintf(stderr, \"conn->name (%p): \", conn->name);\n    my_safe_print_str(conn->name, conn->name_len);\n    fputc('\\n', stderr);\n#ifdef EMBEDDED_LIBRARY\n    fprintf(stderr, \"conn->cur_query (%p): \", conn->cur_query);\n    my_safe_print_str(conn->cur_query, conn->cur_query_len);\n    fputc('\\n', stderr);\n#endif\n  }\n  fputs(\"Attempting backtrace...\\n\", stderr);\n  my_print_stacktrace(NULL, my_thread_stack_size);\n}", "target": 0}
{"code": "static my_bool is_binary_compatible(enum enum_field_types type1,\n                                    enum enum_field_types type2)\n{\n  static const enum enum_field_types\n    range1[]= { MYSQL_TYPE_SHORT, MYSQL_TYPE_YEAR, MYSQL_TYPE_NULL },\n    range2[]= { MYSQL_TYPE_INT24, MYSQL_TYPE_LONG, MYSQL_TYPE_NULL },\n    range3[]= { MYSQL_TYPE_DATETIME, MYSQL_TYPE_TIMESTAMP, MYSQL_TYPE_NULL },\n    range4[]= { MYSQL_TYPE_ENUM, MYSQL_TYPE_SET, MYSQL_TYPE_TINY_BLOB,\n                MYSQL_TYPE_MEDIUM_BLOB, MYSQL_TYPE_LONG_BLOB, MYSQL_TYPE_BLOB,\n                MYSQL_TYPE_VAR_STRING, MYSQL_TYPE_STRING, MYSQL_TYPE_GEOMETRY,\n                MYSQL_TYPE_DECIMAL, MYSQL_TYPE_NULL };\n  static const enum enum_field_types\n   *range_list[]= { range1, range2, range3, range4 },\n   **range_list_end= range_list + sizeof(range_list)/sizeof(*range_list);\n   const enum enum_field_types **range, *type;\n  if (type1 == type2)\n    return TRUE;\n  for (range= range_list; range != range_list_end; ++range)\n  {\n    my_bool type1_found= FALSE, type2_found= FALSE;\n    for (type= *range; *type != MYSQL_TYPE_NULL; type++)\n    {\n      type1_found|= type1 == *type;\n      type2_found|= type2 == *type;\n    }\n    if (type1_found || type2_found)\n      return type1_found && type2_found;\n  }\n  return FALSE;\n}", "target": 0}
{"code": "static inline bool bio_remaining_done(struct bio *bio)\n{\n\tif (!bio_flagged(bio, BIO_CHAIN))\n\t\treturn true;\n\tBUG_ON(atomic_read(&bio->__bi_remaining) <= 0);\n\tif (atomic_dec_and_test(&bio->__bi_remaining)) {\n\t\tbio_clear_flag(bio, BIO_CHAIN);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static bool nested_exit_intr_ack_set(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->vm_exit_controls &\n\t\tVM_EXIT_ACK_INTR_ON_EXIT;\n}", "target": 0}
{"code": "  DllDef int libraw_get_color_maximum(libraw_data_t *lr)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->color.maximum;\n  }", "target": 0}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void AudioContext::addDeferredBreakConnection(AudioNode& node)\n{\n    ASSERT(isAudioThread());\n    m_deferredBreakConnectionList.append(&node);\n}", "target": 0}
{"code": "static inline struct kmem_cache_order_objects oo_make(unsigned int order,\n\t\tunsigned int size)\n{\n\tstruct kmem_cache_order_objects x = {\n\t\t(order << OO_SHIFT) + order_objects(order, size)\n\t};\n\treturn x;\n}", "target": 0}
{"code": "static void set_page_hwpoison_huge_page(struct page *hpage)\n{\n\tint i;\n\tint nr_pages = 1 << compound_order(hpage);\n\tfor (i = 0; i < nr_pages; i++)\n\t\tSetPageHWPoison(hpage + i);\n}", "target": 0}
{"code": "have_queries_to_wait_for(MYSQL *connection, uint threshold)\n{\n\tMYSQL_RES *result;\n\tMYSQL_ROW row;\n\tbool all_queries;\n\tresult = xb_mysql_query(connection, \"SHOW FULL PROCESSLIST\", true);\n\tall_queries = (opt_lock_wait_query_type == QUERY_TYPE_ALL);\n\twhile ((row = mysql_fetch_row(result)) != NULL) {\n\t\tconst char\t*info\t\t= row[7];\n\t\tchar\t\t*id\t\t= row[0];\n\t\tint\t\tduration;\n\t\tduration = (row[5] != NULL) ? atoi(row[5]) : 0;\n\t\tif (info != NULL\n\t\t    && duration >= (int)threshold\n\t\t    && ((all_queries && is_query(info))\n\t\t    \t|| is_update_query(info))) {\n\t\t\tmsg_ts(\"Waiting for query %s (duration %d sec): %s\",\n\t\t\t       id, duration, info);\n\t\t\tmysql_free_result(result);\n\t\t\treturn(true);\n\t\t}\n\t}\n\tmysql_free_result(result);\n\treturn(false);\n}", "target": 0}
{"code": "extern int get_u16(unsigned short *val, const char *arg, int base)\n{\n\tunsigned long res;\n\tchar *ptr;\n\tif (!arg || !*arg)\n\t\treturn -1;\n\terrno = 0;\n\tres = strtoul(arg, &ptr, base);\n\tif (!ptr || ptr == arg || *ptr || res > 0xFFFF || errno != 0)\n\t\treturn -1;\n\t*val = res;\n\treturn 0;\n}", "target": 0}
{"code": "    void JpegBase::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}", "target": 0}
{"code": "static int check_revocation(X509_STORE_CTX *ctx)\n{\n    int i = 0, last = 0, ok = 0;\n    if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))\n        return 1;\n    if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)\n        last = sk_X509_num(ctx->chain) - 1;\n    else {\n        if (ctx->parent)\n            return 1;\n        last = 0;\n    }\n    for (i = 0; i <= last; i++) {\n        ctx->error_depth = i;\n        ok = check_cert(ctx);\n        if (!ok)\n            return ok;\n    }\n    return 1;\n}", "target": 0}
{"code": "void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\t__u32 pmtu = 0;\n\tif (!asoc)\n\t\treturn;\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tif (t->pmtu_pending && t->dst) {\n\t\t\tsctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));\n\t\t\tt->pmtu_pending = 0;\n\t\t}\n\t\tif (!pmtu || (t->pathmtu < pmtu))\n\t\t\tpmtu = t->pathmtu;\n\t}\n\tif (pmtu) {\n\t\tasoc->pathmtu = pmtu;\n\t\tasoc->frag_point = sctp_frag_point(asoc, pmtu);\n\t}\n\tpr_debug(\"%s: asoc:%p, pmtu:%d, frag_point:%d\\n\", __func__, asoc,\n\t\t asoc->pathmtu, asoc->frag_point);\n}", "target": 0}
{"code": "  template <typename UnaryOperation> void inlineTransform(UnaryOperation&& unary_op) {\n    ASSERT(type() == Type::Inline);\n    std::transform(absl::get<InlineHeaderVector>(buffer_).begin(),\n                   absl::get<InlineHeaderVector>(buffer_).end(),\n                   absl::get<InlineHeaderVector>(buffer_).begin(), unary_op);\n  }", "target": 0}
{"code": "defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,\n                XML_Bool isId, const XML_Char *value, XML_Parser parser) {\n  DEFAULT_ATTRIBUTE *att;\n  if (value || isId) {\n    int i;\n    for (i = 0; i < type->nDefaultAtts; i++)\n      if (attId == type->defaultAtts[i].id)\n        return 1;\n    if (isId && ! type->idAtt && ! attId->xmlns)\n      type->idAtt = attId;\n  }\n  if (type->nDefaultAtts == type->allocDefaultAtts) {\n    if (type->allocDefaultAtts == 0) {\n      type->allocDefaultAtts = 8;\n      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(\n          parser, type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));\n      if (! type->defaultAtts) {\n        type->allocDefaultAtts = 0;\n        return 0;\n      }\n    } else {\n      DEFAULT_ATTRIBUTE *temp;\n      if (type->allocDefaultAtts > INT_MAX / 2) {\n        return 0;\n      }\n      int count = type->allocDefaultAtts * 2;\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)count > (size_t)(-1) / sizeof(DEFAULT_ATTRIBUTE)) {\n        return 0;\n      }\n#endif\n      temp = (DEFAULT_ATTRIBUTE *)REALLOC(parser, type->defaultAtts,\n                                          (count * sizeof(DEFAULT_ATTRIBUTE)));\n      if (temp == NULL)\n        return 0;\n      type->allocDefaultAtts = count;\n      type->defaultAtts = temp;\n    }\n  }\n  att = type->defaultAtts + type->nDefaultAtts;\n  att->id = attId;\n  att->value = value;\n  att->isCdata = isCdata;\n  if (! isCdata)\n    attId->maybeTokenized = XML_TRUE;\n  type->nDefaultAtts += 1;\n  return 1;\n}", "target": 0}
{"code": "static NTSTATUS read_packet_remainder(int fd, char *buffer,\n\t\t\t\t      unsigned int timeout, ssize_t len)\n{\n\tif (len <= 0) {\n\t\treturn NT_STATUS_OK;\n\t}\n\treturn read_fd_with_timeout(fd, buffer, len, len, timeout, NULL);\n}", "target": 0}
{"code": "    inline unsigned int& _openmp_mode(const unsigned int value, const bool is_set) {\n      static unsigned int mode = 2;\n      if (is_set)  { cimg::mutex(0); mode = value<2?value:2; cimg::mutex(0,0); }\n      return mode;\n    }", "target": 0}
{"code": "static void ml_schedule_timer(struct ml_device *ml)\n{\n\tstruct ml_effect_state *state;\n\tunsigned long now = jiffies;\n\tunsigned long earliest = 0;\n\tunsigned long next_at;\n\tint events = 0;\n\tint i;\n\tpr_debug(\"calculating next timer\\n\");\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\n\t\tstate = &ml->states[i];\n\t\tif (!test_bit(FF_EFFECT_STARTED, &state->flags))\n\t\t\tcontinue;\n\t\tif (test_bit(FF_EFFECT_PLAYING, &state->flags))\n\t\t\tnext_at = calculate_next_time(state);\n\t\telse\n\t\t\tnext_at = state->play_at;\n\t\tif (time_before_eq(now, next_at) &&\n\t\t    (++events == 1 || time_before(next_at, earliest)))\n\t\t\tearliest = next_at;\n\t}\n\tif (!events) {\n\t\tpr_debug(\"no actions\\n\");\n\t\tdel_timer(&ml->timer);\n\t} else {\n\t\tpr_debug(\"timer set\\n\");\n\t\tmod_timer(&ml->timer, earliest);\n\t}\n}", "target": 0}
{"code": "unsigned char * InstanceKlass::get_cached_class_file_bytes() {\n  return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);\n}", "target": 0}
{"code": "static int partitions_probe(blkid_probe pr, struct blkid_chain *chn)\n{\n\tint rc = BLKID_PROBE_NONE;\n\tsize_t i;\n\tif (!pr || chn->idx < -1)\n\t\treturn -EINVAL;\n\tblkid_probe_chain_reset_values(pr, chn);\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\treturn BLKID_PROBE_NONE;\n\tif (chn->binary)\n\t\tpartitions_init_data(chn);\n\tif (!pr->wipe_size && (pr->prob_flags & BLKID_PROBE_FL_IGNORE_PT))\n\t\tgoto details_only;\n\tDBG(LOWPROBE, ul_debug(\"--> starting probing loop [PARTS idx=%d]\",\n\t\tchn->idx));\n\ti = chn->idx < 0 ? 0 : chn->idx + 1U;\n\tfor ( ; i < ARRAY_SIZE(idinfos); i++) {\n\t\tconst char *name;\n\t\tchn->idx = i;\n\t\tif (chn->fltr && blkid_bmp_get_item(chn->fltr, i))\n\t\t\tcontinue;\n\t\trc = idinfo_probe(pr, idinfos[i], chn);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tif (rc != BLKID_PROBE_OK)\n\t\t\tcontinue;\n\t\tname = idinfos[i]->name;\n\t\tif (!chn->binary)\n\t\t\tblkid_probe_set_value(pr, \"PTTYPE\",\n\t\t\t\t\t\t(unsigned char *) name,\n\t\t\t\t\t\tstrlen(name) + 1);\n\t\tDBG(LOWPROBE, ul_debug(\"<-- leaving probing loop (type=%s) [PARTS idx=%d]\",\n\t\t\tname, chn->idx));\n\t\trc = BLKID_PROBE_OK;\n\t\tbreak;\n\t}\n\tif (rc != BLKID_PROBE_OK) {\n\t\tDBG(LOWPROBE, ul_debug(\"<-- leaving probing loop (failed=%d) [PARTS idx=%d]\",\n\t\t\trc, chn->idx));\n\t}\ndetails_only:\n\tif ((rc == BLKID_PROBE_OK || rc == BLKID_PROBE_NONE) && !chn->binary &&\n\t    (blkid_partitions_get_flags(pr) & BLKID_PARTS_ENTRY_DETAILS)) {\n\t\tint xrc = blkid_partitions_probe_partition(pr);\n\t\tif (xrc < 0)\n\t\t\trc = xrc;\t\t\t\n\t\telse if (rc == BLKID_PROBE_NONE)\n\t\t\trc = xrc;\n\t}\n\tDBG(LOWPROBE, ul_debug(\"partitions probe done [rc=%d]\",\trc));\n\treturn rc;\n}", "target": 0}
{"code": "bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        UINT8 v = (*in++ != 0) ? 255 : 0;\n        *out++ = v;\n        *out++ = v;\n        *out++ = v;\n        *out++ = 255;\n    }\n}", "target": 0}
{"code": "static inline const char *xt_outname(const struct xt_action_param *par)\n{\n\treturn par->state->out->name;\n}", "target": 0}
{"code": "open_wait(Sg_device *sdp, int flags)\n{\n\tint retval = 0;\n\tif (flags & O_EXCL) {\n\t\twhile (sdp->open_cnt > 0) {\n\t\t\tmutex_unlock(&sdp->open_rel_lock);\n\t\t\tretval = wait_event_interruptible(sdp->open_wait,\n\t\t\t\t\t(atomic_read(&sdp->detaching) ||\n\t\t\t\t\t !sdp->open_cnt));\n\t\t\tmutex_lock(&sdp->open_rel_lock);\n\t\t\tif (retval) \n\t\t\t\treturn retval;\n\t\t\tif (atomic_read(&sdp->detaching))\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\twhile (sdp->exclude) {\n\t\t\tmutex_unlock(&sdp->open_rel_lock);\n\t\t\tretval = wait_event_interruptible(sdp->open_wait,\n\t\t\t\t\t(atomic_read(&sdp->detaching) ||\n\t\t\t\t\t !sdp->exclude));\n\t\t\tmutex_lock(&sdp->open_rel_lock);\n\t\t\tif (retval) \n\t\t\t\treturn retval;\n\t\t\tif (atomic_read(&sdp->detaching))\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static void free_firmware(struct xc2028_data *priv)\n{\n\tint i;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tif (!priv->firm)\n\t\treturn;\n\tfor (i = 0; i < priv->firm_size; i++)\n\t\tkfree(priv->firm[i].ptr);\n\tkfree(priv->firm);\n\tpriv->firm = NULL;\n\tpriv->firm_size = 0;\n\tpriv->state = XC2028_NO_FIRMWARE;\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestExtractParam) {\n  auto headers = TestRequestHeaderMapImpl{\n      {\":path\", \"/path?token_param=token3&access_token=token4\"},\n      {\"token-header\", \"token2\"},\n      {\"authorization\", \"Bearer token1\"},\n      {\"prefix-header\", \"AAAtoken5\"},\n  };\n  JwtProvider provider;\n  provider.set_issuer(\"foo\");\n  auto extractor = Extractor::create(provider);\n  auto tokens = extractor->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_EQ(tokens[0]->token(), \"token1\");\n  EXPECT_EQ(tokens[1]->token(), \"token4\");\n  auto header = provider.add_from_headers();\n  header->set_name(\"prefix-header\");\n  header->set_value_prefix(\"AAA\");\n  provider.add_from_params(\"token_param\");\n  extractor = Extractor::create(provider);\n  tokens = extractor->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_EQ(tokens[0]->token(), \"token5\");\n  EXPECT_EQ(tokens[1]->token(), \"token3\");\n}", "target": 0}
{"code": "     **/\n    inline double rand(const double val_max=1) {\n      return cimg::rand(0,val_max);", "target": 0}
{"code": "static int calc_acctdigest(RADIUS_PACKET *packet, const char *secret)\n{\n\tu_char\t\tdigest[AUTH_VECTOR_LEN];\n\tMD5_CTX\t\tcontext;\n\tmemset(digest, 0, sizeof(digest));\n\tif (memcmp(packet->vector, digest, AUTH_VECTOR_LEN) == 0) {\n\t\tpacket->verified = 1;\n\t\treturn 1;\n\t}\n\tmemset(packet->data + 4, 0, AUTH_VECTOR_LEN);\n\tMD5Init(&context);\n\tMD5Update(&context, packet->data, packet->data_len);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(digest, &context);\n\tpacket->verified =\n\tmemcmp(digest, packet->vector, AUTH_VECTOR_LEN) ? 2 : 0;\n\treturn packet->verified;\n}", "target": 0}
{"code": "static inline void skb_queue_head_init_class(struct sk_buff_head *list,\n\t\tstruct lock_class_key *class)\n{\n\tskb_queue_head_init(list);\n\tlockdep_set_class(&list->lock, class);\n}", "target": 0}
{"code": "rdpdr_send_client_capability_response(void)\n{\n\tSTREAM s;\n\ts = channel_init(rdpdr_channel, 0x50);\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_CLIENT_CAPABILITY);\n\tout_uint32_le(s, 5);\t\n\tout_uint16_le(s, 1);\t\n\tout_uint16_le(s, 0x28);\t\n\tout_uint32_le(s, 1);\n\tout_uint32_le(s, 2);\n\tout_uint16_le(s, 2);\n\tout_uint16_le(s, 5);\n\tout_uint16_le(s, 1);\n\tout_uint16_le(s, 5);\n\tout_uint16_le(s, 0xFFFF);\n\tout_uint16_le(s, 0);\n\tout_uint32_le(s, 0);\n\tout_uint32_le(s, 3);\n\tout_uint32_le(s, 0);\n\tout_uint32_le(s, 0);\n\tout_uint16_le(s, 2);\t\n\tout_uint16_le(s, 8);\t\n\tout_uint32_le(s, 1);\n\tout_uint16_le(s, 3);\t\n\tout_uint16_le(s, 8);\t\n\tout_uint32_le(s, 1);\n\tout_uint16_le(s, 4);\t\n\tout_uint16_le(s, 8);\t\n\tout_uint32_le(s, 1);\n\tout_uint16_le(s, 5);\t\n\tout_uint16_le(s, 8);\t\n\tout_uint32_le(s, 1);\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}", "target": 0}
{"code": "static int recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif (t->signal->group_stop_count > 0 ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void _WM_Release_Allowance(struct _mdi *mdi) {\n    uint32_t release = 0;\n    uint32_t longest_release = 0;\n    struct _note *note = mdi->note;\n    while (note != NULL) {\n        if (note->modes & SAMPLE_ENVELOPE) {\n            if (note->env < 4) {\n                note->env = 4;\n            }\n            note->env_inc = -note->sample->env_rate[note->env];\n            release = note->env_level / -note->env_inc;\n        } else {\n            if (note->modes & SAMPLE_LOOP) {\n                note->modes ^= SAMPLE_LOOP;\n            }\n            release = note->sample->data_length - note->sample_pos;\n        }\n        if (release > longest_release) longest_release = release;\n        note->replay = NULL;\n        note = note->next;\n    }\n    mdi->samples_to_mix = longest_release;\n    return;\n}", "target": 0}
{"code": "OMX_ERRORTYPE SimpleSoftOMXComponent::fillThisBuffer(\n        OMX_BUFFERHEADERTYPE *buffer) {\n    sp<AMessage> msg = new AMessage(kWhatFillThisBuffer, mHandler);\n    msg->setPointer(\"header\", buffer);\n    msg->post();\n return OMX_ErrorNone;\n}", "target": 0}
{"code": "static void nvme_copy_in_cb(void *opaque, int ret)\n{\n    NvmeCopyAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeNamespace *ns = req->ns;\n    NvmeCopySourceRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto out;\n    } else if (iocb->ret < 0) {\n        goto out;\n    }\n    if (!ns->lbaf.ms) {\n        nvme_copy_in_completed_cb(iocb, 0);\n        return;\n    }\n    range = &iocb->ranges[iocb->idx];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb) + 1;\n    qemu_iovec_reset(&iocb->iov);\n    qemu_iovec_add(&iocb->iov, iocb->bounce + nvme_l2b(ns, nlb),\n                   nvme_m2b(ns, nlb));\n    iocb->aiocb = blk_aio_preadv(ns->blkconf.blk, nvme_moff(ns, slba),\n                                 &iocb->iov, 0, nvme_copy_in_completed_cb,\n                                 iocb);\n    return;\nout:\n    nvme_copy_cb(iocb, iocb->ret);\n}", "target": 0}
{"code": "WebKit::WebGeolocationService* RenderView::geolocationService() {\n  if (!geolocation_dispatcher_.get())\n    geolocation_dispatcher_.reset(new GeolocationDispatcher(this));\n  return geolocation_dispatcher_.get();\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoVertexAttrib2fv(GLuint index, const GLfloat* v) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib2fv: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v[0];\n  value.v[1] = v[1];\n  value.v[2] = 0.0f;\n  value.v[3] = 1.0f;\n  info->set_value(value);\n  glVertexAttrib2fv(index, v);\n}", "target": 0}
{"code": "static size_t curl_progress(void *clientp, double dltotal, double dlnow, double ultotal, double ulnow)\n{\n\tphp_curl *ch = (php_curl *)clientp;\n\tphp_curl_progress *t = ch->handlers->progress;\n\tsize_t\trval = 0;\n#if PHP_CURL_DEBUG\n\tfprintf(stderr, \"curl_progress() called\\n\");\n\tfprintf(stderr, \"clientp = %x, dltotal = %f, dlnow = %f, ultotal = %f, ulnow = %f\\n\", clientp, dltotal, dlnow, ultotal, ulnow);\n#endif\n\tswitch (t->method) {\n\t\tcase PHP_CURL_USER: {\n\t\t\tzval argv[5];\n\t\t\tzval retval;\n\t\t\tint  error;\n\t\t\tzend_fcall_info fci;\n\t\t\tZVAL_RES(&argv[0], ch->res);\n\t\t\tZ_ADDREF(argv[0]);\n\t\t\tZVAL_LONG(&argv[1], (zend_long)dltotal);\n\t\t\tZVAL_LONG(&argv[2], (zend_long)dlnow);\n\t\t\tZVAL_LONG(&argv[3], (zend_long)ultotal);\n\t\t\tZVAL_LONG(&argv[4], (zend_long)ulnow);\n\t\t\tfci.size = sizeof(fci);\n\t\t\tfci.function_table = EG(function_table);\n\t\t\tZVAL_COPY_VALUE(&fci.function_name, &t->func_name);\n\t\t\tfci.object = NULL;\n\t\t\tfci.retval = &retval;\n\t\t\tfci.param_count = 5;\n\t\t\tfci.params = argv;\n\t\t\tfci.no_separation = 0;\n\t\t\tfci.symbol_table = NULL;\n\t\t\tch->in_callback = 1;\n\t\t\terror = zend_call_function(&fci, &t->fci_cache);\n\t\t\tch->in_callback = 0;\n\t\t\tif (error == FAILURE) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot call the CURLOPT_PROGRESSFUNCTION\");\n\t\t\t} else if (!Z_ISUNDEF(retval)) {\n\t\t\t\tif (Z_TYPE(retval) != IS_LONG) {\n\t\t\t\t\tconvert_to_long_ex(&retval);\n\t\t\t\t}\n\t\t\t\tif (0 != Z_LVAL(retval)) {\n\t\t\t\t\trval = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzval_ptr_dtor(&argv[0]);\n\t\t\tzval_ptr_dtor(&argv[1]);\n\t\t\tzval_ptr_dtor(&argv[2]);\n\t\t\tzval_ptr_dtor(&argv[3]);\n\t\t\tzval_ptr_dtor(&argv[4]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rval;\n}", "target": 0}
{"code": "fz_drop_color_converter(fz_context *ctx, fz_color_converter *cc)\n{\n\tfz_icclink *link = (fz_icclink *)cc->link;\n\tif (link)\n\t\tfz_drop_icclink(ctx, link);\n\tcc->link = NULL;\n}", "target": 0}
{"code": "xsltCopyComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemCopyPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemCopyPtr) xsltNewStylePreComp(style, XSLT_FUNC_COPY);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_COPY);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    comp->use = xsltGetCNsProp(style, inst, (const xmlChar *)\"use-attribute-sets\",\n\t\t\t\t    XSLT_NAMESPACE);\n    if (comp->use == NULL)\n\tcomp->has_use = 0;\n    else\n\tcomp->has_use = 1;\n}", "target": 0}
{"code": "static int hls_close(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n    return 0;\n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = bprm->file->f_path.dentry->d_inode;\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tinode_lock(inode);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tinode_unlock(inode);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "static int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "int bio_alloc_pages(struct bio *bio, gfp_t gfp_mask)\n{\n\tint i;\n\tstruct bio_vec *bv;\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tbv->bv_page = alloc_page(gfp_mask);\n\t\tif (!bv->bv_page) {\n\t\t\twhile (--bv >= bio->bi_io_vec)\n\t\t\t\t__free_page(bv->bv_page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void do_item_update(item *it) {\n    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);\n    if (settings.lru_segmented) {\n        assert((it->it_flags & ITEM_SLABBED) == 0);\n        if ((it->it_flags & ITEM_LINKED) != 0) {\n            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {\n                it->time = current_time;\n                item_unlink_q(it);\n                it->slabs_clsid = ITEM_clsid(it);\n                it->slabs_clsid |= WARM_LRU;\n                it->it_flags &= ~ITEM_ACTIVE;\n                item_link_q_warm(it);\n            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {\n                it->time = current_time;\n            }\n        }\n    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {\n        assert((it->it_flags & ITEM_SLABBED) == 0);\n        if ((it->it_flags & ITEM_LINKED) != 0) {\n            it->time = current_time;\n            item_unlink_q(it);\n            item_link_q(it);\n        }\n    }\n}", "target": 0}
{"code": "ScriptPromise BaseAudioContext::decodeAudioData(\n    ScriptState* script_state,\n    DOMArrayBuffer* audio_data,\n    V8DecodeSuccessCallback* success_callback,\n    ExceptionState& exception_state) {\n  return decodeAudioData(script_state, audio_data, success_callback, nullptr,\n                         exception_state);\n}", "target": 0}
{"code": "void RGWDeleteBucketReplication_ObjStore_S3::send_response() \n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag, const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_9_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    if (*p >= 0xaa && *p <= 0xba)\n      return FALSE;\n    else\n      return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}", "target": 0}
{"code": "void Browser::RequestToLockMouse(WebContents* web_contents,\n                                 bool user_gesture,\n                                 bool last_unlocked_by_target) {\n  exclusive_access_manager_->mouse_lock_controller()->RequestToLockMouse(\n      web_contents, user_gesture, last_unlocked_by_target);\n}", "target": 0}
{"code": "static void handle_no_active_connection(struct st_command *command, \n  struct st_connection *cn, DYNAMIC_STRING *ds)\n{\n  handle_error(command, 2006, \"MySQL server has gone away\", \"000000\", ds);\n  cn->pending= FALSE;\n  var_set_errno(2006);\n}", "target": 0}
{"code": "WebView* RenderView::createView(\n    WebFrame* creator,\n    const WebWindowFeatures& features,\n    const WebString& frame_name) {\n  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)\n    return NULL;\n  script_can_close_ = false;\n  ViewHostMsg_CreateWindow_Params params;\n  params.opener_id = routing_id_;\n  params.user_gesture = creator->isProcessingUserGesture();\n  params.window_container_type = WindowFeaturesToContainerType(features);\n  params.session_storage_namespace_id = session_storage_namespace_id_;\n  params.frame_name = frame_name;\n  int32 routing_id = MSG_ROUTING_NONE;\n  int64 cloned_session_storage_namespace_id;\n  bool opener_suppressed = creator->willSuppressOpenerInNewFrame();\n  render_thread_->Send(\n      new ViewHostMsg_CreateWindow(params,\n                                   &routing_id,\n                                   &cloned_session_storage_namespace_id));\n  if (routing_id == MSG_ROUTING_NONE)\n    return NULL;\n  RenderView* view = RenderView::Create(render_thread_,\n                                        0,\n                                        routing_id_,\n                                        renderer_preferences_,\n                                        webkit_preferences_,\n                                        shared_popup_counter_,\n                                        routing_id,\n                                        cloned_session_storage_namespace_id,\n                                        frame_name);\n  view->opened_by_user_gesture_ = params.user_gesture;\n  view->opener_suppressed_ = opener_suppressed;\n  GURL creator_url(creator->securityOrigin().toString().utf8());\n  if (!creator_url.is_valid() || !creator_url.IsStandard())\n    creator_url = GURL();\n  view->creator_url_ = creator_url;\n  view->alternate_error_page_url_ = alternate_error_page_url_;\n  return view->webview();\n}", "target": 0}
{"code": "static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)\n{\n  unsigned error = 0;\n  size_t i;\n  ucvector PLTE;\n  ucvector_init(&PLTE);\n  for(i = 0; i < info->palettesize * 4; i++)\n  {\n    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);\n  }\n  error = addChunk(out, \"PLTE\", PLTE.data, PLTE.size);\n  ucvector_cleanup(&PLTE);\n  return error;\n}", "target": 0}
{"code": "BOOL CSoundFile::SetWaveConfig(UINT nRate,UINT nBits,UINT nChannels,BOOL bMMX)\n{\n\tBOOL bReset = FALSE;\n\tDWORD d = gdwSoundSetup & ~SNDMIX_ENABLEMMX;\n\tif (bMMX) d |= SNDMIX_ENABLEMMX;\n\tif ((gdwMixingFreq != nRate) || (gnBitsPerSample != nBits) || (gnChannels != nChannels) || (d != gdwSoundSetup)) bReset = TRUE;\n\tgnChannels = nChannels;\n\tgdwSoundSetup = d;\n\tgdwMixingFreq = nRate;\n\tgnBitsPerSample = nBits;\n\tInitPlayer(bReset);\n\treturn TRUE;\n}", "target": 0}
{"code": "Item_field::create_tmp_field_from_item_field(TABLE *new_table,\n                                             Item_ref *orig_item,\n                                             const Tmp_field_param *param)\n{\n  DBUG_ASSERT(!is_result_field());\n  Field *result;\n  LEX_CSTRING *new_name= (orig_item ? &orig_item->name :\n                          !param->modify_item() ? &name :\n                          &field->field_name);\n  if (((maybe_null && in_rollup) ||\n      (new_table->in_use->create_tmp_table_for_derived && \n       orig_item && orig_item->maybe_null)) &&\n      !field->maybe_null())\n  {\n    Record_addr rec(orig_item ? orig_item->maybe_null : maybe_null);\n    const Type_handler *handler= type_handler()->\n                                   type_handler_for_tmp_table(this);\n    result= handler->make_and_init_table_field(new_name,\n                                               rec, *this, new_table);\n  }\n  else if (param->table_cant_handle_bit_fields() &&\n           field->type() == MYSQL_TYPE_BIT)\n  {\n    const Type_handler *handler= type_handler_long_or_longlong();\n    result= handler->make_and_init_table_field(new_name,\n                                               Record_addr(maybe_null),\n                                               *this, new_table);\n  }\n  else\n  {\n    bool tmp_maybe_null= param->modify_item() ? maybe_null :\n                                                field->maybe_null();\n    result= field->create_tmp_field(new_table->in_use->mem_root, new_table,\n                                    tmp_maybe_null);\n    if (result && ! param->modify_item())\n      result->field_name= *new_name;\n  }\n  if (result && param->modify_item())\n    result_field= result;\n  return result;\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitBrOn(Expression*& out, uint32_t code) {\n  BrOnOp op;\n  switch (code) {\n    case BinaryConsts::BrOnNull:\n      op = BrOnNull;\n      break;\n    case BinaryConsts::BrOnNonNull:\n      op = BrOnNonNull;\n      break;\n    case BinaryConsts::BrOnCast:\n    case BinaryConsts::BrOnCastStatic:\n      op = BrOnCast;\n      break;\n    case BinaryConsts::BrOnCastFail:\n    case BinaryConsts::BrOnCastStaticFail:\n      op = BrOnCastFail;\n      break;\n    case BinaryConsts::BrOnFunc:\n      op = BrOnFunc;\n      break;\n    case BinaryConsts::BrOnNonFunc:\n      op = BrOnNonFunc;\n      break;\n    case BinaryConsts::BrOnData:\n      op = BrOnData;\n      break;\n    case BinaryConsts::BrOnNonData:\n      op = BrOnNonData;\n      break;\n    case BinaryConsts::BrOnI31:\n      op = BrOnI31;\n      break;\n    case BinaryConsts::BrOnNonI31:\n      op = BrOnNonI31;\n      break;\n    default:\n      return false;\n  }\n  auto name = getBreakTarget(getU32LEB()).name;\n  if (code == BinaryConsts::BrOnCastStatic ||\n      code == BinaryConsts::BrOnCastStaticFail) {\n    auto intendedType = getIndexedHeapType();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeBrOn(op, name, ref, intendedType);\n    return true;\n  }\n  Expression* rtt = nullptr;\n  if (op == BrOnCast || op == BrOnCastFail) {\n    rtt = popNonVoidExpression();\n  }\n  auto* ref = popNonVoidExpression();\n  out = ValidatingBuilder(wasm, pos).validateAndMakeBrOn(op, name, ref, rtt);\n  return true;\n}", "target": 0}
{"code": "static int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "GfxRadialShading::~GfxRadialShading() { }", "target": 0}
{"code": "static void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (is_guest_mode(vcpu))\n\t\treturn;\n\tif (!cpu_has_virtual_nmis()) {\n\t\tvmx->soft_vnmi_blocked = 1;\n\t\tvmx->vnmi_blocked_time = 0;\n\t}\n\t++vcpu->stat.nmi_injections;\n\tvmx->nmi_known_unmasked = false;\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}", "target": 0}
{"code": "static int spl_ptr_pqueue_zval_cmp(spl_ptr_heap_element a, spl_ptr_heap_element b, void* object TSRMLS_DC) { \n\tzval result;\n\tzval **a_priority_pp = spl_pqueue_extract_helper((zval **)&a, SPL_PQUEUE_EXTR_PRIORITY);\n\tzval **b_priority_pp = spl_pqueue_extract_helper((zval **)&b, SPL_PQUEUE_EXTR_PRIORITY);\n\tif ((!a_priority_pp) || (!b_priority_pp)) {\n\t\tzend_error(E_RECOVERABLE_ERROR, \"Unable to extract from the PriorityQueue node\");\n\t\treturn 0;\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\tif (object) {\n\t\tspl_heap_object *heap_object = (spl_heap_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t\tif (heap_object->fptr_cmp) {\n\t\t\tlong lval = 0;\n\t\t\tif (spl_ptr_heap_cmp_cb_helper((zval *)object, heap_object, *a_priority_pp, *b_priority_pp, &lval TSRMLS_CC) == FAILURE) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn lval;\n\t\t}\n\t}\n\tINIT_ZVAL(result);\n\tcompare_function(&result, *a_priority_pp, *b_priority_pp TSRMLS_CC);\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "void PasswordAutofillAgent::PasswordValueGatekeeper::OnUserGesture() {\n  was_user_gesture_seen_ = true;\n  for (blink::WebInputElement& element : elements_)\n    ShowValue(&element);\n  elements_.clear();\n}", "target": 0}
{"code": "PassRefPtr<HTMLInputElement> HTMLInputElement::create(Document& document, HTMLFormElement* form, bool createdByParser)\n{\n    RefPtr<HTMLInputElement> inputElement = adoptRef(new HTMLInputElement(document, form, createdByParser));\n    inputElement->ensureUserAgentShadowRoot();\n    return inputElement.release();\n}", "target": 0}
{"code": "static void nvme_set_smart_warning(Object *obj, Visitor *v, const char *name,\n                                   void *opaque, Error **errp)\n{\n    NvmeCtrl *n = NVME(obj);\n    uint8_t value, old_value, cap = 0, index, event;\n    if (!visit_type_uint8(v, name, &value, errp)) {\n        return;\n    }\n    cap = NVME_SMART_SPARE | NVME_SMART_TEMPERATURE | NVME_SMART_RELIABILITY\n          | NVME_SMART_MEDIA_READ_ONLY | NVME_SMART_FAILED_VOLATILE_MEDIA;\n    if (NVME_CAP_PMRS(ldq_le_p(&n->bar.cap))) {\n        cap |= NVME_SMART_PMR_UNRELIABLE;\n    }\n    if ((value & cap) != value) {\n        error_setg(errp, \"unsupported smart critical warning bits: 0x%x\",\n                   value & ~cap);\n        return;\n    }\n    old_value = n->smart_critical_warning;\n    n->smart_critical_warning = value;\n    for (index = 0; index < NVME_SMART_WARN_MAX; index++) {\n        event = 1 << index;\n        if (value & ~old_value & event)\n            nvme_smart_event(n, event);\n    }\n}", "target": 0}
{"code": "static struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}", "target": 0}
{"code": "static bool vma_has_reserves(struct vm_area_struct *vma, long chg)\n{\n\tif (vma->vm_flags & VM_NORESERVE) {\n\t\tif (vma->vm_flags & VM_MAYSHARE && chg == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tif (vma->vm_flags & VM_MAYSHARE) {\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\tif (is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tif (chg)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void kvm_ioapic_update_eoi(struct kvm *kvm, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}", "target": 0}
{"code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n    njs_assert(array->object.fast_array);\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n    size = (uint64_t) prepend + array->length + append;\n    if (size < 16) {\n        size *= 2;\n    } else {\n        size += size / 2;\n    }\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n    array->size = size;\n    old = array->data;\n    array->data = start;\n    start += prepend;\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n    array->start = start;\n    if (old != NULL) {\n        njs_mp_free(vm->mem_pool, old);\n    }\n    return NJS_OK;\nmemory_error:\n    njs_memory_error(vm);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "auto CommonRegexParse(ExpressionContext* const expCtx,\n                      BSONElement expr,\n                      const VariablesParseState& vpsIn,\n                      StringData opName) {\n    uassert(51103,\n            str::stream() << opName\n                          << \" expects an object of named arguments but found: \" << expr.type(),\n            expr.type() == BSONType::Object);\n    struct {\n        boost::intrusive_ptr<Expression> input;\n        boost::intrusive_ptr<Expression> regex;\n        boost::intrusive_ptr<Expression> options;\n    } parsed;\n    for (auto&& elem : expr.embeddedObject()) {\n        const auto field = elem.fieldNameStringData();\n        if (field == \"input\"_sd) {\n            parsed.input = Expression::parseOperand(expCtx, elem, vpsIn);\n        } else if (field == \"regex\"_sd) {\n            parsed.regex = Expression::parseOperand(expCtx, elem, vpsIn);\n        } else if (field == \"options\"_sd) {\n            parsed.options = Expression::parseOperand(expCtx, elem, vpsIn);\n        } else {\n            uasserted(31024,\n                      str::stream() << opName << \" found an unknown argument: \"\n                                    << elem.fieldNameStringData());\n        }\n    }\n    uassert(31022, str::stream() << opName << \" requires 'input' parameter\", parsed.input);\n    uassert(31023, str::stream() << opName << \" requires 'regex' parameter\", parsed.regex);\n    return parsed;\n}", "target": 0}
{"code": "bool HHVM_FUNCTION(array_walk_recursive,\n                   VRefParam input,\n                   const Variant& funcname,\n                   const Variant& userdata ) {\n  if (!input.isArray()) {\n    throw_expected_array_exception(\"array_walk_recursive\");\n    return false;\n  }\n  CallCtx ctx;\n  CallerFrame cf;\n  vm_decode_function(funcname, cf(), false, ctx);\n  if (ctx.func == NULL) {\n    return false;\n  }\n  PointerSet seen;\n  Variant var(input, Variant::WithRefBind{});\n  ArrayUtil::Walk(var, walk_func, &ctx, true, &seen, userdata);\n  return true;\n}", "target": 0}
{"code": "JSRetainPtr<JSStringRef> AccessibilityUIElement::accessibilityValue() const\n{\n    return JSStringCreateWithCharacters(0, 0);\n}", "target": 0}
{"code": "void AudioContext::removeMarkedAudioNodeOutput(AudioNodeOutput* output)\n{\n    ASSERT(isGraphOwner());\n    ASSERT(isMainThread());\n    m_dirtyAudioNodeOutputs.remove(output);\n}", "target": 0}
{"code": "  Error_Obj Parser::parse_error()\n  {\n    if (stack.back() != Scope::Root &&\n        stack.back() != Scope::Function &&\n        stack.back() != Scope::Mixin &&\n        stack.back() != Scope::Control &&\n        stack.back() != Scope::Rules) {\n      error(\"Illegal nesting: Only properties may be nested beneath properties.\");\n    }\n    return SASS_MEMORY_NEW(Error, pstate, parse_list(DELAYED));\n  }", "target": 0}
{"code": "callbacks_select_layer_row (gint rowIndex)\n{\n\tGtkTreeSelection *selection;\n\tGtkTreeIter iter;\n\tGtkListStore *list_store = (GtkListStore *) gtk_tree_view_get_model\n\t\t\t((GtkTreeView *) screen.win.layerTree);\n\tselection = gtk_tree_view_get_selection((GtkTreeView *) screen.win.layerTree);\n\tif (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(list_store),\n\t\t\t\t&iter, NULL, rowIndex)) {\n\t\tgtk_tree_selection_select_iter (selection, &iter);\n\t}\n}", "target": 0}
{"code": "static int zipfileDisconnect(sqlite3_vtab *pVtab){\n  zipfileCleanupTransaction((ZipfileTab*)pVtab);\n  sqlite3_free(pVtab);\n  return SQLITE_OK;\n}", "target": 0}
{"code": "void shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}", "target": 0}
{"code": "static inline void encode_createmode(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tstruct nfs_client *clp;\n\tp = reserve_space(xdr, 4);\n\tswitch(arg->open_flags & O_EXCL) {\n\tcase 0:\n\t\t*p = cpu_to_be32(NFS4_CREATE_UNCHECKED);\n\t\tencode_attrs(xdr, arg->u.attrs, arg->server);\n\t\tbreak;\n\tdefault:\n\t\tclp = arg->server->nfs_client;\n\t\tif (clp->cl_mvops->minor_version > 0) {\n\t\t\tif (nfs4_has_persistent_session(clp)) {\n\t\t\t\t*p = cpu_to_be32(NFS4_CREATE_GUARDED);\n\t\t\t\tencode_attrs(xdr, arg->u.attrs, arg->server);\n\t\t\t} else {\n\t\t\t\tstruct iattr dummy;\n\t\t\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE4_1);\n\t\t\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\t\t\tdummy.ia_valid = 0;\n\t\t\t\tencode_attrs(xdr, &dummy, arg->server);\n\t\t\t}\n\t\t} else {\n\t\t\t*p = cpu_to_be32(NFS4_CREATE_EXCLUSIVE);\n\t\t\tencode_nfs4_verifier(xdr, &arg->u.verifier);\n\t\t}\n\t}\n}", "target": 0}
{"code": "  Definition_Obj Parser::parse_definition(Definition::Type which_type)\n  {\n    std::string which_str(lexed);\n    if (!lex< identifier >()) error(\"invalid name in \" + which_str + \" definition\");\n    std::string name(Util::normalize_underscores(lexed));\n    if (which_type == Definition::FUNCTION && (name == \"and\" || name == \"or\" || name == \"not\"))\n    { error(\"Invalid function name \\\"\" + name + \"\\\".\"); }\n    ParserState source_position_of_def = pstate;\n    Parameters_Obj params = parse_parameters();\n    if (which_type == Definition::MIXIN) stack.push_back(Scope::Mixin);\n    else stack.push_back(Scope::Function);\n    Block_Obj body = parse_block();\n    stack.pop_back();\n    return SASS_MEMORY_NEW(Definition, source_position_of_def, name, params, body, which_type);\n  }", "target": 0}
{"code": "nl80211_send_cqm_rssi_notify(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev,\n\t\t\t     enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *pinfoattr;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "int mod_wstunnel_frame_recv(handler_ctx *hctx) {\n  #ifdef _MOD_WEBSOCKET_SPEC_RFC_6455_\n    if (hctx->hybivers >= 8) return recv_rfc_6455(hctx);\n  #endif \n  #ifdef _MOD_WEBSOCKET_SPEC_IETF_00_\n    if (0 == hctx->hybivers) return recv_ietf_00(hctx);\n  #endif \n    return -1;\n}", "target": 0}
{"code": "static void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\tr = kvm_arch_hardware_enable(NULL);\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tprintk(KERN_INFO \"kvm: enabling virtualization on \"\n\t\t\t\t \"CPU%d failed\\n\", cpu);\n\t}\n}", "target": 0}
{"code": "fbCombineDisjointOutC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineDisjointGeneralC (dest, src, mask, width, CombineAOut);\n}", "target": 0}
{"code": "gsd_xrandr_manager_apply_configuration (GsdXrandrManager *manager,\n                                        GError          **error)\n{\n        return try_to_apply_intended_configuration (manager, NULL, GDK_CURRENT_TIME, error);\n}", "target": 0}
{"code": "size_t avrcp_handle_vendor_reject(uint8_t *code, uint8_t *operands)\n{\n\tstruct avrcp_header *pdu = (void *) operands;\n\tuint32_t company_id = get_company_id(pdu->company_id);\n\t*code = AVC_CTYPE_REJECTED;\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INTERNAL_ERROR;\n\tDBG(\"rejecting AVRCP PDU 0x%02X, company 0x%06X len 0x%04X\",\n\t\t\tpdu->pdu_id, company_id, ntohs(pdu->params_len));\n\treturn AVRCP_HEADER_LENGTH + 1;\n}", "target": 0}
{"code": "acl_fetch_shdr_val(struct proxy *px, struct session *l4, void *l7, int dir,\n\t\t   struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->rsp.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\treturn acl_fetch_hdr_val(px, l4, txn, txn->rsp.sol, expr, test);\n}", "target": 0}
{"code": "AttachOutputGPU(ScreenPtr pScreen, ScreenPtr new)\n{\n    assert(new->isGPU);\n    xorg_list_add(&new->output_head, &pScreen->output_slave_list);\n    new->current_master = pScreen;\n}", "target": 0}
{"code": "void ExtensionPrefs::SetBrowserActionVisibility(const Extension* extension,\n                                                bool visible) {\n  if (GetBrowserActionVisibility(extension) == visible)\n    return;\n  UpdateExtensionPref(extension->id(), kBrowserActionVisible,\n                      Value::CreateBooleanValue(visible));\n  NotificationService::current()->Notify(\n      NotificationType::EXTENSION_BROWSER_ACTION_VISIBILITY_CHANGED,\n      Source<ExtensionPrefs>(this),\n      Details<const Extension>(extension));\n}", "target": 0}
{"code": "static inline struct nlattr *nla_find_nested(struct nlattr *nla, int attrtype)\n{\n\treturn nla_find(nla_data(nla), nla_len(nla), attrtype);\n}", "target": 0}
{"code": "static inline s64 entity_key(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn se->vruntime - cfs_rq->min_vruntime;\n}", "target": 0}
{"code": "compare_votes_by_authority_id_(const void **_a, const void **_b)\n{\n  const networkstatus_t *a = *_a, *b = *_b;\n  return fast_memcmp(get_voter(a)->identity_digest,\n                get_voter(b)->identity_digest, DIGEST_LEN);\n}", "target": 0}
{"code": "ZEND_API double ZEND_FASTCALL zval_get_double_func(zval *op) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\treturn 0.0;\n\t\tcase IS_TRUE:\n\t\t\treturn 1.0;\n\t\tcase IS_RESOURCE:\n\t\t\treturn (double) Z_RES_HANDLE_P(op);\n\t\tcase IS_LONG:\n\t\t\treturn (double) Z_LVAL_P(op);\n\t\tcase IS_DOUBLE:\n\t\t\treturn Z_DVAL_P(op);\n\t\tcase IS_STRING:\n\t\t\treturn zend_strtod(Z_STRVAL_P(op), NULL);\n\t\tcase IS_ARRAY:\n\t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(op)) ? 1.0 : 0.0;\n\t\tcase IS_OBJECT:\n\t\t\t{\n\t\t\t\tzval dst;\n\t\t\t\tconvert_object_to_type(op, &dst, IS_DOUBLE, convert_to_double);\n\t\t\t\tif (Z_TYPE(dst) == IS_DOUBLE) {\n\t\t\t\t\treturn Z_DVAL(dst);\n\t\t\t\t} else {\n\t\t\t\t\treturn 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\top = Z_REFVAL_P(op);\n\t\t\tgoto try_again;\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n\treturn 0.0;\n}", "target": 0}
{"code": "void RenderView::OnExtensionMessageInvoke(const std::string& function_name,\n                                          const ListValue& args,\n                                          bool requires_incognito_access,\n                                          const GURL& event_url) {\n  RendererExtensionBindings::Invoke(\n      function_name, args, this, requires_incognito_access, event_url);\n}", "target": 0}
{"code": "lt_argz_insert (char **pargz, size_t *pargz_len, char *before,\n\t\tconst char *entry)\n{\n  error_t error;\n  if (before)\n    error = argz_insert (pargz, pargz_len, before, entry);\n  else\n    error = argz_append (pargz, pargz_len, entry, 1 + strlen (entry));\n  if (error)\n    {\n      switch (error)\n\t{\n\tcase ENOMEM:\n\t  LT__SETERROR (NO_MEMORY);\n\t  break;\n\tdefault:\n\t  LT__SETERROR (UNKNOWN);\n\t  break;\n\t}\n      return 1;\n    }\n  return 0;\n}", "target": 0}
{"code": "static void nasm_fputs(const char *line, FILE * outfile)\n{\n    if (outfile) {\n        fputs(line, outfile);\n        putc('\\n', outfile);\n    } else\n        puts(line);\n}", "target": 0}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_line(const CImg<t>& points,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const bool init_hatch=true) {\n      if (is_empty() || !points || points._width<2) return *this;\n      bool ninit_hatch = init_hatch;\n      switch (points._height) {\n      case 0 : case 1 :\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_line(): Invalid specified point set (%u,%u,%u,%u,%p).\",\n                                    cimg_instance,\n                                    points._width,points._height,points._depth,points._spectrum,points._data);\n      case 2 : {\n        const int x0 = (int)points(0,0), y0 = (int)points(0,1);\n        int ox = x0, oy = y0;\n        for (unsigned int i = 1; i<points._width; ++i) {\n          const int x = (int)points(i,0), y = (int)points(i,1);\n          draw_line(ox,oy,x,y,color,opacity,pattern,ninit_hatch);\n          ninit_hatch = false;\n          ox = x; oy = y;\n        }\n      } break;\n      default : {\n        const int x0 = (int)points(0,0), y0 = (int)points(0,1), z0 = (int)points(0,2);\n        int ox = x0, oy = y0, oz = z0;\n        for (unsigned int i = 1; i<points._width; ++i) {\n          const int x = (int)points(i,0), y = (int)points(i,1), z = (int)points(i,2);\n          draw_line(ox,oy,oz,x,y,z,color,opacity,pattern,ninit_hatch);\n          ninit_hatch = false;\n          ox = x; oy = y; oz = z;\n        }\n      }\n      }\n      return *this;", "target": 0}
{"code": "TEST(SegmentSumOpModelTest, Int32Test_ThreeDimensions) {\n  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2, 1}},\n                                   {TensorType_INT32, {3}});\n  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 0, 1});\n  model.Invoke();\n  EXPECT_THAT(model.GetOutput(), ElementsAreArray({4, 6, 5, 6}));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAreArray({2, 2, 1}));\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ContainedOrPushdownIndexedExpr) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(\n        fromjson(\"{$expr: {$and: [{$eq: ['$d', 'd']}, {$eq: ['$a', 'a']}]},\"\n                 \"$or: [{b: 'b'}, {b: 'c'}]}\"));\n    assertNumSolutions(3);\n    assertSolutionExists(\n        \"{fetch: {node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {a: 1, b: 1}, filter: null, bounds: {a: [['a', 'a', true, true]], b: \"\n        \"[['b', 'b', true, true]]}}},\"\n        \"{ixscan: {pattern: {a: 1, b: 1}, filter: null, bounds: {a: [['a', 'a', true, true]], b: \"\n        \"[['c', 'c', true, true]]}}}]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, filter: null,\"\n        \"bounds: {a: [['a', 'a', true, true]], b: [['MinKey', 'MaxKey', true, true]]}}}}}\");\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "ZEND_METHOD(CURLFile, __wakeup)\n{\n\tzval *_this = getThis();\n\tzend_unset_property(curl_CURLFile_class, _this, \"name\", sizeof(\"name\")-1 TSRMLS_CC);\n\tzend_update_property_string(curl_CURLFile_class, _this, \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n\tzend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n}", "target": 0}
{"code": "bool ScrollAnchor::ComputeScrollAnchorDisablingStyleChanged() {\n  LayoutObject* current = AnchorObject();\n  if (!current)\n    return false;\n  LayoutObject* scroller_box = ScrollerLayoutBox(scroller_);\n  while (true) {\n    DCHECK(current);\n    if (current->ScrollAnchorDisablingStyleChanged())\n      return true;\n    if (current == scroller_box)\n      return false;\n    current = current->Parent();\n  }\n}", "target": 0}
{"code": "void PasswordAutofillAgent::ClearPreview(\n    blink::WebInputElement* username,\n    blink::WebInputElement* password) {\n  if (!username->isNull() && !username->suggestedValue().isEmpty()) {\n    username->setSuggestedValue(blink::WebString());\n    username->setAutofilled(was_username_autofilled_);\n    username->setSelectionRange(username_query_prefix_.length(),\n                                username->value().length());\n  }\n  if (!password->suggestedValue().isEmpty()) {\n      password->setSuggestedValue(blink::WebString());\n      password->setAutofilled(was_password_autofilled_);\n  }\n}", "target": 0}
{"code": "static inline int doGetChar(JPXStreamPrivate* priv) {\n  const int result = doLookChar(priv);\n  if (++priv->ccounter == priv->ncomps) {\n    priv->ccounter = 0;\n    ++priv->counter;\n  }\n  return result;\n}", "target": 0}
{"code": "void nfs_fattr_init_names(struct nfs_fattr *fattr,\n\t\tstruct nfs4_string *owner_name,\n\t\tstruct nfs4_string *group_name)\n{\n\tfattr->owner_name = owner_name;\n\tfattr->group_name = group_name;\n}", "target": 0}
{"code": "    std::ostream& DateValue::write(std::ostream& os) const\n    {\n        std::ios::fmtflags f( os.flags() );\n        os << date_.year << '-' << std::right\n           << std::setw(2) << std::setfill('0') << date_.month << '-'\n           << std::setw(2) << std::setfill('0') << date_.day;\n        os.flags(f);\n        return os;\n    }", "target": 0}
{"code": "ns_client_settimeout(ns_client_t *client, unsigned int seconds) {\n\tisc_result_t result;\n\tisc_interval_t interval;\n\tisc_interval_set(&interval, seconds, 0);\n\tresult = isc_timer_reset(client->timer, isc_timertype_once, NULL,\n\t\t\t\t &interval, false);\n\tclient->timerset = true;\n\tif (result != ISC_R_SUCCESS) {\n\t\tns_client_log(client, NS_LOGCATEGORY_CLIENT,\n\t\t\t      NS_LOGMODULE_CLIENT, ISC_LOG_ERROR,\n\t\t\t      \"setting timeout: %s\",\n\t\t\t      isc_result_totext(result));\n\t}\n}", "target": 0}
{"code": "onig_builtin_error(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int n;\n  OnigValue val;\n  r = onig_get_arg_by_callout_args(args, 0, 0, &val);\n  if (r != ONIG_NORMAL) return r;\n  n = (int )val.l;\n  if (n >= 0) {\n    n = ONIGERR_INVALID_CALLOUT_BODY;\n  }\n  return n;\n}", "target": 0}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static int _nfs4_proc_create_session(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs41_create_session_args args = {\n\t\t.client = clp,\n\t\t.cb_program = NFS4_CALLBACK,\n\t};\n\tstruct nfs41_create_session_res res = {\n\t\t.client = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\tnfs4_init_channel_attrs(&args);\n\targs.flags = (SESSION4_PERSIST | SESSION4_BACK_CHAN);\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (!status)\n\t\tstatus = nfs4_verify_channel_attrs(&args, session);\n\tif (!status) {\n\t\tclp->cl_seqid++;\n\t}\n\treturn status;\n}", "target": 0}
{"code": "void\nPerl__invlist_dump(pTHX_ PerlIO *file, I32 level,\n                         const char * const indent, SV* const invlist)\n{\n    UV start, end;\n    STRLEN count = 0;\n    PERL_ARGS_ASSERT__INVLIST_DUMP;\n    if (invlist_is_iterating(invlist)) {\n        Perl_dump_indent(aTHX_ level, file,\n             \"%sCan't dump inversion list because is in middle of iterating\\n\",\n             indent);\n        return;\n    }\n    invlist_iterinit(invlist);\n    while (invlist_iternext(invlist, &start, &end)) {\n\tif (end == UV_MAX) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                       \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. INFTY\\n\",\n                                   indent, (UV)count, start);\n\t}\n\telse if (end != start) {\n\t    Perl_dump_indent(aTHX_ level, file,\n                                    \"%s[%\" UVuf \"] 0x%04\" UVXf \" .. 0x%04\" UVXf \"\\n\",\n\t\t                indent, (UV)count, start,         end);\n\t}\n\telse {\n\t    Perl_dump_indent(aTHX_ level, file, \"%s[%\" UVuf \"] 0x%04\" UVXf \"\\n\",\n                                            indent, (UV)count, start);\n\t}\n        count += 2;\n    }", "target": 0}
{"code": "static ZipfileCsr *zipfileFindCursor(ZipfileTab *pTab, i64 iId){\n  ZipfileCsr *pCsr;\n  for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n    if( iId==pCsr->iId ) break;\n  }\n  return pCsr;\n}", "target": 0}
{"code": "  explicit DatabaseTaskBase(QuotaManager* manager)\n      : QuotaThreadTask(manager, manager->db_thread_),\n        manager_(manager),\n        database_(manager->database_.get()),\n        db_disabled_(false) {\n    DCHECK(manager_);\n    DCHECK(database_);\n  }", "target": 0}
{"code": "  AudioSourceProviderClientLockScope(HTMLMediaElement& element)\n      : client_(element.AudioSourceNode()) {\n    if (client_)\n      client_->lock();\n  }", "target": 0}
{"code": "static int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\treturn cfg80211_disconnect(rdev, dev, reason, true);\n}", "target": 0}
{"code": "  virtual NetworkIPConfigVector GetIPConfigs(const std::string& device_path,\n                                             std::string* hardware_address) {\n    hardware_address->clear();\n    return NetworkIPConfigVector();\n  }", "target": 0}
{"code": "static struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\tcoolkey_ops = *iso_drv->ops;\n\tcoolkey_ops.match_card = coolkey_match_card;\n\tcoolkey_ops.init = coolkey_init;\n\tcoolkey_ops.finish = coolkey_finish;\n\tcoolkey_ops.select_file =  coolkey_select_file; \n\tcoolkey_ops.get_challenge = coolkey_get_challenge;\n\tcoolkey_ops.read_binary = coolkey_read_binary;\n\tcoolkey_ops.write_binary = coolkey_write_binary;\n\tcoolkey_ops.set_security_env = coolkey_set_security_env;\n\tcoolkey_ops.restore_security_env = coolkey_restore_security_env;\n\tcoolkey_ops.compute_signature = coolkey_compute_crypt;\n\tcoolkey_ops.decipher =  coolkey_compute_crypt;\n\tcoolkey_ops.card_ctl = coolkey_card_ctl;\n\tcoolkey_ops.check_sw = coolkey_check_sw;\n\tcoolkey_ops.pin_cmd = coolkey_pin_cmd;\n\tcoolkey_ops.logout = coolkey_logout;\n\tcoolkey_ops.card_reader_lock_obtained = coolkey_card_reader_lock_obtained;\n\treturn &coolkey_drv;\n}", "target": 0}
{"code": "scoped_ptr<EdgeEffectBase> OverscrollControllerAndroid::CreateEdgeEffect() {\n  return CreateGlowEdgeEffect(&compositor_->GetResourceManager(), dpi_scale_);\n}", "target": 0}
{"code": "void WebContentsImpl::DidStartProvisionalLoadForFrame(\n    RenderViewHost* render_view_host,\n    int64 frame_id,\n    int64 parent_frame_id,\n    bool is_main_frame,\n    const GURL& url) {\n  bool is_error_page = (url.spec() == kUnreachableWebDataURL);\n  bool is_iframe_srcdoc = (url.spec() == kAboutSrcDocURL);\n  GURL validated_url(url);\n  RenderProcessHost* render_process_host =\n      render_view_host->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n  if (is_main_frame) {\n    DidChangeLoadProgress(0);\n    NavigationEntry* pending_entry = controller_.GetPendingEntry();\n    bool has_browser_initiated_pending_entry = pending_entry &&\n        !NavigationEntryImpl::FromNavigationEntry(pending_entry)->\n            is_renderer_initiated();\n    if (!has_browser_initiated_pending_entry && !is_error_page) {\n      NavigationEntryImpl* entry = NavigationEntryImpl::FromNavigationEntry(\n          controller_.CreateNavigationEntry(validated_url,\n                                            content::Referrer(),\n                                            content::PAGE_TRANSITION_LINK,\n                                            true ,\n                                            std::string(),\n                                            GetBrowserContext()));\n      entry->set_site_instance(\n          static_cast<SiteInstanceImpl*>(GetSiteInstance()));\n      controller_.SetPendingEntry(entry);\n      NotifyNavigationStateChanged(content::INVALIDATE_TYPE_URL);\n    }\n  }\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidStartProvisionalLoadForFrame(frame_id, parent_frame_id,\n                    is_main_frame, validated_url, is_error_page,\n                    is_iframe_srcdoc, render_view_host));\n  if (is_main_frame) {\n    FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                      ProvisionalChangeToMainFrameUrl(validated_url,\n                                                      render_view_host));\n  }\n}", "target": 0}
{"code": "double RemoteFsDevice::usedCapacity()\n{\n    if (cacheProgress>-1) {\n        return (cacheProgress*1.0)/100.0;\n    }\n    if (!isConnected()) {\n        return -1.0;\n    }\n    spaceInfo.setPath(mountPoint(details, false));\n    if (isOldSshfs()) {\n        return -1.0;\n    }\n    return spaceInfo.size()>0 ? (spaceInfo.used()*1.0)/(spaceInfo.size()*1.0) : -1.0;\n}", "target": 0}
{"code": "void print_vma_addr(char *prefix, unsigned long ip)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tif (preempt_count())\n\t\treturn;\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, ip);\n\tif (vma && vma->vm_file) {\n\t\tstruct file *f = vma->vm_file;\n\t\tchar *buf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (buf) {\n\t\t\tchar *p, *s;\n\t\t\tp = d_path(&f->f_path, buf, PAGE_SIZE);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"?\";\n\t\t\ts = strrchr(p, '/');\n\t\t\tif (s)\n\t\t\t\tp = s+1;\n\t\t\tprintk(\"%s%s[%lx+%lx]\", prefix, p,\n\t\t\t\t\tvma->vm_start,\n\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\tfree_page((unsigned long)buf);\n\t\t}\n\t}\n\tup_read(&current->mm->mmap_sem);\n}", "target": 0}
{"code": "ZEND_API void ZEND_FASTCALL convert_to_boolean(zval *op) \n{\n\tint tmp;\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_FALSE:\n\t\tcase IS_TRUE:\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tZVAL_FALSE(op);\n\t\t\tbreak;\n\t\tcase IS_RESOURCE: {\n\t\t\t\tzend_long l = (Z_RES_HANDLE_P(op) ? 1 : 0);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tZVAL_BOOL(op, l);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_BOOL(op, Z_LVAL_P(op) ? 1 : 0);\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\tZVAL_BOOL(op, Z_DVAL_P(op) ? 1 : 0);\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\t{\n\t\t\t\tzend_string *str = Z_STR_P(op);\n\t\t\t\tif (ZSTR_LEN(str) == 0\n\t\t\t\t\t|| (ZSTR_LEN(str) == 1 && ZSTR_VAL(str)[0] == '0')) {\n\t\t\t\t\tZVAL_FALSE(op);\n\t\t\t\t} else {\n\t\t\t\t\tZVAL_TRUE(op);\n\t\t\t\t}\n\t\t\t\tzend_string_release_ex(str, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\ttmp = (zend_hash_num_elements(Z_ARRVAL_P(op))?1:0);\n\t\t\tzval_ptr_dtor(op);\n\t\t\tZVAL_BOOL(op, tmp);\n\t\t\tbreak;\n\t\tcase IS_OBJECT:\n\t\t\t{\n\t\t\t\tzval dst;\n\t\t\t\tconvert_object_to_type(op, &dst, _IS_BOOL, convert_to_boolean);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tif (Z_TYPE_INFO(dst) == IS_FALSE || Z_TYPE_INFO(dst) == IS_TRUE) {\n\t\t\t\t\tZ_TYPE_INFO_P(op) = Z_TYPE_INFO(dst);\n\t\t\t\t} else {\n\t\t\t\t\tZVAL_TRUE(op);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\tzend_unwrap_reference(op);\n\t\t\tgoto try_again;\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n}", "target": 0}
{"code": "const char *v4l2_norm_to_name(v4l2_std_id id)\n{\n\tu32 myid = id;\n\tint i;\n\tBUG_ON(myid != id);\n\tfor (i = 0; standards[i].std; i++)\n\t\tif (myid == standards[i].std)\n\t\t\tbreak;\n\treturn standards[i].descr;\n}", "target": 0}
{"code": "onigenc_always_true_is_allowed_reverse_match(const UChar* s   ARG_UNUSED,\n\t\t\t\t\t     const UChar* end ARG_UNUSED,\n\t\t\t\t\t     OnigEncoding enc ARG_UNUSED)\n{\n  return TRUE;\n}", "target": 0}
{"code": "MagickExport double ExpandAffine(const AffineMatrix *affine)\n{\n  assert(affine != (const AffineMatrix *) NULL);\n  return(sqrt(fabs(affine->sx*affine->sy-affine->rx*affine->ry)));\n}", "target": 0}
{"code": "static void __exit netif_exit(void)\n{\n\txenbus_unregister_driver(&netfront_driver);\n}", "target": 0}
{"code": "static void date_period_it_invalidate_current(zend_object_iterator *iter TSRMLS_DC)\n{\n\tdate_period_it *iterator = (date_period_it *)iter;\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}", "target": 0}
{"code": "ospf_make_ls_req (struct ospf_neighbor *nbr, struct stream *s)\n{\n  struct ospf_lsa *lsa;\n  u_int16_t length = OSPF_LS_REQ_MIN_SIZE;\n  unsigned long delta = stream_get_endp(s)+12;\n  struct route_table *table;\n  struct route_node *rn;\n  int i;\n  struct ospf_lsdb *lsdb;\n  lsdb = &nbr->ls_req;\n  for (i = OSPF_MIN_LSA; i < OSPF_MAX_LSA; i++)\n    {\n      table = lsdb->type[i].db;\n      for (rn = route_top (table); rn; rn = route_next (rn))\n\tif ((lsa = (rn->info)) != NULL)\n\t  if (ospf_make_ls_req_func (s, &length, delta, nbr, lsa) == 0)\n\t    {\n\t      route_unlock_node (rn);\n\t      break;\n\t    }\n    }\n  return length;\n}", "target": 0}
{"code": "static sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (packet) {\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\t\tabort->skb->sk = ep->base.sk;\n\t\tsctp_packet_append_chunk(packet, abort);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "bool FrameLoader::willLoadMediaElementURL(KURL& url)\n{\n    ResourceRequest request(url);\n    unsigned long identifier;\n    ResourceError error;\n    requestFromDelegate(request, identifier, error);\n    notifier()->sendRemainingDelegateMessages(m_documentLoader.get(), identifier, ResourceResponse(url, String(), -1, String(), String()), 0, -1, -1, error);\n    url = request.url();\n    return error.isNull();\n}", "target": 0}
{"code": "bool Document::TasksNeedSuspension() {\n  Page* page = GetPage();\n  return page && page->Paused();\n}", "target": 0}
{"code": "previously_transported(address_item *addr, BOOL testing)\n{\n(void)string_format(big_buffer, big_buffer_size, \"%s/%s\",\n  addr->unique + (testflag(addr, af_homonym)? 3:0), addr->transport->name);\nif (tree_search(tree_nonrecipients, big_buffer) != 0)\n  {\n  DEBUG(D_deliver|D_route|D_transport)\n    debug_printf(\"%s was previously delivered (%s transport): discarded\\n\",\n    addr->address, addr->transport->name);\n  if (!testing) child_done(addr, tod_stamp(tod_log));\n  return TRUE;\n  }\nreturn FALSE;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitSwitch(Switch* curr) {\n  BYN_TRACE(\"zz node: Switch\\n\");\n  curr->condition = popNonVoidExpression();\n  auto numTargets = getU32LEB();\n  BYN_TRACE(\"targets: \" << numTargets << std::endl);\n  for (size_t i = 0; i < numTargets; i++) {\n    curr->targets.push_back(getBreakTarget(getU32LEB()).name);\n  }\n  auto defaultTarget = getBreakTarget(getU32LEB());\n  curr->default_ = defaultTarget.name;\n  BYN_TRACE(\"default: \" << curr->default_ << \"\\n\");\n  if (defaultTarget.type.isConcrete()) {\n    curr->value = popTypedExpression(defaultTarget.type);\n  }\n  curr->finalize();\n}", "target": 0}
{"code": "int sql_auxprop_plug_init(const sasl_utils_t *utils,\n\t\t\t  int max_version,\n\t\t\t  int *out_version,\n\t\t\t  sasl_auxprop_plug_t **plug,\n\t\t\t  const char *plugname __attribute__((unused))) \n{\n    sql_settings_t *settings;\n    if (!out_version || !plug) return SASL_BADPARAM;\n    if (max_version < SASL_AUXPROP_PLUG_VERSION) return SASL_BADVERS;\n    *out_version = SASL_AUXPROP_PLUG_VERSION;\n    *plug = &sql_auxprop_plugin;\n    settings = (sql_settings_t *) utils->malloc(sizeof(sql_settings_t));\n    if (!settings) {\n\tMEMERROR(utils);\n\treturn SASL_NOMEM;\n    }\n    memset(settings, 0, sizeof(sql_settings_t));\n    sql_get_settings(utils, settings);\n    if (!settings->sql_engine->name) return SASL_NOMECH;\n    if (!sql_exists(settings->sql_select)) {\n\tutils->log(utils->conn, SASL_LOG_ERR, \"sql_select option missing\");\n\tutils->free(settings);\t\n\treturn SASL_NOMECH;\n    }\n    utils->log(utils->conn, SASL_LOG_DEBUG,\n\t       \"sql auxprop plugin using %s engine\\n\",\n\t       settings->sql_engine->name);\n    sql_auxprop_plugin.glob_context = settings;\n    return SASL_OK;\n}", "target": 0}
{"code": "long kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + ARRAY_SIZE(emulated_msrs);\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t ARRAY_SIZE(emulated_msrs) * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "static bool hugetlb_cma_page(struct page *page, unsigned int order)\n{\n\treturn false;\n}", "target": 0}
{"code": "static int selinux_sb_show_options(struct seq_file *m, struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tint rc;\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\tif (!selinux_initialized(&selinux_state))\n\t\treturn 0;\n\tif (sbsec->flags & FSCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, FSCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & CONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, CONTEXT_STR);\n\t\trc = show_sid(m, sbsec->mntpoint_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & DEFCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, DEFCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->def_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & ROOTCONTEXT_MNT) {\n\t\tstruct dentry *root = sbsec->sb->s_root;\n\t\tstruct inode_security_struct *isec = backing_inode_security(root);\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, ROOTCONTEXT_STR);\n\t\trc = show_sid(m, isec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & SBLABEL_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, SECLABEL_STR);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void print_verification_stats(struct bpf_verifier_env *env)\n{\n\tint i;\n\tif (env->log.level & BPF_LOG_STATS) {\n\t\tverbose(env, \"verification time %lld usec\\n\",\n\t\t\tdiv_u64(env->verification_time, 1000));\n\t\tverbose(env, \"stack depth \");\n\t\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\t\tu32 depth = env->subprog_info[i].stack_depth;\n\t\t\tverbose(env, \"%d\", depth);\n\t\t\tif (i + 1 < env->subprog_cnt)\n\t\t\t\tverbose(env, \"+\");\n\t\t}\n\t\tverbose(env, \"\\n\");\n\t}\n\tverbose(env, \"processed %d insns (limit %d) max_states_per_insn %d \"\n\t\t\"total_states %d peak_states %d mark_read %d\\n\",\n\t\tenv->insn_processed, BPF_COMPLEXITY_LIMIT_INSNS,\n\t\tenv->max_states_per_insn, env->total_states,\n\t\tenv->peak_states, env->longest_mark_read_walk);\n}", "target": 0}
{"code": "int usbredirparser_have_cap(struct usbredirparser *parser_pub, int cap)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    return usbredirparser_caps_get_cap(parser, parser->our_caps, cap);\n}", "target": 0}
{"code": "spnego_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                     const gss_buffer_t sasl_mech_name,\n                                     gss_OID *mech_type)\n{\n\tif (sasl_mech_name->length == SPNEGO_SASL_NAME_LEN &&\n\t    memcmp(sasl_mech_name->value, SPNEGO_SASL_NAME,\n\t\t   SPNEGO_SASL_NAME_LEN) == 0) {\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\treturn (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void cql_server::connection::write_response(foreign_ptr<std::unique_ptr<cql_server::response>>&& response, service_permit permit, cql_compression compression)\n{\n    _ready_to_respond = _ready_to_respond.then([this, compression, response = std::move(response), permit = std::move(permit)] () mutable {\n        auto message = response->make_message(_version, compression);\n        message.on_delete([response = std::move(response)] { });\n        return _write_buf.write(std::move(message)).then([this] {\n            return _write_buf.flush();\n        });\n    });\n}", "target": 0}
{"code": "int check_ctx_reg(struct bpf_verifier_env *env,\n\t\t  const struct bpf_reg_state *reg, int regno)\n{\n\tif (reg->off) {\n\t\tverbose(env, \"dereference of modified ctx ptr R%d off=%d disallowed\\n\",\n\t\t\tregno, reg->off);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"variable ctx access var_off=%s disallowed\\n\", tn_buf);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mm_answer_bsdauthrespond(int socket, Buffer *m)\n{\n\tchar *response;\n\tint authok;\n\tif (authctxt->as == 0)\n\t\tfatal(\"%s: no bsd auth session\", __func__);\n\tresponse = buffer_get_string(m, NULL);\n\tauthok = options.challenge_response_authentication &&\n\t    auth_userresponse(authctxt->as, response, 0);\n\tauthctxt->as = NULL;\n\tdebug3(\"%s: <%s> = <%d>\", __func__, response, authok);\n\txfree(response);\n\tbuffer_clear(m);\n\tbuffer_put_int(m, authok);\n\tdebug3(\"%s: sending authenticated: %d\", __func__, authok);\n\tmm_request_send(socket, MONITOR_ANS_BSDAUTHRESPOND, m);\n\tauth_method = \"bsdauth\";\n\treturn (authok != 0);\n}", "target": 0}
{"code": "static int hns_roce_modify_device(struct ib_device *ib_dev, int mask,\n\t\t\t\t  struct ib_device_modify *props)\n{\n\tunsigned long flags;\n\tif (mask & ~IB_DEVICE_MODIFY_NODE_DESC)\n\t\treturn -EOPNOTSUPP;\n\tif (mask & IB_DEVICE_MODIFY_NODE_DESC) {\n\t\tspin_lock_irqsave(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t\tmemcpy(ib_dev->node_desc, props->node_desc, NODE_DESC_SIZE);\n\t\tspin_unlock_irqrestore(&to_hr_dev(ib_dev)->sm_lock, flags);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void ModuleState::addConvertFloatToInt(FormatCode input, FormatCode output,\n\tconst _PCMInfo &inputMapping, const _PCMInfo &outputMapping)\n{\n\taddModule(new ConvertFloatToIntClip(input, output, inputMapping, outputMapping));\n}", "target": 0}
{"code": "sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)\n{\n\tvoid __user *p = (void __user *)arg;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tint ret;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tret = sg_ioctl_common(filp, sdp, sfp, cmd_in, p);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\treturn scsi_ioctl(sdp->device, cmd_in, p);\n}", "target": 0}
{"code": "static void rtnl_lock_unregistering_all(void)\n{\n\tstruct net *net;\n\tbool unregistering;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tadd_wait_queue(&netdev_unregistering_wq, &wait);\n\tfor (;;) {\n\t\tunregistering = false;\n\t\trtnl_lock();\n\t\tfor_each_net(net) {\n\t\t\tif (net->dev_unreg_count > 0) {\n\t\t\t\tunregistering = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!unregistering)\n\t\t\tbreak;\n\t\t__rtnl_unlock();\n\t\twait_woken(&wait, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&netdev_unregistering_wq, &wait);\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL add_function(zval *result, zval *op1, zval *op2) \n{\n\tif (add_function_fast(result, op1, op2) == SUCCESS) {\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn add_function_slow(result, op1, op2);\n\t}\n}", "target": 0}
{"code": "String XSSAuditor::decodedSnippetForName(const FilterTokenRequest& request)\n{\n    return fullyDecodeString(request.sourceTracker.sourceForToken(request.token), m_encoding).substring(0, request.token.name().size() + 1);\n}", "target": 0}
{"code": "bool FrameLoader::shouldReloadToHandleUnreachableURL(DocumentLoader* docLoader)\n{\n    KURL unreachableURL = docLoader->unreachableURL();\n    if (unreachableURL.isEmpty())\n        return false;\n    if (!isBackForwardLoadType(policyChecker()->loadType()))\n        return false;\n    DocumentLoader* compareDocumentLoader = 0;\n    if (policyChecker()->delegateIsDecidingNavigationPolicy() || policyChecker()->delegateIsHandlingUnimplementablePolicy())\n        compareDocumentLoader = m_policyDocumentLoader.get();\n    else if (m_delegateIsHandlingProvisionalLoadError)\n        compareDocumentLoader = m_provisionalDocumentLoader.get();\n    return compareDocumentLoader && unreachableURL == compareDocumentLoader->request().url();\n}", "target": 0}
{"code": "static int vhost_zerocopy_signal_used(struct vhost_net *net,\n\t\t\t\t      struct vhost_virtqueue *vq)\n{\n\tint i;\n\tint j = 0;\n\tfor (i = vq->done_idx; i != vq->upend_idx; i = (i + 1) % UIO_MAXIOV) {\n\t\tif (vq->heads[i].len == VHOST_DMA_FAILED_LEN)\n\t\t\tvhost_net_tx_err(net);\n\t\tif (VHOST_DMA_IS_DONE(vq->heads[i].len)) {\n\t\t\tvq->heads[i].len = VHOST_DMA_CLEAR_LEN;\n\t\t\tvhost_add_used_and_signal(vq->dev, vq,\n\t\t\t\t\t\t  vq->heads[i].id, 0);\n\t\t\t++j;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (j)\n\t\tvq->done_idx = i;\n\treturn j;\n}", "target": 0}
{"code": "static int domain_update_iommu_snooping(struct intel_iommu *skip)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint ret = 1;\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (iommu != skip) {\n\t\t\tif (!ecap_sc_support(iommu->ecap)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_intersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args ) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "static bool hasName(const HTMLToken& token, const QualifiedName& name)\n{\n    return threadSafeMatch(token.name(), name);\n}", "target": 0}
{"code": "void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}", "target": 0}
{"code": "void GfxPath::lineTo(double x, double y)\n{\n    if (justMoved || (n > 0 && subpaths[n - 1]->isClosed())) {\n        if (n >= size) {\n            size *= 2;\n            subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n        }\n        if (justMoved) {\n            subpaths[n] = new GfxSubpath(firstX, firstY);\n        } else {\n            subpaths[n] = new GfxSubpath(subpaths[n - 1]->getLastX(), subpaths[n - 1]->getLastY());\n        }\n        ++n;\n        justMoved = false;\n    }\n    subpaths[n - 1]->lineTo(x, y);\n}", "target": 0}
{"code": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n        if (n_monitors > n_windows) {\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        gs_window_cancel_unlock_request (GS_WINDOW (l->data));\n                        l = l->next;\n                }\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i);\n                }\n                gs_manager_request_unlock (manager);\n        } else {\n                gdk_x11_grab_server ();\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n                        GSList    *next = l->next;\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                g_hash_table_remove (manager->priv->jobs, l->data);\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                        l = next;\n                }\n                if (n_windows > n_monitors) {\n                        gs_manager_request_unlock (manager);\n                }\n                gdk_flush ();\n                gdk_x11_ungrab_server ();\n        }\n}", "target": 0}
{"code": "static int bnx2x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\tu64 ns;\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"PTP gettime called while the interface is down\\n\");\n\t\treturn -ENETDOWN;\n\t}\n\tns = timecounter_read(&bp->timecounter);\n\tDP(BNX2X_MSG_PTP, \"PTP gettime called, ns = %llu\\n\", ns);\n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}", "target": 0}
{"code": "archive_read_support_format_zip_seekable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip_seekable\");\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n#ifdef HAVE_COPYFILE_H\n\tzip->process_mac_extensions = 1;\n#endif\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_seekable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_seekable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_seekable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_seekable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "  libraw_iparams_t *libraw_get_iparams(libraw_data_t *lr)\n  {\n    if (!lr)\n      return NULL;\n    return &(lr->idata);\n  }", "target": 0}
{"code": "lib_do_one_event_core(argc, argv, self, is_ip)\n    int   argc;\n    VALUE *argv;\n    VALUE self;\n    int   is_ip;\n{\n    volatile VALUE vflags;\n    int flags;\n    int found_event;\n    if (!NIL_P(eventloop_thread)) {\n        rb_raise(rb_eRuntimeError, \"eventloop is already running\");\n    }\n    tcl_stubs_check();\n    if (rb_scan_args(argc, argv, \"01\", &vflags) == 0) {\n        flags = TCL_ALL_EVENTS | TCL_DONT_WAIT;\n    } else {\n        Check_Type(vflags, T_FIXNUM);\n        flags = FIX2INT(vflags);\n    }\n    if (rb_safe_level() >=1 && OBJ_TAINTED(vflags)) {\n      flags |= TCL_DONT_WAIT;\n    }\n    if (is_ip) {\n        struct tcltkip *ptr = get_ip(self);\n        if (deleted_ip(ptr)) {\n            return Qfalse;\n        }\n        if (Tcl_GetMaster(ptr->ip) != (Tcl_Interp*)NULL) {\n            flags |= TCL_DONT_WAIT;\n        }\n    }\n    found_event = Tcl_DoOneEvent(flags);\n    if (pending_exception_check0()) {\n        return Qfalse;\n    }\n    if (found_event) {\n        return Qtrue;\n    } else {\n        return Qfalse;\n    }\n}", "target": 0}
{"code": "static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}", "target": 0}
{"code": "void DelegatedFrameHost::CheckResizeLock() {\n  if (!resize_lock_ ||\n      resize_lock_->expected_size() != current_frame_size_in_dip_)\n    return;\n  resize_lock_->UnlockCompositor();\n}", "target": 0}
{"code": "match_end(VALUE match, VALUE n)\n{\n    int i = match_backref_number(match, n);\n    struct re_registers *regs = RMATCH_REGS(match);\n    match_check(match);\n    if (i < 0 || regs->num_regs <= i)\n\trb_raise(rb_eIndexError, \"index %d out of matches\", i);\n    if (BEG(i) < 0)\n\treturn Qnil;\n    update_char_offset(match);\n    return INT2FIX(RMATCH(match)->rmatch->char_offset[i].end);\n}", "target": 0}
{"code": "hugetlb_resv_map_add(struct resv_map *map, struct file_region *rg, long from,\n\t\t     long to, struct hstate *h, struct hugetlb_cgroup *cg,\n\t\t     long *regions_needed)\n{\n\tstruct file_region *nrg;\n\tif (!regions_needed) {\n\t\tnrg = get_file_region_entry_from_cache(map, from, to);\n\t\trecord_hugetlb_cgroup_uncharge_info(cg, h, map, nrg);\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tcoalesce_file_region(map, nrg);\n\t} else\n\t\t*regions_needed += 1;\n\treturn to - from;\n}", "target": 0}
{"code": "void LibRaw::SetStandardIlluminants (unsigned makerIdx, const char* normModel) {\n  int i = -1;\n  int c;\n  if (!imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] &&\n      !imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0]) {\n    if (makerIdx == LIBRAW_CAMERAMAKER_Olympus) {\n      while (++i, imgdata.color.WBCT_Coeffs[i][0]) {\n        if (imgdata.color.WBCT_Coeffs[i][0] == 3000)\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][c] =\n                    imgdata.color.WBCT_Coeffs[i][c+1];\n        else if (imgdata.color.WBCT_Coeffs[i][0] == 6600)\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c] =\n                    imgdata.color.WBCT_Coeffs[i][c+1];\n      }\n    }\n  }\n  if (!imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] &&\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0])\n    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][c] =\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c];\n  if (!imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] &&\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0])\n    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c] =\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c];\n  return;\n}", "target": 0}
{"code": "GF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "        virtual bool valid() const { return valid_; }", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsSmoothToneCurve(cmsToneCurve* Tab, cmsFloat64Number lambda)\n{\n    cmsFloat32Number w[MAX_NODES_IN_CURVE], y[MAX_NODES_IN_CURVE], z[MAX_NODES_IN_CURVE];\n    int i, nItems, Zeros, Poles;\n    if (Tab == NULL) return FALSE;\n    if (cmsIsToneCurveLinear(Tab)) return TRUE; \n    nItems = Tab -> nEntries;\n    if (nItems >= MAX_NODES_IN_CURVE) {\n        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: too many points.\");\n        return FALSE;\n    }\n    memset(w, 0, nItems * sizeof(cmsFloat32Number));\n    memset(y, 0, nItems * sizeof(cmsFloat32Number));\n    memset(z, 0, nItems * sizeof(cmsFloat32Number));\n    for (i=0; i < nItems; i++)\n    {\n        y[i+1] = (cmsFloat32Number) Tab -> Table16[i];\n        w[i+1] = 1.0;\n    }\n    if (!smooth2(Tab ->InterpParams->ContextID, w, y, z, (cmsFloat32Number) lambda, nItems)) return FALSE;\n    Zeros = Poles = 0;\n    for (i=nItems; i > 1; --i) {\n        if (z[i] == 0.) Zeros++;\n        if (z[i] >= 65535.) Poles++;\n        if (z[i] < z[i-1]) {\n            cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Non-Monotonic.\");\n            return FALSE;\n        }\n    }\n    if (Zeros > (nItems / 3)) {\n        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Degenerated, mostly zeros.\");\n        return FALSE;\n    }\n    if (Poles > (nItems / 3)) {\n        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Degenerated, mostly poles.\");\n        return FALSE;\n    }\n    for (i=0; i < nItems; i++) {\n        Tab -> Table16[i] = _cmsQuickSaturateWord(z[i+1]);\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static struct kmem_cache *get_slab(size_t size, gfp_t flags)\n{\n\tint index;\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\t\tindex = size_index[(size - 1) / 8];\n\t} else\n\t\tindex = fls(size - 1);\n#ifdef CONFIG_ZONE_DMA\n\tif (unlikely((flags & SLUB_DMA)))\n\t\treturn dma_kmalloc_cache(index, flags);\n#endif\n\treturn &kmalloc_caches[index];\n}", "target": 0}
{"code": "void paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "asmlinkage __visible void __sched notrace preempt_schedule_notrace(void)\n{\n\tenum ctx_state prev_ctx;\n\tif (likely(!preemptible()))\n\t\treturn;\n\tdo {\n\t\tpreempt_disable_notrace();\n\t\tprev_ctx = exception_enter();\n\t\t__schedule(true);\n\t\texception_exit(prev_ctx);\n\t\tpreempt_enable_no_resched_notrace();\n\t} while (need_resched());\n}", "target": 0}
{"code": "test_info_zip_ux(void)\n{\n\tconst char *refname = \"test_read_format_zip_ux.zip\";\n\tstruct archive *a;\n\tchar *p;\n\tsize_t s;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 10240));\n\tverify_info_zip_ux(a, 1);\n\tp = slurpfile(&s, refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, read_open_memory(a, p, s, 108));\n\tverify_info_zip_ux(a, 0);\n\tfree(p);\n}", "target": 0}
{"code": "static ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_TYPESAFE_BY_RCU));\n}", "target": 0}
{"code": "static int pfkey_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct pfkey_sock *pfk;\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != PF_KEY_V2)\n\t\treturn -EPROTONOSUPPORT;\n\tsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tpfk = pfkey_sk(sk);\n\tmutex_init(&pfk->dump_lock);\n\tsock->ops = &pfkey_ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_KEY;\n\tsk->sk_destruct = pfkey_sock_destruct;\n\tatomic_inc(&net_pfkey->socks_nr);\n\tpfkey_insert(sk);\n\treturn 0;\n}", "target": 0}
{"code": "void rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force)\n{\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\tint zot_me = 0;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr) {\n\t\tpr_debug(\"rds: trying to unuse MR with unknown r_key %u!\\n\",\n\t\t\t r_key);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\treturn;\n\t}\n\tif (mr->r_use_once || force) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tzot_me = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (mr->r_trans->sync_mr)\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_FROM_DEVICE);\n\tif (zot_me) {\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t}\n}", "target": 0}
{"code": "int BN_abs_is_word(const BIGNUM *a, const BN_ULONG w)\n{\n    return ((a->top == 1) && (a->d[0] == w)) || ((w == 0) && (a->top == 0));\n}", "target": 0}
{"code": "void __kmemcg_cache_deactivate(struct kmem_cache *s)\n{\n\tslub_set_cpu_partial(s, 0);\n\ts->min_partial = 0;\n}", "target": 0}
{"code": "int sha1sum_file(char *fnam, unsigned char *digest)\n{\n\tchar *buf;\n\tint ret;\n\tFILE *f;\n\tlong flen;\n\tif (!fnam)\n\t\treturn -1;\n\tf = fopen_cloexec(fnam, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Error opening template\");\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_END) < 0) {\n\t\tSYSERROR(\"Error seeking to end of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((flen = ftell(f)) < 0) {\n\t\tSYSERROR(\"Error telling size of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to start of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((buf = malloc(flen+1)) == NULL) {\n\t\tSYSERROR(\"Out of memory\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fread(buf, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Failure reading template\");\n\t\tfree(buf);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fclose(f) < 0) {\n\t\tSYSERROR(\"Failre closing template\");\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\tbuf[flen] = '\\0';\n\tret = gnutls_hash_fast(GNUTLS_DIG_SHA1, buf, flen, (void *)digest);\n\tfree(buf);\n\treturn ret;\n}", "target": 0}
{"code": "static int destroy_srq(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                       union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_destroy_srq *cmd = &req->destroy_srq;\n    RdmaRmSRQ *srq;\n    PvrdmaRing *ring;\n    srq = rdma_rm_get_srq(&dev->rdma_dev_res, cmd->srq_handle);\n    if (!srq) {\n        return -EINVAL;\n    }\n    ring = (PvrdmaRing *)srq->opaque;\n    destroy_srq_ring(ring);\n    rdma_rm_dealloc_srq(&dev->rdma_dev_res, cmd->srq_handle);\n    return 0;\n}", "target": 0}
{"code": "bool Browser::EmbedsFullscreenWidget() const {\n  return true;\n}", "target": 0}
{"code": "    void TiffEncoder::encodeBinaryElement(TiffBinaryElement* object, const Exifdatum* datum)\n    {\n        encodeTiffEntryBase(object, datum);\n    } ", "target": 0}
{"code": "xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,\n\t\t\t      double *numbers,\n\t\t\t      int numbers_max,\n\t\t\t      xsltFormatPtr tokens,\n\t\t\t      xmlBufferPtr buffer)\n{\n    int i = 0;\n    double number;\n    xsltFormatTokenPtr token;\n    if (tokens->start != NULL)\n\t xmlBufferCat(buffer, tokens->start);\n    for (i = 0; i < numbers_max; i++) {\n\tnumber = numbers[(numbers_max - 1) - i];\n        number = floor(number + 0.5);\n        if (number < 0.0) {\n            xsltTransformError(NULL, NULL, NULL,\n                    \"xsl-number : negative value\\n\");\n            number = 0.0;\n        }\n\tif (i < tokens->nTokens) {\n\t  token = &(tokens->tokens[i]);\n\t} else if (tokens->nTokens > 0) {\n\t  token = &(tokens->tokens[tokens->nTokens - 1]);\n\t} else {\n\t  token = &default_token;\n\t}\n\tif (i > 0) {\n\t    if (token->separator != NULL)\n\t\txmlBufferCat(buffer, token->separator);\n\t    else\n\t\txmlBufferCCat(buffer, DEFAULT_SEPARATOR);\n\t}\n\tswitch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    xmlBufferCCat(buffer, \"-Infinity\");\n\t    break;\n\tcase 1:\n\t    xmlBufferCCat(buffer, \"Infinity\");\n\t    break;\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\txmlBufferCCat(buffer, \"NaN\");\n\t    } else {\n\t\tswitch (token->token) {\n\t\tcase 'A':\n\t\t    xsltNumberFormatAlpha(data, buffer, number, TRUE);\n\t\t    break;\n\t\tcase 'a':\n\t\t    xsltNumberFormatAlpha(data, buffer, number, FALSE);\n\t\t    break;\n\t\tcase 'I':\n\t\t    xsltNumberFormatRoman(data, buffer, number, TRUE);\n\t\t    break;\n\t\tcase 'i':\n\t\t    xsltNumberFormatRoman(data, buffer, number, FALSE);\n\t\t    break;\n\t\tdefault:\n\t\t    if (IS_DIGIT_ZERO(token->token)) {\n\t\t\txsltNumberFormatDecimal(buffer,\n\t\t\t\t\t\tnumber,\n\t\t\t\t\t\ttoken->token,\n\t\t\t\t\t\ttoken->width,\n\t\t\t\t\t\tdata->digitsPerGroup,\n\t\t\t\t\t\tdata->groupingCharacter,\n\t\t\t\t\t\tdata->groupingCharacterLen);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    if (tokens->end != NULL)\n\t xmlBufferCat(buffer, tokens->end);\n}", "target": 0}
{"code": "void FrameLoader::closeAndRemoveChild(Frame* child)\n{\n    child->tree()->detachFromParent();\n    child->setView(0);\n    if (child->ownerElement() && child->page())\n        child->page()->decrementFrameCount();\n    child->pageDestroyed();\n    m_frame->tree()->removeChild(child);\n}", "target": 0}
{"code": "SWFShape_addStyleHeader(SWFShape shape)\n{\n\tSWFOutput out = newSWFOutput();\n\tSWFOutput_writeUInt16(out, CHARACTERID(shape));\n\tSWFOutput_writeRect(out, SWFCharacter_getBounds(CHARACTER(shape)));\n\tif(shape->useVersion == SWF_SHAPE4)\n\t{\n\t\tSWFOutput_writeRect(out, shape->edgeBounds);\n\t\tSWFOutput_writeUInt8(out, shape->flags);\n\t}\n\tSWFOutput_writeFillStyles(out, shape->fills, shape->nFills, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\tSWFOutput_writeLineStyles(out, shape->lines, shape->nLines, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\tSWFOutput_setNext(out, shape->out);\n\tshape->out = out;\n}", "target": 0}
{"code": "cdf_get_property_info_pos(const cdf_stream_t *sst, const cdf_header_t *h, \n    const uint8_t *p, const uint8_t *e, size_t i)\n{\n\tsize_t tail = (i << 1) + 1;\n\tsize_t ofs;\n\tconst uint8_t *q;\n\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t    __LINE__) == -1)\n\t\treturn NULL;\n\tofs = CDF_GETUINT32(p, tail);\n\tq = CAST(const uint8_t *, cdf_offset(CAST(const void *, p), \n\t    ofs - 2 * sizeof(uint32_t)));\n\tif (q < p) {\n\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n\t\treturn NULL;\n\t}\n\tif (q >= e) {\n\t\tDPRINTF((\"Ran off the end %p >= %p\\n\", q, e));\n\t\treturn NULL;\n\t}\n\treturn q;\n}", "target": 0}
{"code": "static int ldb_match_present(struct ldb_context *ldb, \n\t\t\t     const struct ldb_message *msg,\n\t\t\t     const struct ldb_parse_tree *tree,\n\t\t\t     enum ldb_scope scope, bool *matched)\n{\n\tconst struct ldb_schema_attribute *a;\n\tstruct ldb_message_element *el;\n\tif (ldb_attr_dn(tree->u.present.attr) == 0) {\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\t}\n\tel = ldb_msg_find_element(msg, tree->u.present.attr);\n\tif (el == NULL) {\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\t}\n\ta = ldb_schema_attribute_by_name(ldb, el->name);\n\tif (!a) {\n\t\treturn LDB_ERR_INVALID_ATTRIBUTE_SYNTAX;\n\t}\n\tif (a->syntax->operator_fn) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < el->num_values; i++) {\n\t\t\tint ret = a->syntax->operator_fn(ldb, LDB_OP_PRESENT, a, &el->values[i], NULL, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\t}\n\t*matched = true;\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "void prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}", "target": 0}
{"code": "MagickPrivate void ConvertRGBToHSV(const double red,const double green,\n  const double blue,double *hue,double *saturation,double *value)\n{\n  double\n    c,\n    max,\n    min;\n  assert(hue != (double *) NULL);\n  assert(saturation != (double *) NULL);\n  assert(value != (double *) NULL);\n  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,\n    QuantumScale*blue));\n  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,\n    QuantumScale*blue));\n  c=max-min;\n  *value=max;\n  if (c <= 0.0)\n    {\n      *hue=0.0;\n      *saturation=0.0;\n      return;\n    }\n  if (fabs(max-QuantumScale*red) < MagickEpsilon)\n    {\n      *hue=(QuantumScale*green-QuantumScale*blue)/c;\n      if ((QuantumScale*green) < (QuantumScale*blue))\n        *hue+=6.0;\n    }\n  else\n    if (fabs(max-QuantumScale*green) < MagickEpsilon)\n      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;\n    else\n      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;\n  *hue*=60.0/360.0;\n  *saturation=c*PerceptibleReciprocal(max);\n}", "target": 0}
{"code": "TEST(QuantizedUInt8PoolingOpTest, MaxPoolPaddingValidStride1) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, 0, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, 0, 15.9375}, Padding_VALID, 1, 1);\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({6, 10, 10})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({96, 160, 160}));\n}", "target": 0}
{"code": "void RGWDeleteCORS_ObjStore_S3::send_response()\n{\n  int r = op_ret;\n  if (!r || r == -ENOENT)\n    r = STATUS_NO_CONTENT;\n  set_req_state_err(s, r);\n  dump_errno(s);\n  end_header(s, NULL);\n}", "target": 0}
{"code": "static void ok_jpg_convert_data_unit_grayscale(const uint8_t *y, uint8_t *output,\n                                               const int x_inc, const int y_inc,\n                                               const int max_width, const int max_height) {\n    for (int v = 0; v < max_height; v++) {\n        uint8_t *out = output;\n        for (int x = 0; x < max_width; x++) {\n            out[0] = y[x];\n            out[1] = y[x];\n            out[2] = y[x];\n            out[3] = 0xff;\n            out += x_inc;\n        }\n        y += C_WIDTH;\n        output += y_inc;\n    }\n}", "target": 0}
{"code": "  explicit FullFeedFetcher(JobScheduler* scheduler)\n      : scheduler_(scheduler),\n        weak_ptr_factory_(this) {\n  }", "target": 0}
{"code": "  String DumpFragmentTree(Element* element) {\n    auto fragment = RunBlockLayoutAlgorithm(element);\n    return DumpFragmentTree(fragment.get());\n  }", "target": 0}
{"code": "void SandboxedExtensionUnpacker::StartProcessOnIOThread(\n    const FilePath& temp_crx_path) {\n  UtilityProcessHost* host = new UtilityProcessHost(\n      rdh_, this, thread_identifier_);\n  host->StartExtensionUnpacker(temp_crx_path);\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "static void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}", "target": 0}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "globfree(glob_t *pglob)\n{\n    int i;\n    char **pp;\n    if (pglob->gl_pathv != NULL) {\n        pp = pglob->gl_pathv + pglob->gl_offs;\n        for (i = pglob->gl_pathc; i--; ++pp) {\n            if (*pp) {\n                free(*pp);\n            }\n        }\n        free(pglob->gl_pathv);\n        pglob->gl_pathv = NULL;\n    }\n    if (pglob->gl_statv != NULL) {\n        for (i = 0; i < pglob->gl_pathc; i++) {\n            if (pglob->gl_statv[i] != NULL) {\n                free(pglob->gl_statv[i]);\n            }\n        }\n        free(pglob->gl_statv);\n        pglob->gl_statv = NULL;\n    }\n}", "target": 0}
{"code": "static AioContext *nvme_get_aio_context(BlockAIOCB *acb)\n{\n    return qemu_get_aio_context();\n}", "target": 0}
{"code": "GF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "CryptRsaSelectScheme(\n\t\t     TPMI_DH_OBJECT       rsaHandle,     \n\t\t     TPMT_RSA_DECRYPT    *scheme         \n\t\t     )\n{\n    OBJECT              *rsaObject;\n    TPMT_ASYM_SCHEME    *keyScheme;\n    TPMT_RSA_DECRYPT    *retVal = NULL;\n    rsaObject = HandleToObject(rsaHandle);\n    keyScheme = &rsaObject->publicArea.parameters.asymDetail.scheme;\n    if(keyScheme->scheme == TPM_ALG_NULL)\n\t{\n\t    retVal = scheme;\n\t}\n    else if(scheme->scheme == TPM_ALG_NULL)\n\t{\n\t    retVal = (TPMT_RSA_DECRYPT *)keyScheme;\n\t}\n    else if(keyScheme->scheme == scheme->scheme\n\t    && keyScheme->details.anySig.hashAlg == scheme->details.anySig.hashAlg)\n\t{\n\t    retVal = scheme;\n\t}\n    return retVal;\n}", "target": 0}
{"code": "static krb5_error_code hdb_samba4_nextkey_panic(krb5_context context, HDB *db,\n\t\t\t\t\t\tunsigned flags,\n\t\t\t\t\t\thdb_entry *entry)\n{\n\tDBG_ERR(\"Attempt to iterate kpasswd keytab => PANIC\\n\");\n\tsmb_panic(\"hdb_samba4_nextkey_panic: Attempt to iterate kpasswd keytab\");\n}", "target": 0}
{"code": "static int soft_offline_huge_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct page *hpage = compound_head(page);\n\tLIST_HEAD(pagelist);\n\tlock_page(hpage);\n\tif (PageHWPoison(hpage)) {\n\t\tunlock_page(hpage);\n\t\tput_hwpoison_page(hpage);\n\t\tpr_info(\"soft offline: %#lx hugepage already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tunlock_page(hpage);\n\tret = isolate_huge_page(hpage, &pagelist);\n\tput_hwpoison_page(hpage);\n\tif (!ret) {\n\t\tpr_info(\"soft offline: %#lx hugepage failed to isolate\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\tif (ret) {\n\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx\\n\",\n\t\t\tpfn, ret, page->flags);\n\t\tputback_active_hugepage(hpage);\n\t\tif (ret > 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\tif (PageHuge(page)) {\n\t\t\tset_page_hwpoison_huge_page(hpage);\n\t\t\tdequeue_hwpoisoned_huge_page(hpage);\n\t\t\tnum_poisoned_pages_add(1 << compound_order(hpage));\n\t\t} else {\n\t\t\tSetPageHWPoison(page);\n\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "my_bool STDCALL mysql_stmt_attr_set(MYSQL_STMT *stmt,\n                                    enum enum_stmt_attr_type attr_type,\n                                    const void *value)\n{\n  switch (attr_type) {\n  case STMT_ATTR_UPDATE_MAX_LENGTH:\n    stmt->update_max_length= value ? *(const my_bool*) value : 0;\n    break;\n  case STMT_ATTR_CURSOR_TYPE:\n  {\n    ulong cursor_type;\n    cursor_type= value ? *(ulong*) value : 0UL;\n    if (cursor_type > (ulong) CURSOR_TYPE_READ_ONLY)\n      goto err_not_implemented;\n    stmt->flags= cursor_type;\n    break;\n  }\n  case STMT_ATTR_PREFETCH_ROWS:\n  {\n    ulong prefetch_rows= value ? *(ulong*) value : DEFAULT_PREFETCH_ROWS;\n    if (value == 0)\n      return TRUE;\n    stmt->prefetch_rows= prefetch_rows;\n    break;\n  }\n  default:\n    goto err_not_implemented;\n  }\n  return FALSE;\nerr_not_implemented:\n  set_stmt_error(stmt, CR_NOT_IMPLEMENTED, unknown_sqlstate, NULL);\n  return TRUE;\n}", "target": 0}
{"code": "mwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_wep_key *wep_key;\n\tu16 cmd_size = *param_size;\n\tint i;\n\tu8 *tlv = *tlv_buf;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif (bss_cfg->wep_cfg[i].length &&\n\t\t    (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\n\t\t     bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\n\t\t\twep_key = (struct host_cmd_tlv_wep_key *)tlv;\n\t\t\twep_key->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\n\t\t\twep_key->header.len =\n\t\t\t\tcpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\n\t\t\twep_key->key_index = bss_cfg->wep_cfg[i].key_index;\n\t\t\twep_key->is_default = bss_cfg->wep_cfg[i].is_default;\n\t\t\tmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\n\t\t\t       bss_cfg->wep_cfg[i].length);\n\t\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t\ttlv += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t}\n\t}\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\treturn;\n}", "target": 0}
{"code": "static void connection_reset(connection *con) {\n\trequest_st * const r = &con->request;\n\trequest_reset(r);\n\tconfig_reset_config(r);\n\tr->bytes_read_ckpt = 0;\n\tr->bytes_written_ckpt = 0;\n\tcon->is_readable = 1;\n\tcon->bytes_written = 0;\n\tcon->bytes_written_cur_second = 0;\n\tcon->bytes_read = 0;\n}", "target": 0}
{"code": "static void msgfmt_do_format(MessageFormatter_object *mfo, zval *args, zval *return_value TSRMLS_DC)\n{\n\tint count;\n\tUChar* formatted = NULL;\n\tint formatted_len = 0;\n\tHashTable *args_copy;\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(args));\n\tALLOC_HASHTABLE(args_copy);\n\tzend_hash_init(args_copy, count, NULL, ZVAL_PTR_DTOR, 0);\n\tzend_hash_copy(args_copy, Z_ARRVAL_P(args), (copy_ctor_func_t)zval_add_ref,\n\t\tNULL, sizeof(zval*));\n\tumsg_format_helper(mfo, args_copy, &formatted, &formatted_len TSRMLS_CC);\n\tzend_hash_destroy(args_copy);\n\tefree(args_copy);\n\tif (U_FAILURE(INTL_DATA_ERROR_CODE(mfo))) {\n\t\tif (formatted) {\n\t\t\tefree(formatted);\n\t\t}\n\t\tRETURN_FALSE;\n\t} else {\n\t\tINTL_METHOD_RETVAL_UTF8(mfo, formatted, formatted_len, 1);\n\t}\n}", "target": 0}
{"code": "vte_sequence_handler_soft_reset (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_terminal_reset(terminal, FALSE, FALSE);\n}", "target": 0}
{"code": "LibRaw_buffer_datastream::~LibRaw_buffer_datastream() {}", "target": 0}
{"code": "int CLua::file_write(lua_State *ls)\n{\n    if (!lua_islightuserdata(ls, 1))\n    {\n        luaL_argerror(ls, 1, \"Expected filehandle at arg 1\");\n        return 0;\n    }\n    CLuaSave *sf = static_cast<CLuaSave *>(lua_touserdata(ls, 1));\n    if (!sf)\n        return 0;\n    FILE *f = sf->get_file();\n    if (!f)\n        return 0;\n    const char *text = luaL_checkstring(ls, 2);\n    if (text)\n        fprintf(f, \"%s\", text);\n    return 0;\n}", "target": 0}
{"code": "void EmbeddedWorkerContextClient::workerContextFailedToStart() {\n  DCHECK(main_thread_proxy_->RunsTasksOnCurrentThread());\n  DCHECK(!script_context_);\n  RenderThreadImpl::current()->embedded_worker_dispatcher()->\n      WorkerContextDestroyed(embedded_worker_id_);\n}", "target": 0}
{"code": "GF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tp->size += 8;\n\tp->version=1;\n\tp->size += 4;\n\tif (p->version>=2) p->size += 4;\n\tp->default_length = 0;\n\tfor (i=0; i<gf_list_count(p->group_descriptions); i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (!p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += gf_list_count(p->group_descriptions)*4;\n\t}\n\treturn GF_OK;", "target": 0}
{"code": "static int req_parseargs(lua_State *L)\n{\n    apr_table_t *form_table;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    lua_newtable(L);\n    lua_newtable(L);            \n    ap_args_to_table(r, &form_table);\n    apr_table_do(req_aprtable2luatable_cb, L, form_table, NULL);\n    return 2;                   \n}", "target": 0}
{"code": "    void CrwParser::encode(\n              Blob&     blob,\n        const byte*     pData,\n              uint32_t  size,\n        const CrwImage* pCrwImage\n    )\n    {\n        CiffHeader::UniquePtr head(new CiffHeader);\n        if (size != 0) {\n            head->read(pData, size);\n        }\n        CrwMap::encode(head.get(), *pCrwImage);\n        head->write(blob);\n    } ", "target": 0}
{"code": "option_handler (assuan_context_t ctx, const char *key, const char *value)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  if (!strcmp (key, \"event-signal\"))\n    {\n#ifdef HAVE_W32_SYSTEM\n      if (!*value)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = strtoul (value, NULL, 16);\n#else\n      int i = *value? atoi (value) : -1;\n      if (i < 0)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = i;\n#endif\n    }\n return 0;\n}", "target": 0}
{"code": "    const NativePreviewList& Image::nativePreviews() const\n    {\n        return nativePreviews_;\n    }", "target": 0}
{"code": "static int _php_pgsql_detect_identifier_escape(const char *identifier, size_t len)\n{\n\tsize_t i;\n\tif (len <= 2) {\n\t\treturn FAILURE;\n\t}\n\tif (identifier[0] == '\"' && identifier[len-1] == '\"') {\n\t\tfor (i = 1; i < len-1; i++) {\n\t\t\tif (identifier[i] == '\"' && (identifier[++i] != '\"' || i == len-1)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void avrcp_set_addressed_player(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_player *player)\n{\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 2];\n\tstruct avrcp_header *pdu = (void *) buf;\n\tuint16_t id;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_SET_ADDRESSED_PLAYER;\n\tpdu->packet_type = AVRCP_PACKET_TYPE_SINGLE;\n\tid = htons(player->id);\n\tmemcpy(pdu->params, &id, 2);\n\tpdu->params_len = htons(2);\n\tavctp_send_vendordep_req(session->conn, AVC_CTYPE_CONTROL,\n\t\t\t\t\tAVC_SUBUNIT_PANEL, buf, sizeof(buf),\n\t\t\t\t\tavrcp_set_addressed_player_rsp,\n\t\t\t\t\tsession);\n}", "target": 0}
{"code": "static void dump_bucket_metadata(struct req_state *s, RGWBucketEnt& bucket)\n{\n  dump_header(s, \"X-RGW-Object-Count\", static_cast<long long>(bucket.count));\n  dump_header(s, \"X-RGW-Bytes-Used\", static_cast<long long>(bucket.size));\n}", "target": 0}
{"code": "    void XmpSidecar::setComment(const std::string& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"Image comment\", \"XMP\"));\n    }", "target": 0}
{"code": "bool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 0}
{"code": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\treturn uprobe;\n}", "target": 0}
{"code": "void FrameLoader::loadHistoryItem(HistoryItem* item)\n{\n    m_requestedHistoryItem = item;\n    HistoryItem* currentItem = history()->currentItem();\n    if (currentItem && item->shouldDoSameDocumentNavigationTo(currentItem)) {\n        history()->setCurrentItem(item);\n        loadInSameDocument(item->url(), item->stateObject(), false);\n        return;\n    }\n    history()->setProvisionalItem(item);\n    RefPtr<FormData> formData = item->formData();\n    ResourceRequest request(item->url());\n    request.setHTTPReferrer(item->referrer());\n    if (formData) {\n        request.setHTTPMethod(\"POST\");\n        request.setHTTPBody(formData);\n        request.setHTTPContentType(item->formContentType());\n        RefPtr<SecurityOrigin> securityOrigin = SecurityOrigin::createFromString(item->referrer());\n        addHTTPOriginIfNeeded(request, securityOrigin->toString());\n    }\n    loadWithNavigationAction(request, NavigationAction(request, FrameLoadTypeBackForward, false), FrameLoadTypeBackForward, 0, SubstituteData());\n}", "target": 0}
{"code": "  static std::unique_ptr<Task> Create(ImageLoader* loader,\n                                      UpdateFromElementBehavior update_behavior,\n                                      ReferrerPolicy referrer_policy) {\n    return std::make_unique<Task>(loader, update_behavior, referrer_policy);\n  }", "target": 0}
{"code": "void set_stmt_errmsg(MYSQL_STMT *stmt, NET *net)\n{\n  DBUG_ENTER(\"set_stmt_errmsg\");\n  DBUG_PRINT(\"enter\", (\"error: %d/%s '%s'\",\n                       net->last_errno,\n                       net->sqlstate,\n                       net->last_error));\n  DBUG_ASSERT(stmt != 0);\n  stmt->last_errno= net->last_errno;\n  if (net->last_error && net->last_error[0])\n    strmov(stmt->last_error, net->last_error);\n  strmov(stmt->sqlstate, net->sqlstate);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "send_message (mu_message_t msg)\n{\n  char *mailer_url = NULL;\n  char *sendmail;\n  int status;\n  if (mailvar_get (&sendmail, mailvar_name_sendmail,\n\t\t   mailvar_type_string, 0) == 0)\n    {\n      if (mailvar_is_true (mailvar_name_mailx))\n\t{\n\t  if (!mu_is_proto (sendmail))\n\t    {\n\t      status = mu_asprintf (&mailer_url, \"sendmail:\n\t      if (status)\n\t\treturn status;\n\t      sendmail = mailer_url;\n\t    }\n\t}\n      if (sendmail[0] == '/')\n\tstatus = msg_to_pipe (sendmail, msg);\n      else\n\t{\n\t  mu_mailer_t mailer;\n\t  status = mu_mailer_create (&mailer, sendmail);\n\t  if (status == 0)\n\t    {\n\t      const char *return_address_str;\n\t      mu_address_t return_address = NULL;\n\t      if (mailvar_get (&return_address_str, mailvar_name_return_address,\n\t\t\t       mailvar_type_string, 0) == 0)\n\t\t{\n\t\t  struct mu_address hint = MU_ADDRESS_HINT_INITIALIZER;\n\t\t  status = mu_address_create_hint (&return_address,\n\t\t\t\t\t\t   return_address_str,\n\t\t\t\t\t\t   &hint, 0);\n\t\t  if (status)\n\t\t    {\n\t\t      mu_error (_(\"invalid return address: %s\"),\n\t\t\t\tmu_strerror (status));\n\t\t      mu_mailer_destroy (&mailer);\n\t\t      return status;\n\t\t    }\n\t\t} \n\t      if (mailvar_is_true (mailvar_name_verbose))\n\t\t{\n\t\t  mu_debug_set_category_level (MU_DEBCAT_MAILER,\n\t\t\t\t\t  MU_DEBUG_LEVEL_UPTO (MU_DEBUG_PROT));\n\t\t}\n\t      status = mu_mailer_open (mailer, MU_STREAM_RDWR);\n\t      if (status == 0)\n\t\t{\n\t\t  status = mu_mailer_send_message (mailer, msg,\n\t\t\t\t\t\t   return_address, NULL);\n\t\t  mu_mailer_close (mailer);\n\t\t}\n\t      else\n\t\tmu_error (_(\"Cannot open mailer: %s\"),\n\t\t\t  mu_strerror (status));\n\t      mu_mailer_destroy (&mailer);\n\t      mu_address_destroy (&return_address);\n\t    }\n\t  else\n\t    mu_error (_(\"Cannot create mailer: %s\"), mu_strerror (status));\n\t}\n    }\n  else\n    {\n      mu_error (_(\"Variable sendmail not set: no mailer\"));\n      status = ENOSYS;\n    }\n  free (mailer_url);\n  return status;\n}", "target": 0}
{"code": "int __export rad_packet_add_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tint len = strlen(val);\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\tra->alloc = 1;\n\tra->val.string = _malloc(len + 1);\n\tif (!ra->val.string) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t_free(ra);\n\t\treturn -1;\n\t}\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\tra->raw = ra->val.string;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\treturn 0;\n}", "target": 0}
{"code": "static int btrfs_ioctl_get_fslabel(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\tspin_lock(&fs_info->super_lock);\n\tmemcpy(label, fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&fs_info->super_lock);\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t   \"label is too long, return the first %zu bytes\",\n\t\t\t   --len);\n\t}\n\tret = copy_to_user(arg, label, len);\n\treturn ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static inline bool should_drop_frame(struct sk_buff *skb, int present_fcs_len,\n\t\t\t\t     unsigned int rtap_space)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\thdr = (void *)(skb->data + rtap_space);\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC |\n\t\t\t    RX_FLAG_FAILED_PLCP_CRC |\n\t\t\t    RX_FLAG_ONLY_MONITOR |\n\t\t\t    RX_FLAG_NO_PSDU))\n\t\treturn true;\n\tif (unlikely(skb->len < 16 + present_fcs_len + rtap_space))\n\t\treturn true;\n\tif (ieee80211_is_ctl(hdr->frame_control) &&\n\t    !ieee80211_is_pspoll(hdr->frame_control) &&\n\t    !ieee80211_is_back_req(hdr->frame_control))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct skcipher_tfm *tfm = private;\n\tint err;\n\terr = crypto_ablkcipher_setkey(tfm->skcipher, key, keylen);\n\ttfm->has_key = !err;\n\treturn err;\n}", "target": 0}
{"code": "display_block (unsigned char *data,\n\t       dwarf_vma length,\n\t       const unsigned char * const end, char delimiter)\n{\n  dwarf_vma maxlen;\n  printf (_(\"%c%s byte block: \"), delimiter, dwarf_vmatoa (\"u\", length));\n  if (data > end)\n    return (unsigned char *) end;\n  maxlen = (dwarf_vma) (end - data);\n  length = length > maxlen ? maxlen : length;\n  while (length --)\n    printf (\"%lx \", (unsigned long) byte_get (data++, 1));\n  return data;\n}", "target": 0}
{"code": "static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}", "target": 0}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "lock_encryption_data_unref (LockEncryptionData *data)\n{\n  data->refcount--;\n  if (data->refcount == 0)\n    {\n      g_object_unref (data->luks_device);\n      g_object_unref (data->cleartext_device);\n      g_free (data);\n    }\n}", "target": 0}
{"code": "ZEND_METHOD(error_exception, getSeverity)\n{\n\tDEFAULT_0_PARAMS;\n\t_default_exception_get_entry(getThis(), \"severity\", sizeof(\"severity\")-1, return_value TSRMLS_CC);\n}", "target": 0}
{"code": "static int nvme_aor_check(NvmeNamespace *ns, uint32_t act, uint32_t opn)\n{\n    if (ns->params.max_active_zones != 0 &&\n        ns->nr_active_zones + act > ns->params.max_active_zones) {\n        trace_pci_nvme_err_insuff_active_res(ns->params.max_active_zones);\n        return NVME_ZONE_TOO_MANY_ACTIVE | NVME_DNR;\n    }\n    if (ns->params.max_open_zones != 0 &&\n        ns->nr_open_zones + opn > ns->params.max_open_zones) {\n        trace_pci_nvme_err_insuff_open_res(ns->params.max_open_zones);\n        return NVME_ZONE_TOO_MANY_OPEN | NVME_DNR;\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static inline int domain_type_is_vm(struct dmar_domain *domain)\n{\n\treturn domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE;\n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_9_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "GF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tp->size += 8;\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int tftp_read_data(struct tftp_session *spt, uint32_t block_nr,\n                          uint8_t *buf, int len)\n{\n    int bytes_read = 0;\n    if (spt->fd < 0) {\n        spt->fd = open(spt->filename, O_RDONLY | O_BINARY);\n    }\n    if (spt->fd < 0) {\n        return -1;\n    }\n    if (len) {\n        lseek(spt->fd, block_nr * spt->block_size, SEEK_SET);\n        bytes_read = read(spt->fd, buf, len);\n    }\n    return bytes_read;\n}", "target": 0}
{"code": "static void scale_rect(SkIRect* dst, const SkIRect& src, float scale) {\n   dst->fLeft = (int)::roundf(src.fLeft * scale);\n   dst->fTop = (int)::roundf(src.fTop * scale);\n   dst->fRight = (int)::roundf(src.fRight * scale);\n   dst->fBottom = (int)::roundf(src.fBottom * scale);\n}", "target": 0}
{"code": "void ParamTraits<Message>::Write(Message* m, const Message& p) {\n#if defined(OS_POSIX)\n  DCHECK(!p.HasFileDescriptors());\n#endif\n  m->WriteUInt32(static_cast<uint32>(p.routing_id()));\n  m->WriteUInt32(p.type());\n  m->WriteUInt32(p.flags());\n  m->WriteData(p.payload(), static_cast<uint32>(p.payload_size()));\n}", "target": 0}
{"code": "static GF_Err gf_m4v_parse_frame_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, val;\n\ts32 o_type;\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = GF_FALSE;\n\tm4v->current_object_type = (u32)-1;\n\t*frame_type = 0;\n\tif (!m4v->step_mode)\n\t\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_PIC_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\t\t\t*is_coded = 1;\n\t\t\tgf_bs_read_u8(m4v->bs);\n\t\t\tval = gf_bs_read_u8(m4v->bs);\n\t\t\t*frame_type = ((val >> 3) & 0x7) - 1;\n\t\t\tbreak;\n\t\tcase M2V_GOP_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\tif (m4v->step_mode)\n\t\t\treturn GF_OK;\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}", "target": 0}
{"code": "HttpStateData::proceedAfter1xx()\n{\n    Must(flags.handling1xx);\n    debugs(11, 2, \"continuing with \" << payloadSeen << \" bytes in buffer after 1xx\");\n    CallJobHere(11, 3, this, HttpStateData, HttpStateData::processReply);\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct * mm, unsigned long addr)\n{\n\tstruct vm_area_struct * vma;\n\tunsigned long start;\n\taddr &= PAGE_MASK;\n\tvma = find_vma(mm,addr);\n\tif (!vma)\n\t\treturn NULL;\n\tif (vma->vm_start <= addr)\n\t\treturn vma;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\treturn NULL;\n\tstart = vma->vm_start;\n\tif (expand_stack(vma, addr))\n\t\treturn NULL;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tmake_pages_present(addr, start);\n\treturn vma;\n}", "target": 0}
{"code": "bool format_time(time_t time, char *dest, size_t max_size)\n{\n\ttm tm;\n\tlocaltime_r(&time, &tm);\n\treturn strftime(dest, max_size,\n\t\t \"%Y-%m-%d %H:%M:%S\", &tm) != 0;\n}", "target": 0}
{"code": "static void vp9_segmentation_params(GF_BitStream *bs)\n{\n\tBool segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled == 1) {\n\t\tint i;\n\t\tBool segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\tif (segmentation_update_map) {\n\t\t\tfor (i = 0; i < 7; i++) {\n\t\t\t\tvp9_read_prob(bs);\n\t\t\t}\n\t\t\tBool segmentation_temporal_update = gf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (segmentation_temporal_update) {\n\t\t\t\t\tvp9_read_prob(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tBool segmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\tif (segmentation_update_data == 1) {\n\t\t\t gf_bs_read_int_log(bs, 1, \"segmentation_abs_or_delta_update\");\n\t\t\tfor (i = 0; i < VP9_MAX_SEGMENTS; i++) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < VP9_SEG_LVL_MAX; j++) {\n\t\t\t\t\tBool feature_enabled = gf_bs_read_int_log(bs, 1, \"feature_enabled\");\n\t\t\t\t\tif (feature_enabled) {\n\t\t\t\t\t\tint bits_to_read = segmentation_feature_bits[j];\n\t\t\t\t\t\t gf_bs_read_int_log(bs, bits_to_read, \"feature_value\");\n\t\t\t\t\t\tif (segmentation_feature_signed[j] == 1) {\n\t\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"feature_sign\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_size_t truelen;\n   png_byte buf[4];\n   png_debug(1, \"in png_handle_sBIT\");\n   buf[0] = buf[1] = buf[2] = buf[3] = 0;\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sBIT\");\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sBIT after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n   {\n      png_warning(png_ptr, \"Out of place sBIT chunk\");\n   }\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))\n   {\n      png_warning(png_ptr, \"Duplicate sBIT chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 3;\n   else\n      truelen = (png_size_t)png_ptr->channels;\n   if (length != truelen || length > 4)\n   {\n      png_warning(png_ptr, \"Incorrect sBIT chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n   png_crc_read(png_ptr, buf, truelen);\n   if (png_crc_finish(png_ptr, 0))\n      return;\n   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n   else\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[0];\n      png_ptr->sig_bit.blue = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n}", "target": 0}
{"code": "void CallInfo::print() {\n  ResourceMark rm;\n  const char* kindstr;\n  switch (_call_kind) {\n  case direct_call: kindstr = \"direct\";  break;\n  case vtable_call: kindstr = \"vtable\";  break;\n  case itable_call: kindstr = \"itable\";  break;\n  default         : kindstr = \"unknown\"; break;\n  }\n  tty->print_cr(\"Call %s@%d %s\", kindstr, _call_index,\n                _resolved_method.is_null() ? \"(none)\" : _resolved_method->name_and_sig_as_C_string());\n}", "target": 0}
{"code": "void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger)\n{\n\tunsigned int mask = 1 << irq;\n\tunsigned int old, new;\n\told = inb(0x4d0) | (inb(0x4d1) << 8);\n\tnew = acpi_noirq ? old : 0;\n\tswitch (trigger) {\n\tcase 1:\t\t\n\t\tnew &= ~mask;\n\t\tbreak;\n\tcase 3:\t\t\n\t\tnew |= mask;\n\t\tbreak;\n\t}\n\tif (old == new)\n\t\treturn;\n\tprintk(PREFIX \"setting ELCR to %04x (from %04x)\\n\", new, old);\n\toutb(new, 0x4d0);\n\toutb(new >> 8, 0x4d1);\n}", "target": 0}
{"code": "    PreviewManager::PreviewManager(const Image& image)\n        : image_(image)\n    {\n    }", "target": 0}
{"code": "getProperty(Property prop)\n{\n\tswitch(prop)\n\t{\n\tcase SWF_SETPROPERTY_X: \treturn(\"_x\"); break;\n\tcase SWF_SETPROPERTY_Y:\n\tcase PROPERTY_Y:\t\treturn(\"_y\"); break;\n\tcase PROPERTY_XMOUSE:\t\treturn(\"_xMouse\"); break;\n\tcase PROPERTY_YMOUSE:\t\treturn(\"_yMouse\"); break;\n\tcase SWF_SETPROPERTY_XSCALE:\n\tcase PROPERTY_XSCALE:\t   \treturn(\"_xScale\"); break;\n\tcase SWF_SETPROPERTY_YSCALE:\n\tcase PROPERTY_YSCALE:\t   \treturn(\"_yScale\"); break;\n\tcase PROPERTY_CURRENTFRAME:\treturn(\"_currentFrame\"); break;\n\tcase PROPERTY_TOTALFRAMES:\treturn(\"_totalFrames\"); break;\n\tcase SWF_SETPROPERTY_ALPHA:\n\tcase PROPERTY_ALPHA:\t\treturn(\"_alpha\"); break;\n\tcase SWF_SETPROPERTY_VISIBILITY:\n\tcase PROPERTY_VISIBLE:\t\treturn(\"_visible\"); break;\n\tcase PROPERTY_WIDTH:\t\treturn(\"_width\"); break;\n\tcase PROPERTY_HEIGHT:\t\treturn(\"_height\"); break;\n\tcase SWF_SETPROPERTY_ROTATION:\n\tcase PROPERTY_ROTATION:\t\treturn(\"_rotation\"); break;\n\tcase PROPERTY_TARGET:\t\treturn(\"_target\"); break;\n\tcase PROPERTY_FRAMESLOADED:\treturn(\"_framesLoaded\"); break;\n\tcase SWF_SETPROPERTY_NAME:\n\tcase PROPERTY_NAME:\t\treturn(\"_name\"); break;\n\tcase PROPERTY_DROPTARGET:\treturn(\"_dropTarget\"); break;\n\tcase PROPERTY_URL:\t\treturn(\"_url\"); break;\n\tcase SWF_SETPROPERTY_HIGHQUALITY:\n\tcase PROPERTY_HIGHQUALITY:\treturn(\"_quality\"); break;\n\tcase SWF_SETPROPERTY_SHOWFOCUSRECT:\n\tcase PROPERTY_FOCUSRECT:\treturn(\"_focusRect\"); break;\n\tcase SWF_SETPROPERTY_SOUNDBUFFERTIME:\n\tcase PROPERTY_SOUNDBUFTIME:\treturn(\"_soundBufTime\"); break;\n\tcase SWF_SETPROPERTY_WTHIT:\n\tcase PROPERTY_WTHIT:\t\treturn(\"_WTHIT!?\"); break;\n\tdefault:\t\t\treturn(\"unknown property!\"); break;\n\t}\n}", "target": 0}
{"code": "static void str_term_source(j_decompress_ptr cinfo) { }", "target": 0}
{"code": "      void decode_xml(XMLObj *obj) {\n        RGWXMLDecoder::decode_xml(\"Prefix\", prefix, obj);\n        if (prefix && prefix->empty()) {\n          prefix.reset();\n        }\n        RGWXMLDecoder::decode_xml(\"Tag\", tag, obj);\n        if (tag && tag->empty()) {\n          tag.reset();\n        }\n        RGWXMLDecoder::decode_xml(\"And\", and_elements, obj);\n        if (and_elements && and_elements->empty()) {\n          and_elements.reset();\n        }\n      };", "target": 0}
{"code": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\treturn kobj_to_node_hstate(kobj, nidp);\n}", "target": 0}
{"code": "nm_vpnc_plugin_new (const char *bus_name)\n{\n\tNMVPNCPlugin *plugin;\n\tGError *error = NULL;\n\tplugin = (NMVPNCPlugin *) g_initable_new (NM_TYPE_VPNC_PLUGIN, NULL, &error,\n\t                                          NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME, bus_name,\n\t                                          NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER, !gl.debug,\n\t                                          NULL);\n\tif (!plugin) {\n\t\t_LOGW (\"Failed to initialize a plugin instance: %s\", error->message);\n\t\tg_error_free (error);\n\t}\n\treturn plugin;\n}", "target": 0}
{"code": "range_entry_compar (const void *ap, const void *bp)\n{\n  const struct range_entry *a_re = (const struct range_entry *) ap;\n  const struct range_entry *b_re = (const struct range_entry *) bp;\n  const dwarf_vma a = a_re->ranges_offset;\n  const dwarf_vma b = b_re->ranges_offset;\n  return (a > b) - (b > a);\n}", "target": 0}
{"code": "Bool gf_fs_check_filter_register_cap(const GF_FilterRegister *f_reg, u32 incode, GF_PropertyValue *cap_input, u32 outcode, GF_PropertyValue *cap_output, Bool exact_match_only)\n{\n\treturn gf_fs_check_filter_register_cap_ex(f_reg, incode, cap_input, outcode, cap_output, exact_match_only, GF_FALSE);\n}", "target": 0}
{"code": "int afGetChannels (AFfilehandle file, int trackid)\n{\n\t_Track\t*track;\n\tif ((track = _af_filehandle_get_track(file, trackid)) == NULL)\n\t\treturn -1;\n\treturn track->f.channelCount;\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoTexParameteriv(\n  GLenum target, GLenum pname, const GLint* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameteriv: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(info, pname, *params)) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameteriv: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameteriv(target, pname, params);\n}", "target": 0}
{"code": "      static double mp_dowhile(_cimg_math_parser& mp) {\n        const ulongT\n          mem_body = mp.opcode[1],\n          mem_cond = mp.opcode[2];\n        const CImg<ulongT>\n          *const p_body = ++mp.p_code,\n          *const p_cond = p_body + mp.opcode[3],\n          *const p_end = p_cond + mp.opcode[4];\n        const unsigned int vsiz = (unsigned int)mp.opcode[5];\n        if (mp.opcode[6]) { \n          if (vsiz) CImg<doubleT>(&mp.mem[mem_body] + 1,vsiz,1,1,1,true).fill(cimg::type<double>::nan());\n          else mp.mem[mem_body] = cimg::type<double>::nan();\n        }\n        if (mp.opcode[7]) mp.mem[mem_cond] = 0;\n        const unsigned int _break_type = mp.break_type;\n        mp.break_type = 0;\n        do {\n          for (mp.p_code = p_body; mp.p_code<p_cond; ++mp.p_code) { \n            mp.opcode._data = mp.p_code->_data;\n            const ulongT target = mp.opcode[1];\n            mp.mem[target] = _cimg_mp_defunc(mp);\n          }\n          if (mp.break_type==1) break; else if (mp.break_type==2) mp.break_type = 0;\n          for (mp.p_code = p_cond; mp.p_code<p_end; ++mp.p_code) { \n            mp.opcode._data = mp.p_code->_data;\n            const ulongT target = mp.opcode[1];\n            mp.mem[target] = _cimg_mp_defunc(mp);\n          }\n          if (mp.break_type==1) break; else if (mp.break_type==2) mp.break_type = 0;\n        } while (mp.mem[mem_cond]);\n        mp.break_type = _break_type;\n        mp.p_code = p_end - 1;\n        return mp.mem[mem_body];", "target": 0}
{"code": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n{\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    static const uint8_t vlan[] = {0x81, 0x00};\n    uint8_t *ptr = (uint8_t *)buf;\n    int i;\n    if (n->promisc)\n        return 1;\n    ptr += n->host_hdr_len;\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n        int vid = lduw_be_p(ptr + 14) & 0xfff;\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n            return 0;\n    }\n    if (ptr[0] & 1) { \n        if (!memcmp(ptr, bcast, sizeof(bcast))) {\n            return !n->nobcast;\n        } else if (n->nomulti) {\n            return 0;\n        } else if (n->allmulti || n->mac_table.multi_overflow) {\n            return 1;\n        }\n        for (i = n->mac_table.first_multi; i < n->mac_table.in_use; i++) {\n            if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) {\n                return 1;\n            }\n        }\n    } else { \n        if (n->nouni) {\n            return 0;\n        } else if (n->alluni || n->mac_table.uni_overflow) {\n            return 1;\n        } else if (!memcmp(ptr, n->mac, ETH_ALEN)) {\n            return 1;\n        }\n        for (i = 0; i < n->mac_table.first_multi; i++) {\n            if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int btrfs_extent_same_range(struct inode *src, u64 loff, u64 olen,\n\t\t\t\t   struct inode *dst, u64 dst_loff)\n{\n\tu64 bs = BTRFS_I(src)->root->fs_info->sb->s_blocksize;\n\tint ret;\n\tu64 len = olen;\n\tif (loff + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - loff;\n\tif (dst == src && len != olen)\n\t\treturn -EINVAL;\n\tbtrfs_double_extent_lock(src, loff, dst, dst_loff, len);\n\tret = btrfs_clone(src, dst, loff, olen, len, dst_loff, 1);\n\tbtrfs_double_extent_unlock(src, loff, dst, dst_loff, len);\n\treturn ret;\n}", "target": 0}
{"code": "static  v4l2_std_id parse_audio_std_option(void)\n{\n\tif (strcasecmp(audio_std, \"A2\") == 0)\n\t\treturn V4L2_STD_A2;\n\tif (strcasecmp(audio_std, \"A2/A\") == 0)\n\t\treturn V4L2_STD_A2_A;\n\tif (strcasecmp(audio_std, \"A2/B\") == 0)\n\t\treturn V4L2_STD_A2_B;\n\tif (strcasecmp(audio_std, \"NICAM\") == 0)\n\t\treturn V4L2_STD_NICAM;\n\tif (strcasecmp(audio_std, \"NICAM/A\") == 0)\n\t\treturn V4L2_STD_NICAM_A;\n\tif (strcasecmp(audio_std, \"NICAM/B\") == 0)\n\t\treturn V4L2_STD_NICAM_B;\n\treturn 0;\n}", "target": 0}
{"code": "void vhost_zerocopy_callback(struct ubuf_info *ubuf)\n{\n\tstruct vhost_ubuf_ref *ubufs = ubuf->ctx;\n\tstruct vhost_virtqueue *vq = ubufs->vq;\n\tvhost_poll_queue(&vq->poll);\n\tvq->heads[ubuf->desc].len = VHOST_DMA_DONE_LEN;\n\tkref_put(&ubufs->kref, vhost_zerocopy_done_signal);\n}", "target": 0}
{"code": "static inline void vm_entry_controls_setbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) | val);\n}", "target": 0}
{"code": "last_match_getter(void)\n{\n    return rb_reg_last_match(rb_backref_get());\n}", "target": 0}
{"code": "int __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_aux_data_fd_pair *ax;\n\tif (likely(!context)) {\n\t\treturn 0;\n\t}\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax) {\n\t\treturn -ENOMEM;\n\t}\n\tax->fd[0] = fd1;\n\tax->fd[1] = fd2;\n\tax->d.type = AUDIT_FD_PAIR;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "SPL_METHOD(SplFileObject, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n} ", "target": 0}
{"code": "    **/\n    inline const char *split_filename(const char *const filename, char *const body=0) {\n      if (!filename) { if (body) *body = 0; return 0; }\n      const char *p = 0; for (const char *np = filename; np>=filename && (p=np); np = std::strchr(np,'.') + 1) {}\n      if (p==filename) {\n        if (body) std::strcpy(body,filename);\n        return filename + std::strlen(filename);\n      }\n      const unsigned int l = (unsigned int)(p - filename - 1);\n      if (body) { if (l) std::memcpy(body,filename,l); body[l] = 0; }\n      return p;", "target": 0}
{"code": "compileString (const char *inString)\n{\n  int k;\n  FileInfo nested;\n  if (inString == NULL)\n    return 0;\n  nested.fileName = inString;\n  nested.encoding = noEncoding;\n  nested.lineNumber = 1;\n  nested.status = 0;\n  nested.linepos = 0;\n  for (k = 0; inString[k]; k++)\n    nested.line[k] = inString[k];\n  nested.line[k] = 0;\n  return compileRule (&nested);\n}", "target": 0}
{"code": "  Supports_Condition_Obj Parser::parse_supports_condition_in_parens()\n  {\n    Supports_Condition_Obj interp = parse_supports_interpolation();\n    if (interp != 0) return interp;\n    if (!lex < exactly <'('> >()) return {};\n    lex < css_whitespace >();\n    Supports_Condition_Obj cond = parse_supports_condition();\n    if (cond != 0) {\n      if (!lex < exactly <')'> >()) error(\"unclosed parenthesis in @supports declaration\");\n    } else {\n      cond = parse_supports_declaration();\n      if (!lex < exactly <')'> >()) error(\"unclosed parenthesis in @supports declaration\");\n    }\n    lex < css_whitespace >();\n    return cond;\n  }", "target": 0}
{"code": "eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    type = get_compare_type(p, &len, &type_is);\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tlong\t    comp_lnum = SOURCING_LNUM;\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\t    SOURCING_LNUM = comp_lnum;\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n    return OK;\n}", "target": 0}
{"code": "static int packet_rcv_has_room(struct packet_sock *po, struct sk_buff *skb)\n{\n\tint ret;\n\tbool has_room;\n\tspin_lock_bh(&po->sk.sk_receive_queue.lock);\n\tret = __packet_rcv_has_room(po, skb);\n\thas_room = ret == ROOM_NORMAL;\n\tif (po->pressure == has_room)\n\t\tpo->pressure = !has_room;\n\tspin_unlock_bh(&po->sk.sk_receive_queue.lock);\n\treturn ret;\n}", "target": 0}
{"code": "bool SimpleSoftOMXComponent::isSetParameterAllowed(\n        OMX_INDEXTYPE index, const OMX_PTR params) const {\n if (mState == OMX_StateLoaded) {\n return true;\n }\n    OMX_U32 portIndex;\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n            portIndex = ((OMX_PARAM_PORTDEFINITIONTYPE *)params)->nPortIndex;\n break;\n }\n case OMX_IndexParamAudioPcm:\n {\n            portIndex = ((OMX_AUDIO_PARAM_PCMMODETYPE *)params)->nPortIndex;\n break;\n }\n case OMX_IndexParamAudioAac:\n {\n            portIndex = ((OMX_AUDIO_PARAM_AACPROFILETYPE *)params)->nPortIndex;\n break;\n }\n default:\n return false;\n }\n    CHECK(portIndex < mPorts.size());\n return !mPorts.itemAt(portIndex).mDef.bEnabled;\n}", "target": 0}
{"code": "    bool PanasonicMnHeader::read(const byte* pData,\n                                 uint32_t    size,\n                                 ByteOrder   )\n    {\n        if (!pData || size < sizeOfSignature()) return false;\n        if (0 != memcmp(pData, signature_, 9)) return false;\n        buf_.alloc(sizeOfSignature());\n        std::memcpy(buf_.pData_, pData, buf_.size_);\n        start_ = sizeOfSignature();\n        return true;\n    } ", "target": 0}
{"code": "void ScriptController::enableEval()\n{\n    if (!m_windowShell->isContextInitialized())\n        return;\n    v8::HandleScope handleScope(m_isolate);\n    m_windowShell->context()->AllowCodeGenerationFromStrings(true);\n}", "target": 0}
{"code": "std::string ProcessRawBytes(const unsigned char* data, size_t data_length) {\n  return ProcessRawBytesWithSeparators(data, data_length, ' ', '\\n');\n}", "target": 0}
{"code": "static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct net_device *dev = idev->dev;\n\tbool update_rs = false;\n\tstruct in6_addr ll_addr;\n\tif (token == NULL)\n\t\treturn -EINVAL;\n\tif (ipv6_addr_any(token))\n\t\treturn -EINVAL;\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP))\n\t\treturn -EINVAL;\n\tif (!ipv6_accept_ra(idev))\n\t\treturn -EINVAL;\n\tif (idev->cnf.rtr_solicits <= 0)\n\t\treturn -EINVAL;\n\twrite_lock_bh(&idev->lock);\n\tBUILD_BUG_ON(sizeof(token->s6_addr) != 16);\n\tmemcpy(idev->token.s6_addr + 8, token->s6_addr + 8, 8);\n\twrite_unlock_bh(&idev->lock);\n\tif (!idev->dead && (idev->if_flags & IF_READY) &&\n\t    !ipv6_get_lladdr(dev, &ll_addr, IFA_F_TENTATIVE |\n\t\t\t     IFA_F_OPTIMISTIC)) {\n\t\tndisc_send_rs(dev, &ll_addr, &in6addr_linklocal_allrouters);\n\t\tupdate_rs = true;\n\t}\n\twrite_lock_bh(&idev->lock);\n\tif (update_rs) {\n\t\tidev->if_flags |= IF_RS_SENT;\n\t\tidev->rs_probes = 1;\n\t\taddrconf_mod_rs_timer(idev, idev->cnf.rtr_solicit_interval);\n\t}\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tspin_lock(&ifp->lock);\n\t\tif (ifp->tokenized) {\n\t\t\tifp->valid_lft = 0;\n\t\t\tifp->prefered_lft = 0;\n\t\t}\n\t\tspin_unlock(&ifp->lock);\n\t}\n\twrite_unlock_bh(&idev->lock);\n\taddrconf_verify(0);\n\treturn 0;\n}", "target": 0}
{"code": "gen_blkmove(codegen_scope *s, uint16_t ainfo, int lv)\n{\n  int m1 = (ainfo>>7)&0x3f;\n  int r  = (ainfo>>6)&0x1;\n  int m2 = (ainfo>>1)&0x1f;\n  int kd = (ainfo)&0x1;\n  int off = m1+r+m2+kd+1;\n  if (lv == 0) {\n    gen_move(s, cursp(), off, 0);\n  }\n  else {\n    genop_3(s, OP_GETUPVAR, cursp(), off, lv);\n  }\n  push();\n}", "target": 0}
{"code": "void _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    _WM_Release_Allowance(mdi);\n    return;\n}", "target": 0}
{"code": "GF_Err piff_psec_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->AlgorithmID = gf_bs_read_int(bs, 24);\n\t\tptr->IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\t}\n\tif (ptr->IV_size == 0)\n\t\tptr->IV_size = 8; \n\tptr->bs_offset = gf_bs_get_position(bs);\n\tgf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->IV_size != 8 && ptr->IV_size != 16) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] PIFF PSEC box incorrect IV size: %u - shall be 8 or 16\\n\", ptr->IV_size));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle != DMA_MAPPING_ERROR)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "tagstack_clear_entry(taggy_T *item)\n{\n    VIM_CLEAR(item->tagname);\n    VIM_CLEAR(item->user_data);\n}", "target": 0}
{"code": "decode_NXAST_RAW_LEARN(const struct nx_action_learn *nal,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_learn *learn;\n    enum ofperr error;\n    learn = ofpact_put_LEARN(ofpacts);\n    error = decode_LEARN_common(nal, NXAST_RAW_LEARN, learn);\n    if (error) {\n        return error;\n    }\n    if (learn->flags & ~(NX_LEARN_F_SEND_FLOW_REM |\n                         NX_LEARN_F_DELETE_LEARNED)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    return decode_LEARN_specs(nal + 1, (char *) nal + ntohs(nal->len),\n                              vl_mff_map, tlv_bitmap, ofpacts);\n}", "target": 0}
{"code": "uint32_t enc_untrusted_qe_get_quote(const sgx_report_t *app_report,\n                                    uint32_t quote_size, uint8_t *quote) {\n  uint32_t result;\n  CHECK_OCALL(\n      ocall_enc_untrusted_qe_get_quote(&result, app_report, quote_size, quote));\n  return result;\n}", "target": 0}
{"code": "static int __init parse_acpi(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\tif (strcmp(arg, \"off\") == 0) {\n\t\tdisable_acpi();\n\t}\n\telse if (strcmp(arg, \"force\") == 0) {\n\t\tacpi_force = 1;\n\t\tacpi_ht = 1;\n\t\tacpi_disabled = 0;\n\t}\n\telse if (strcmp(arg, \"strict\") == 0) {\n\t\tacpi_strict = 1;\n\t}\n\telse if (strcmp(arg, \"ht\") == 0) {\n\t\tif (!acpi_force)\n\t\t\tdisable_acpi();\n\t\tacpi_ht = 1;\n\t}\n\telse if (strcmp(arg, \"noirq\") == 0) {\n\t\tacpi_noirq_set();\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    void appendProcessingInstructionCallback(const xmlChar* target, const xmlChar* data)\n    {\n        PendingProcessingInstructionCallback* callback = new PendingProcessingInstructionCallback;\n        callback->target = xmlStrdup(target);\n        callback->data = xmlStrdup(data);\n        m_callbacks.append(callback);\n    }", "target": 0}
{"code": "static int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_accessres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}", "target": 0}
{"code": "  void Parser::error(std::string msg, Position pos)\n  {\n    Position p(pos.line ? pos : before_token);\n    ParserState pstate(path, source, p, Offset(0, 0));\n    char *src_copy = sass_copy_c_string(pstate.src);\n    pstate.src = src_copy;\n    traces.push_back(Backtrace(pstate));\n    throw Exception::InvalidSass(pstate, traces, msg, src_copy);\n  }", "target": 0}
{"code": "SWFInput_getUInt16(SWFInput input)\n{\n\tint num = SWFInput_getChar(input);\n\tnum += SWFInput_getChar(input) << 8;\n\treturn num;\n}", "target": 0}
{"code": "static void write_cachehdr(const char *name, const char *contents,\n                           const char *raw __attribute__((unused)), void *rock)\n{\n    struct transaction_t *txn = (struct transaction_t *) rock;\n    const char **hdr, *hop_by_hop[] =\n        { \"connection\", \"content-length\", \"content-type\", \"date\", \"forwarded\",\n          \"keep-alive\", \"location\", \"status\", \"strict-transport-security\",\n          \"upgrade\", \"via\", NULL };\n    if (name[0] == ':') return;\n    for (hdr = hop_by_hop; *hdr; hdr++) {\n        if (!strcasecmp(name, *hdr)) return;\n    }\n    simple_hdr(txn, name, contents);\n}", "target": 0}
{"code": "static int ct_rewind(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_hold(player, AVC_REWIND);\n}", "target": 0}
{"code": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    struct timespec *rqtp, struct itimerspec *it)\n{\n\tstruct k_itimer timer;\n\tint error;\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec zero_it;\n\t\tmemset(it, 0, sizeof *it);\n\t\tit->it_value = *rqtp;\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires.sched == 0) {\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\t\tsample_to_timespec(which_clock, timer.it.cpu.expires, rqtp);\n\t\tposix_cpu_timer_set(&timer, 0, &zero_it, it);\n\t\tspin_unlock_irq(&timer.it_lock);\n\t\tif ((it->it_value.tv_sec | it->it_value.tv_nsec) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static int fts3SnippetShift(\n  Fts3Table *pTab,                \n  int iLangid,                    \n  int nSnippet,                   \n  const char *zDoc,               \n  int nDoc,                       \n  int *piPos,                     \n  u64 *pHlmask                    \n){\n  u64 hlmask = *pHlmask;          \n  if( hlmask ){\n    int nLeft;                    \n    int nRight;                   \n    int nDesired;                 \n    for(nLeft=0; !(hlmask & ((u64)1 << nLeft)); nLeft++);\n    for(nRight=0; !(hlmask & ((u64)1 << (nSnippet-1-nRight))); nRight++);\n    nDesired = (nLeft-nRight)/2;\n    if( nDesired>0 ){\n      int nShift;                 \n      int iCurrent = 0;           \n      int rc;                     \n      sqlite3_tokenizer_module *pMod;\n      sqlite3_tokenizer_cursor *pC;\n      pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;\n      rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, iLangid, zDoc, nDoc, &pC);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n      while( rc==SQLITE_OK && iCurrent<(nSnippet+nDesired) ){\n        const char *ZDUMMY; int DUMMY1 = 0, DUMMY2 = 0, DUMMY3 = 0;\n        rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &DUMMY2, &DUMMY3, &iCurrent);\n      }\n      pMod->xClose(pC);\n      if( rc!=SQLITE_OK && rc!=SQLITE_DONE ){ return rc; }\n      nShift = (rc==SQLITE_DONE)+iCurrent-nSnippet;\n      assert( nShift<=nDesired );\n      if( nShift>0 ){\n        *piPos += nShift;\n        *pHlmask = hlmask >> nShift;\n      }\n    }\n  }\n  return SQLITE_OK;\n}", "target": 0}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "int bnx2x_set_eth_mac(struct bnx2x *bp, bool set)\n{\n\tif (IS_PF(bp)) {\n\t\tunsigned long ramrod_flags = 0;\n\t\tDP(NETIF_MSG_IFUP, \"Adding Eth MAC\\n\");\n\t\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\t\treturn bnx2x_set_mac_one(bp, bp->dev->dev_addr,\n\t\t\t\t\t &bp->sp_objs->mac_obj, set,\n\t\t\t\t\t BNX2X_ETH_MAC, &ramrod_flags);\n\t} else { \n\t\treturn bnx2x_vfpf_config_mac(bp, bp->dev->dev_addr,\n\t\t\t\t\t     bp->fp->index, set);\n\t}\n}", "target": 0}
{"code": "ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n\t\t\t\t  ipcp_value<valtype> *src_val,\n\t\t\t\t  int src_idx, HOST_WIDE_INT offset,\n\t\t\t\t  ipcp_value<valtype> **val_p,\n\t\t\t\t  bool unlimited)\n{\n  ipcp_value<valtype> *val, *last_val = NULL;\n  if (val_p)\n    *val_p = NULL;\n  if (bottom)\n    return false;\n  for (val = values; val; last_val = val, val = val->next)\n    if (values_equal_for_ipcp_p (val->value, newval))\n      {\n\tif (val_p)\n\t  *val_p = val;\n\tif (ipa_edge_within_scc (cs))\n\t  {\n\t    ipcp_value_source<valtype> *s;\n\t    for (s = val->sources; s; s = s->next)\n\t      if (s->cs == cs)\n\t\tbreak;\n\t    if (s)\n\t      return false;\n\t  }\n\tval->add_source (cs, src_val, src_idx, offset);\n\treturn false;\n      }\n  if (!unlimited && values_count == param_ipa_cp_value_list_size)\n    {\n      for (val = values; val; val = val->next)\n\t{\n\t  while (val->sources)\n\t    {\n\t      ipcp_value_source<valtype> *src = val->sources;\n\t      val->sources = src->next;\n\t      ipcp_sources_pool.remove ((ipcp_value_source<tree>*)src);\n\t    }\n\t}\n      values = NULL;\n      return set_to_bottom ();\n    }\n  values_count++;\n  val = allocate_and_init_ipcp_value (newval);\n  val->add_source (cs, src_val, src_idx, offset);\n  val->next = NULL;\n  if (last_val)\n    last_val->next = val;\n  else\n    values = val;\n  if (val_p)\n    *val_p = val;\n  return true;\n}", "target": 0}
{"code": "bm_search(regex_t* reg, const UChar* target, const UChar* target_end,\n\t  const UChar* text, const UChar* text_end, const UChar* text_range)\n{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n# ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search: text: %\"PRIuPTR\", text_end: %\"PRIuPTR\", text_range: %\"PRIuPTR\"\\n\",\n\t  text, text_end, text_range);\n# endif\n  end = text_range + (target_end - target) - 1;\n  if (end > text_end)\n    end = text_end;\n  tail = target_end - 1;\n  s = text + (target_end - target) - 1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s;\n      t = tail;\n# ifdef ONIG_DEBUG_SEARCH\n      fprintf(stderr, \"bm_search_loop: pos: %\"PRIdPTR\" %s\\n\",\n\t  (intptr_t )(s - text), s);\n# endif\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      s += reg->map[*s];\n    }\n  }\n  else { \n# if OPT_EXACT_MAXLEN >= ONIG_CHAR_TABLE_SIZE\n    while (s < end) {\n      p = s;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )p;\n\tp--; t--;\n      }\n      s += reg->int_map[*s];\n    }\n# endif\n  }\n  return (UChar* )NULL;\n}", "target": 0}
{"code": "static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif (!tp->retransmit_skb_hint ||\n\t    before(TCP_SKB_CB(skb)->seq,\n\t\t   TCP_SKB_CB(tp->retransmit_skb_hint)->seq))\n\t\ttp->retransmit_skb_hint = skb;\n\tif (!tp->lost_out ||\n\t    after(TCP_SKB_CB(skb)->end_seq, tp->retransmit_high))\n\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n}", "target": 0}
{"code": "static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)\n{\n        unsigned int mask;\n        struct snd_timer_user *tu;\n        tu = file->private_data;\n        poll_wait(file, &tu->qchange_sleep, wait);\n\tmask = 0;\n\tif (tu->qused)\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (tu->disconnected)\n\t\tmask |= POLLERR;\n\treturn mask;\n}", "target": 0}
{"code": "static int vhost_user_set_vring_err(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tint expected_fds;\n\texpected_fds = (msg->payload.u64 & VHOST_USER_VRING_NOFD_MASK) ? 0 : 1;\n\tif (validate_msg_fds(msg, expected_fds) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (!(msg->payload.u64 & VHOST_USER_VRING_NOFD_MASK))\n\t\tclose(msg->fds[0]);\n\tVHOST_LOG_CONFIG(INFO, \"not implemented\\n\");\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "static bool rbuf_alloc(conn *c) {\n    if (c->rbuf == NULL) {\n        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);\n        if (!c->rbuf) {\n            THR_STATS_LOCK(c);\n            c->thread->stats.read_buf_oom++;\n            THR_STATS_UNLOCK(c);\n            return false;\n        }\n        c->rsize = READ_BUFFER_SIZE;\n        c->rcurr = c->rbuf;\n    }\n    return true;\n}", "target": 0}
{"code": "    SonyMnHeader::~SonyMnHeader()\n    {\n    }", "target": 0}
{"code": "void debug_hdr(const char *dir, struct session *t, const char *start, const char *end)\n{\n\tint max;\n\tchunk_printf(&trash, \"%08x:%s.%s[%04x:%04x]: \", t->uniq_id, t->be->id,\n\t\t      dir, (unsigned  short)t->req->prod->conn->t.sock.fd,\n\t\t     (unsigned short)t->req->cons->conn->t.sock.fd);\n\tfor (max = 0; start + max < end; max++)\n\t\tif (start[max] == '\\r' || start[max] == '\\n')\n\t\t\tbreak;\n\tUBOUND(max, trash.size - trash.len - 3);\n\ttrash.len += strlcpy2(trash.str + trash.len, start, max + 1);\n\ttrash.str[trash.len++] = '\\n';\n\tif (write(1, trash.str, trash.len) < 0) ;\n}", "target": 0}
{"code": "void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tif (!conn)\n\t\tgoto drop;\n\tBT_DBG(\"conn %p len %d\", conn, skb->len);\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\ndrop:\n\tkfree_skb(skb);\n}", "target": 0}
{"code": "test_gui_tabline_event(dict_T *args UNUSED)\n{\n#  ifdef FEAT_GUI_TABLINE\n    int\t\ttabnr;\n    if (!dict_has_key(args, \"tabnr\"))\n\treturn FALSE;\n    tabnr = (int)dict_get_number(args, \"tabnr\");\n    return send_tabline_event(tabnr);\n#  else\n    return FALSE;\n#  endif\n}", "target": 0}
{"code": "xmlStopParser(xmlParserCtxtPtr ctxt) {\n    if (ctxt == NULL)\n        return;\n    xmlHaltParser(ctxt);\n    ctxt->errNo = XML_ERR_USER_STOP;\n}", "target": 0}
{"code": "static zval **spl_array_get_property_ptr_ptr(zval *object, zval *member, int type, const zend_literal *key TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif ((intern->ar_flags & SPL_ARRAY_ARRAY_AS_PROPS) != 0\n\t&& !std_object_handlers.has_property(object, member, 2, key TSRMLS_CC)) {\n\t\treturn spl_array_get_dimension_ptr_ptr(1, object, member, type TSRMLS_CC);\n\t}\n\treturn std_object_handlers.get_property_ptr_ptr(object, member, type, key TSRMLS_CC);\n} ", "target": 0}
{"code": "static int intel_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dma_addr;\n}", "target": 0}
{"code": "static void *do_ncp_super_data_conv(void *raw_data)\n{\n\tint version = *(unsigned int *)raw_data;\n\tif (version == 3) {\n\t\tstruct compat_ncp_mount_data *c_n = raw_data;\n\t\tstruct ncp_mount_data *n = raw_data;\n\t\tn->dir_mode = c_n->dir_mode;\n\t\tn->file_mode = c_n->file_mode;\n\t\tn->gid = c_n->gid;\n\t\tn->uid = c_n->uid;\n\t\tmemmove (n->mounted_vol, c_n->mounted_vol, (sizeof (c_n->mounted_vol) + 3 * sizeof (unsigned int)));\n\t\tn->wdog_pid = c_n->wdog_pid;\n\t\tn->mounted_uid = c_n->mounted_uid;\n\t} else if (version == 4) {\n\t\tstruct compat_ncp_mount_data_v4 *c_n = raw_data;\n\t\tstruct ncp_mount_data_v4 *n = raw_data;\n\t\tn->dir_mode = c_n->dir_mode;\n\t\tn->file_mode = c_n->file_mode;\n\t\tn->gid = c_n->gid;\n\t\tn->uid = c_n->uid;\n\t\tn->retry_count = c_n->retry_count;\n\t\tn->time_out = c_n->time_out;\n\t\tn->ncp_fd = c_n->ncp_fd;\n\t\tn->wdog_pid = c_n->wdog_pid;\n\t\tn->mounted_uid = c_n->mounted_uid;\n\t\tn->flags = c_n->flags;\n\t} else if (version != 5) {\n\t\treturn NULL;\n\t}\n\treturn raw_data;\n}", "target": 0}
{"code": "gx_dc_pattern2_equal(const gx_device_color * pdevc1,\n                     const gx_device_color * pdevc2)\n{\n    return pdevc2->type == pdevc1->type &&\n        pdevc1->ccolor.pattern == pdevc2->ccolor.pattern;\n}", "target": 0}
{"code": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "cupsdDeleteAllCerts(void)\n{\n  cupsd_cert_t\t*cert,\t\t\t\n\t\t*next;\t\t\t\n  char\t\tfilename[1024];\t\t\n  for (cert = Certs; cert != NULL; cert = next)\n  {\n    snprintf(filename, sizeof(filename), \"%s/certs/%d\", StateDir, cert->pid);\n    if (unlink(filename))\n      cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to remove %s!\", filename);\n    next = cert->next;\n    free(cert);\n  }\n  Certs        = NULL;\n  RootCertTime = 0;\n}", "target": 0}
{"code": "ServiceProtoQueryMappedAliases(ServiceConnection *conn,\n                               ProtoRequest *req)\n{\n   VGAuthError err;\n   gchar *packet;\n   int num;\n   ServiceMappedAlias *maList;\n   err = ServiceAliasQueryMappedAliases(&num,\n                                        &maList);\n   if (err != VGAUTH_E_OK) {\n      packet = Proto_MakeErrorReply(conn, req, err, \"queryMappedIds failed\");\n   } else {\n      int i;\n      gchar *endPacket;\n      packet = g_markup_printf_escaped(VGAUTH_QUERYMAPPEDALIASES_REPLY_FORMAT_START,\n                                       req->sequenceNumber);\n      for (i = 0; i < num; i++) {\n         gchar *tPacket;\n         int j;\n         tPacket = g_markup_printf_escaped(VGAUTH_MAPPEDALIASES_FORMAT_START,\n                                           maList[i].userName,\n                                           maList[i].pemCert);\n         packet = Proto_ConcatXMLStrings(packet, tPacket);\n         for (j = 0; j < maList[i].num; j++) {\n            if (maList[i].subjects[j].type == SUBJECT_TYPE_ANY) {\n               tPacket = g_markup_printf_escaped(VGAUTH_ANYSUBJECT_FORMAT);\n            } else if (maList[i].subjects[j].type == SUBJECT_TYPE_NAMED) {\n               tPacket = g_markup_printf_escaped(VGAUTH_SUBJECT_FORMAT,\n                                                 maList[i].subjects[j].name);\n            } else {\n               tPacket = NULL;\n               ASSERT(0);\n            }\n            packet = Proto_ConcatXMLStrings(packet, tPacket);\n         }\n         packet = Proto_ConcatXMLStrings(packet,\n                                         g_markup_printf_escaped(VGAUTH_MAPPEDALIASES_FORMAT_END));\n      }\n      endPacket = g_markup_printf_escaped(VGAUTH_QUERYMAPPEDALIASES_REPLY_FORMAT_END);\n      packet = Proto_ConcatXMLStrings(packet, endPacket);\n      ServiceAliasFreeMappedAliasList(num, maList);\n   }\n   err = ServiceNetworkWriteData(conn, strlen(packet), packet);\n   if (err != VGAUTH_E_OK) {\n      Warning(\"%s: failed to send QueryAliases reply\\n\", __FUNCTION__);\n   }\n   g_free(packet);\n   return err;\n}", "target": 0}
{"code": "    void TiffDecoder::visitSizeEntry(TiffSizeEntry* object)\n    {\n        decodeTiffEntry(object);\n    }", "target": 0}
{"code": "XML_SetBillionLaughsAttackProtectionActivationThreshold(\n    XML_Parser parser, unsigned long long activationThresholdBytes) {\n  if ((parser == NULL) || (parser->m_parentParser != NULL)) {\n    return XML_FALSE;\n  }\n  parser->m_accounting.activationThresholdBytes = activationThresholdBytes;\n  return XML_TRUE;\n}", "target": 0}
{"code": "onig_snprintf_with_pattern(UChar buf[], int bufsize, OnigEncoding enc,\n                           UChar* pat, UChar* pat_end, const UChar *fmt, ...)\n{\n  va_list args;\n  va_start(args, fmt);\n  onig_vsnprintf_with_pattern(buf, bufsize, enc,\n\t  pat, pat_end, fmt, args);\n  va_end(args);\n}", "target": 0}
{"code": "nfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}", "target": 0}
{"code": "    void CrwMap::encodeBasic(const Image&      image,\n                             const CrwMapping* pCrwMapping,\n                                   CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        ExifKey ek(pCrwMapping->tag_, Internal::groupName(pCrwMapping->ifdId_));\n        ExifData::const_iterator ed = image.exifData().findKey(ek);\n        if (ed != image.exifData().end()) {\n            DataBuf buf(ed->size());\n            ed->copy(buf.pData_, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "int ipmi_smi_watcher_unregister(struct ipmi_smi_watcher *watcher)\n{\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_del(&watcher->link);\n\tmutex_unlock(&smi_watchers_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "void AudioContext::refNode(AudioNode* node)\n{\n    ASSERT(isMainThread());\n    AutoLocker locker(this);\n    m_referencedNodes.append(node);\n    node->makeConnection();\n}", "target": 0}
{"code": "void SingleFromSingle(const size_t xsize,\n                      const pixel_type* const JXL_RESTRICT row_in,\n                      const float factor, Image3F* decoded, size_t c, size_t y,\n                      Rect& rect) {\n  JXL_DASSERT(xsize <= rect.xsize());\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  float* const JXL_RESTRICT row_out = rect.PlaneRow(decoded, c, y);\n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "  MaybeObject* scheduled_exception() {\n    ASSERT(has_scheduled_exception());\n    return thread_local_top_.scheduled_exception_;\n  }", "target": 0}
{"code": "static void decode_channel_map(uint8_t layout_map[][3],\n                               enum ChannelPosition type,\n                               GetBitContext *gb, int n)\n{\n    while (n--) {\n        enum RawDataBlockType syn_ele;\n        switch (type) {\n        case AAC_CHANNEL_FRONT:\n        case AAC_CHANNEL_BACK:\n        case AAC_CHANNEL_SIDE:\n            syn_ele = get_bits1(gb);\n            break;\n        case AAC_CHANNEL_CC:\n            skip_bits1(gb);\n            syn_ele = TYPE_CCE;\n            break;\n        case AAC_CHANNEL_LFE:\n            syn_ele = TYPE_LFE;\n            break;\n        default:\n            av_assert0(0);\n        }\n        layout_map[0][0] = syn_ele;\n        layout_map[0][1] = get_bits(gb, 4);\n        layout_map[0][2] = type;\n        layout_map++;\n    }\n}", "target": 0}
{"code": "static __always_inline int __vfs_follow_link(struct nameidata *nd, const char *link)\n{\n\tint ret;\n\tif (IS_ERR(link))\n\t\tgoto fail;\n\tif (*link == '/') {\n\t\tset_root(nd);\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->root);\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t}\n\tnd->inode = nd->path.dentry->d_inode;\n\tret = link_path_walk(link, nd);\n\treturn ret;\nfail:\n\tpath_put(&nd->path);\n\treturn PTR_ERR(link);\n}", "target": 0}
{"code": "SubstituteData FrameLoader::defaultSubstituteDataForURL(const KURL& url)\n{\n    if (!shouldTreatURLAsSrcdocDocument(url))\n        return SubstituteData();\n    String srcdoc = m_frame->ownerElement()->fastGetAttribute(srcdocAttr);\n    ASSERT(!srcdoc.isNull());\n    CString encodedSrcdoc = srcdoc.utf8();\n    return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), \"text/html\", \"UTF-8\", KURL());\n}", "target": 0}
{"code": " bool Document::IsSecureTransitionTo(const KURL& url) const {\n  scoped_refptr<SecurityOrigin> other = SecurityOrigin::Create(url);\n  return GetSecurityOrigin()->CanAccess(other.get());\n}", "target": 0}
{"code": "ephy_embed_single_init (EphyEmbedSingle *single)\n{\n  EphyEmbedSinglePrivate *priv;\n  single->priv = priv = EPHY_EMBED_SINGLE_GET_PRIVATE (single);\n  priv->online = TRUE;\n  priv->form_auth_data = g_hash_table_new_full (g_str_hash,\n                                                g_str_equal,\n                                                g_free,\n                                                NULL);\n  cache_keyring_form_data (single);\n}", "target": 0}
{"code": "date_s_today(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vsg, nth, ret;\n    double sg;\n    time_t t;\n    struct tm tm;\n    int y, ry, m, d;\n    rb_scan_args(argc, argv, \"01\", &vsg);\n    if (argc < 1)\n\tsg = DEFAULT_SG;\n    else\n\tval2sg(vsg, sg);\n    if (time(&t) == -1)\n\trb_sys_fail(\"time\");\n    tzset();\n    if (!localtime_r(&t, &tm))\n\trb_sys_fail(\"localtime\");\n    y = tm.tm_year + 1900;\n    m = tm.tm_mon + 1;\n    d = tm.tm_mday;\n    decode_year(INT2FIX(y), -1, &nth, &ry);\n    ret = d_simple_new_internal(klass,\n\t\t\t\tnth, 0,\n\t\t\t\tGREGORIAN,\n\t\t\t\try, m, d,\n\t\t\t\tHAVE_CIVIL);\n    {\n\tget_d1(ret);\n\tset_sg(dat, sg);\n    }\n    return ret;\n}", "target": 0}
{"code": "Item_bool_func2::remove_eq_conds(THD *thd, Item::cond_result *cond_value,\n                                 bool top_level_arg)\n{\n  if (const_item() && !is_expensive())\n  {\n    *cond_value= eval_const_cond() ? Item::COND_TRUE : Item::COND_FALSE;\n    return (COND*) 0;\n  }\n  if ((*cond_value= eq_cmp_result()) != Item::COND_OK)\n  {\n    if (args[0]->eq(args[1], true))\n    {\n      if (*cond_value == Item::COND_FALSE ||\n          !args[0]->maybe_null || functype() == Item_func::EQUAL_FUNC)\n        return (COND*) 0;                       \n    }\n  }\n  *cond_value= Item::COND_OK;\n  return this;                                  \n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t\t\t  const UChar** pp, const UChar* end ARG_UNUSED,\n\t\t\t  UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == 0xdf && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_14_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1; \n}", "target": 0}
{"code": "    virtual void didAccessInitialDocument(WebFrame* frame)\n    {\n        EXPECT_TRUE(!m_didAccessInitialDocument);\n        m_didAccessInitialDocument = true;\n    }", "target": 0}
{"code": "static void purge_empty_parameters (PARAMETER **headp)\n{\n  PARAMETER *p, *q, **last;\n  for (last = headp, p = *headp; p; p = q)\n  {\n    q = p->next;\n    if (!p->attribute || !p->value)\n    {\n      *last = q;\n      p->next = NULL;\n      mutt_free_parameter (&p);\n    }\n    else\n      last = &p->next;\n  }\n}", "target": 0}
{"code": "_zip_write2(unsigned short i, FILE *fp)\n{\n    putc(i&0xff, fp);\n    putc((i>>8)&0xff, fp);\n    return;\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPDFImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PDF\",\"AI\",\"Adobe Illustrator CS2\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"EPDF\",\n    \"Encapsulated Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDF\",\"Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDFA\",\"Portable Document Archive Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\t\terr = create_filter(&event_ftrace_test_filter, d->filter,\n\t\t\t\t    false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&event_mutex);\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\t\tmutex_unlock(&event_mutex);\n\t\t__free_filter(filter);\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "get_pubkey_end (GETKEY_CTX ctx)\n{\n  if (ctx)\n    {\n      memset (&ctx->kbpos, 0, sizeof ctx->kbpos);\n      keydb_release (ctx->kr_handle);\n      free_strlist (ctx->extra_list);\n      if (!ctx->not_allocated)\n\txfree (ctx);\n    }\n}", "target": 0}
{"code": "static int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int lua_ap_set_context_info(lua_State *L)\n{\n    request_rec    *r;\n    const char     *prefix;\n    const char     *document_root;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    r = ap_lua_check_request_rec(L, 1);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    prefix = lua_tostring(L, 2);\n    luaL_checktype(L, 3, LUA_TSTRING);\n    document_root = lua_tostring(L, 3);\n    ap_set_context_info(r, prefix, document_root);\n    return 0;\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_set_content_length(request_rec *r, apr_off_t clength)\n{\n    r->clength = clength;\n    apr_table_setn(r->headers_out, \"Content-Length\",\n                   apr_off_t_toa(r->pool, clength));\n}", "target": 0}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 0}
{"code": "static inline pte_t pte_mknuma(pte_t pte)\n{\n\tpte = pte_set_flags(pte, _PAGE_NUMA);\n\treturn pte_clear_flags(pte, _PAGE_PRESENT);\n}", "target": 0}
{"code": "void __init kvm_guest_init(void)\n{\n\tint i;\n\tif (!kvm_para_available())\n\t\treturn;\n\tparavirt_ops_setup();\n\tregister_reboot_notifier(&kvm_pv_reboot_nb);\n\tfor (i = 0; i < KVM_TASK_SLEEP_HASHSIZE; i++)\n\t\tspin_lock_init(&async_pf_sleepers[i].lock);\n\tif (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))\n\t\tx86_init.irqs.trap_init = kvm_apf_trap_init;\n\tif (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) {\n\t\thas_steal_clock = 1;\n\t\tpv_time_ops.steal_clock = kvm_steal_clock;\n\t}\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\tapic_set_eoi_write(kvm_guest_apic_eoi_write);\n\tif (kvmclock_vsyscall)\n\t\tkvm_setup_vsyscall_timeinfo();\n#ifdef CONFIG_SMP\n\tsmp_ops.smp_prepare_boot_cpu = kvm_smp_prepare_boot_cpu;\n\tregister_cpu_notifier(&kvm_cpu_notifier);\n#else\n\tkvm_guest_cpu_init();\n#endif\n\twatchdog_enable_hardlockup_detector(false);\n}", "target": 0}
{"code": "    size_t SamsungMnHeader::size() const\n    {\n        return 0;\n    }", "target": 0}
{"code": "DLLIMPORT void cfg_error(cfg_t *cfg, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (cfg && cfg->errfunc)\n\t\t(*cfg->errfunc) (cfg, fmt, ap);\n\telse {\n\t\tif (cfg && cfg->filename && cfg->line)\n\t\t\tfprintf(stderr, \"%s:%d: \", cfg->filename, cfg->line);\n\t\telse if (cfg && cfg->filename)\n\t\t\tfprintf(stderr, \"%s: \", cfg->filename);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tva_end(ap);\n}", "target": 0}
{"code": "xfs_bulk_ireq_setup(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_bulk_ireq\t*hdr,\n\tstruct xfs_ibulk\t*breq,\n\tvoid __user\t\t*ubuffer)\n{\n\tif (hdr->icount == 0 ||\n\t    (hdr->flags & ~XFS_BULK_IREQ_FLAGS_ALL) ||\n\t    memchr_inv(hdr->reserved, 0, sizeof(hdr->reserved)))\n\t\treturn -EINVAL;\n\tbreq->startino = hdr->ino;\n\tbreq->ubuffer = ubuffer;\n\tbreq->icount = hdr->icount;\n\tbreq->ocount = 0;\n\tbreq->flags = 0;\n\tif (hdr->flags & XFS_BULK_IREQ_SPECIAL) {\n\t\tif (hdr->flags & XFS_BULK_IREQ_AGNO)\n\t\t\treturn -EINVAL;\n\t\tswitch (hdr->ino) {\n\t\tcase XFS_BULK_IREQ_SPECIAL_ROOT:\n\t\t\thdr->ino = mp->m_sb.sb_rootino;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreq->icount = 1;\n\t}\n\tif (hdr->flags & XFS_BULK_IREQ_AGNO) {\n\t\tif (hdr->agno >= mp->m_sb.sb_agcount)\n\t\t\treturn -EINVAL;\n\t\tif (breq->startino == 0)\n\t\t\tbreq->startino = XFS_AGINO_TO_INO(mp, hdr->agno, 0);\n\t\telse if (XFS_INO_TO_AGNO(mp, breq->startino) < hdr->agno)\n\t\t\treturn -EINVAL;\n\t\tbreq->flags |= XFS_IBULK_SAME_AG;\n\t\tif (XFS_INO_TO_AGNO(mp, breq->startino) > hdr->agno)\n\t\t\treturn -ECANCELED;\n\t} else if (hdr->agno)\n\t\treturn -EINVAL;\n\tif (XFS_INO_TO_AGNO(mp, breq->startino) >= mp->m_sb.sb_agcount)\n\t\treturn -ECANCELED;\n\treturn 0;\n}", "target": 0}
{"code": "static void *__packet_lookup_frame_in_block(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t\tint status,\n\t\t\t\t\t    unsigned int len\n\t\t\t\t\t    )\n{\n\tstruct kbdq_core *pkc;\n\tstruct block_desc *pbd;\n\tchar *curr, *end;\n\tpkc = GET_PBDQC_FROM_RB(((struct packet_ring_buffer *)&po->rx_ring));\n\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\tif (prb_queue_frozen(pkc)) {\n\t\tif (prb_curr_blk_in_use(pkc, pbd)) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tprb_open_block(pkc, pbd);\n\t\t}\n\t}\n\tsmp_mb();\n\tcurr = pkc->nxt_offset;\n\tpkc->skb = skb;\n\tend = (char *) ((char *)pbd + pkc->kblk_size);\n\tif (curr+TOTAL_PKT_LEN_INCL_ALIGN(len) < end) {\n\t\tprb_fill_curr_block(curr, pkc, pbd, len);\n\t\treturn (void *)curr;\n\t}\n\tprb_retire_current_block(pkc, po, 0);\n\tcurr = (char *)prb_dispatch_next_block(pkc, po);\n\tif (curr) {\n\t\tpbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);\n\t\tprb_fill_curr_block(curr, pkc, pbd, len);\n\t\treturn (void *)curr;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int do_execve(char * filename,\n\tchar __user *__user *argv,\n\tchar __user *__user *envp,\n\tstruct pt_regs * regs)\n{\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tunsigned long env_p;\n\tint retval;\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_ret;\n\tfile = open_exec(filename);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_kfree;\n\tsched_exec();\n\tbprm->file = file;\n\tbprm->filename = filename;\n\tbprm->interp = filename;\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_file;\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out_mm;\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out_mm;\n\tretval = security_bprm_alloc(bprm);\n\tif (retval)\n\t\tgoto out;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\tenv_p = bprm->p;\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\tbprm->argv_len = env_p - bprm->p;\n\tretval = search_binary_handler(bprm,regs);\n\tif (retval >= 0) {\n\t\tfree_arg_pages(bprm);\n\t\tsecurity_bprm_free(bprm);\n\t\tacct_update_integrals(current);\n\t\tkfree(bprm);\n\t\treturn retval;\n\t}\nout:\n\tfree_arg_pages(bprm);\n\tif (bprm->security)\n\t\tsecurity_bprm_free(bprm);\nout_mm:\n\tif (bprm->mm)\n\t\tmmput (bprm->mm);\nout_file:\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\nout_kfree:\n\tkfree(bprm);\nout_ret:\n\treturn retval;\n}", "target": 0}
{"code": "void UsageTracker::DidGetClientGlobalUsage(StorageType type,\n                                           int64 usage,\n                                           int64 unlimited_usage) {\n  DCHECK_EQ(type, type_);\n  global_usage_.usage += usage;\n  global_usage_.unlimited_usage += unlimited_usage;\n  if (--global_usage_.pending_clients == 0) {\n    if (global_usage_.usage < 0)\n      global_usage_.usage = 0;\n    if (global_usage_.unlimited_usage > global_usage_.usage)\n      global_usage_.unlimited_usage = global_usage_.usage;\n    else if (global_usage_.unlimited_usage < 0)\n      global_usage_.unlimited_usage = 0;\n    global_usage_callbacks_.Run(type, global_usage_.usage,\n                                global_usage_.unlimited_usage);\n  }\n}", "target": 0}
{"code": "  int libraw_cameraCount() { return LibRaw::cameraCount(); }", "target": 0}
{"code": "string_dequote(uschar **sptr)\n{\nuschar *s = *sptr;\nuschar *t, *yield;\nif (*s != '\\\"')\n  {\n  while (*s != 0 && !isspace(*s)) s++;\n  }\nelse\n  {\n  s++;\n  while (*s != 0 && *s != '\\\"')\n    {\n    if (*s == '\\\\') (void)string_interpret_escape(&s);\n    s++;\n    }\n  if (*s != 0) s++;\n  }\nt = yield = store_get(s - *sptr + 1);\ns = *sptr;\nif (*s != '\\\"')\n  {\n  while (*s != 0 && !isspace(*s)) *t++ = *s++;\n  }\nelse\n  {\n  s++;\n  while (*s != 0 && *s != '\\\"')\n    {\n    if (*s == '\\\\') *t++ = string_interpret_escape(&s);\n      else *t++ = *s;\n    s++;\n    }\n  if (*s != 0) s++;\n  }\n*sptr = s;\n*t = 0;\nreturn yield;\n}", "target": 0}
{"code": "__rb_data_page_index(struct buffer_data_page *bpage, unsigned index)\n{\n\treturn bpage->data + index;\n}", "target": 0}
{"code": "static void mce_timer_delete_all(void)\n{\n\tint cpu;\n\tfor_each_online_cpu(cpu)\n\t\tdel_timer_sync(&per_cpu(mce_timer, cpu));\n}", "target": 0}
{"code": "Value DocumentSourceUnionWith::serialize(boost::optional<ExplainOptions::Verbosity> explain) const {\n    auto collectionless = _pipeline->getContext()->ns.isCollectionlessAggregateNS();\n    if (explain) {\n        Pipeline* pipeCopy = nullptr;\n        if (*explain == ExplainOptions::Verbosity::kQueryPlanner) {\n            pipeCopy = Pipeline::create(_pipeline->getSources(), _pipeline->getContext()).release();\n        } else if (*explain >= ExplainOptions::Verbosity::kExecStats &&\n                   _executionState > ExecutionProgress::kIteratingSource) {\n            pipeCopy = Pipeline::create(_cachedPipeline, _pipeline->getContext()).release();\n        } else {\n            BSONArrayBuilder bab;\n            for (auto&& stage : _pipeline->serialize())\n                bab << stage;\n            auto spec = collectionless\n                ? DOC(\"pipeline\" << bab.arr())\n                : DOC(\"coll\" << _pipeline->getContext()->ns.coll() << \"pipeline\" << bab.arr());\n            return Value(DOC(getSourceName() << spec));\n        }\n        invariant(pipeCopy);\n        BSONObj explainLocal =\n            pExpCtx->mongoProcessInterface->preparePipelineAndExplain(pipeCopy, *explain);\n        LOGV2_DEBUG(4553501, 3, \"$unionWith attached cursor to pipeline for explain\");\n        invariant(explainLocal.nFields() == 1);\n        auto spec = collectionless ? DOC(\"pipeline\" << explainLocal.firstElement())\n                                   : DOC(\"coll\" << _pipeline->getContext()->ns.coll() << \"pipeline\"\n                                                << explainLocal.firstElement());\n        return Value(DOC(getSourceName() << spec));\n    } else {\n        BSONArrayBuilder bab;\n        for (auto&& stage : _pipeline->serialize())\n            bab << stage;\n        auto spec = collectionless\n            ? DOC(\"pipeline\" << bab.arr())\n            : DOC(\"coll\" << _pipeline->getContext()->ns.coll() << \"pipeline\" << bab.arr());\n        return Value(DOC(getSourceName() << spec));\n    }\n}", "target": 0}
{"code": "static inline struct cfs_rq *cpu_cfs_rq(struct cfs_rq *cfs_rq, int this_cpu)\n{\n\treturn cfs_rq->tg->cfs_rq[this_cpu];\n}", "target": 0}
{"code": "dirserv_get_nickname_by_digest(const char *digest)\n{\n  router_status_t *status;\n  if (!fingerprint_list)\n    return NULL;\n  tor_assert(digest);\n  status = digestmap_get(fingerprint_list->status_by_digest, digest);\n  return status ? status->nickname : NULL;\n}", "target": 0}
{"code": "sid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}", "target": 0}
{"code": "void ThreadWatcher::OnCheckResponsiveness(uint64 ping_sequence_number) {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  if (!active_) {\n    responsive_ = true;\n    return;\n  }\n  if (ping_sequence_number_ != ping_sequence_number) {\n    ResetHangCounters();\n    responsive_ = true;\n    return;\n  }\n  GotNoResponse();\n  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&ThreadWatcher::OnCheckResponsiveness,\n                 weak_ptr_factory_.GetWeakPtr(), ping_sequence_number_),\n      unresponsive_time_);\n  responsive_ = false;\n}", "target": 0}
{"code": "static int test_mod_exp(int i)\n{\n    const MOD_EXP_TEST *test = &ModExpTests[i];\n    int res = 0;\n    BIGNUM* result = NULL;\n    BIGNUM *base = NULL, *exponent = NULL, *modulo = NULL;\n    char *s = NULL;\n    if (!TEST_ptr(result = BN_new())\n            || !TEST_true(BN_dec2bn(&base, test->base))\n            || !TEST_true(BN_dec2bn(&exponent, test->exp))\n            || !TEST_true(BN_dec2bn(&modulo, test->mod)))\n        goto err;\n    if (!TEST_int_eq(BN_mod_exp(result, base, exponent, modulo, ctx), 1))\n        goto err;\n    if (!TEST_ptr(s = BN_bn2dec(result)))\n        goto err;\n    if (!TEST_mem_eq(s, strlen(s), test->res, strlen(test->res)))\n        goto err;\n    res = 1;\n err:\n    OPENSSL_free(s);\n    BN_free(result);\n    BN_free(base);\n    BN_free(exponent);\n    BN_free(modulo);\n    return res;\n}", "target": 0}
{"code": "free_tmp_table(THD *thd, TABLE *entry)\n{\n  MEM_ROOT own_root= entry->mem_root;\n  const char *save_proc_info;\n  DBUG_ENTER(\"free_tmp_table\");\n  DBUG_PRINT(\"enter\",(\"table: %s  alias: %s\",entry->s->table_name.str,\n                      entry->alias.c_ptr()));\n  save_proc_info=thd->proc_info;\n  THD_STAGE_INFO(thd, stage_removing_tmp_table);\n  if (entry->file && entry->is_created())\n  {\n    entry->file->ha_index_or_rnd_end();\n    if (entry->db_stat)\n    {\n      entry->file->info(HA_STATUS_VARIABLE);\n      thd->tmp_tables_size+= (entry->file->stats.data_file_length +\n                              entry->file->stats.index_file_length);\n      entry->file->ha_drop_table(entry->s->path.str);\n    }\n    else\n      entry->file->ha_delete_table(entry->s->path.str);\n    delete entry->file;\n  }\n  for (Field **ptr=entry->field ; *ptr ; ptr++)\n    (*ptr)->free();\n  if (entry->temp_pool_slot != MY_BIT_NONE)\n    bitmap_lock_clear_bit(&temp_pool, entry->temp_pool_slot);\n  plugin_unlock(0, entry->s->db_plugin);\n  entry->alias.free();\n  if (entry->pos_in_table_list && entry->pos_in_table_list->table)\n  {\n    DBUG_ASSERT(entry->pos_in_table_list->table == entry);\n    entry->pos_in_table_list->table= NULL;\n  }\n  free_root(&own_root, MYF(0)); \n  thd_proc_info(thd, save_proc_info);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){\n  int rc = SQLITE_OK;\n  UNUSED_PARAMETER(iSavepoint);\n  assert( ((Fts3Table *)pVtab)->inTransaction );\n  assert( ((Fts3Table *)pVtab)->mxSavepoint < iSavepoint );\n  TESTONLY( ((Fts3Table *)pVtab)->mxSavepoint = iSavepoint );\n  if( ((Fts3Table *)pVtab)->bIgnoreSavepoint==0 ){\n    rc = fts3SyncMethod(pVtab);\n  }\n  return rc;\n}", "target": 0}
{"code": "static void add_dhcpv6_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tunsigned char *buf, int max_buf,\n\t\t\t\tunsigned char **ptr_buf)\n{\n\tstruct hash_params params = {\n\t\t.buf = buf,\n\t\t.max_buf = max_buf,\n\t\t.ptr_buf = ptr_buf\n\t};\n\tif (dhcp_client->type != G_DHCP_IPV6)\n\t\treturn;\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_dhcpv6_binary_option, &params);\n\t*ptr_buf = *params.ptr_buf;\n}", "target": 0}
{"code": "ProcPolyPoint(ClientPtr client)\n{\n    int npoint;\n    GC *pGC;\n    DrawablePtr pDraw;\n    REQUEST(xPolyPointReq);\n    REQUEST_AT_LEAST_SIZE(xPolyPointReq);\n    if ((stuff->coordMode != CoordModeOrigin) &&\n        (stuff->coordMode != CoordModePrevious)) {\n        client->errorValue = stuff->coordMode;\n        return BadValue;\n    }\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyPointReq));\n    if (npoint)\n        (*pGC->ops->PolyPoint) (pDraw, pGC, stuff->coordMode, npoint,\n                                (xPoint *) &stuff[1]);\n    return Success;\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitSIMDConst(Expression*& out, uint32_t code) {\n  if (code != BinaryConsts::V128Const) {\n    return false;\n  }\n  auto* curr = allocator.alloc<Const>();\n  curr->value = getVec128Literal();\n  curr->finalize();\n  out = curr;\n  return true;\n}", "target": 0}
{"code": "    absl::optional<absl::string_view> result() const {\n      ASSERT((!result_.has_value() && result_backing_string_.empty()) ||\n             (result_.has_value() ^ !result_backing_string_.empty()));\n      return !result_backing_string_.empty() ? result_backing_string_ : result_;\n    }", "target": 0}
{"code": "static bool torture_winbind_struct_setpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\ttorture_comment(torture, \"Running WINBINDD_SETPWENT (struct based)\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SETPWENT, &req, &rep);\n\treturn true;\n}", "target": 0}
{"code": "rb_enc_reg_raise(const char *s, long len, rb_encoding *enc, int options, const char *err)\n{\n    rb_exc_raise(rb_enc_reg_error_desc(s, len, enc, options, err));\n}", "target": 0}
{"code": "epo_check_and_install(gx_device *dev)\n{\n    int code = 0;\n    bool is_installed;\n    bool can_optimize = false;\n    if (gs_debug_c(gs_debug_flag_epo_disable)) {\n        return code;\n    }\n    DPRINTF1(dev->memory, \"current device is %s\\n\", dev->dname);\n    is_installed = is_device_installed(dev, EPO_DEVICENAME);\n    if (is_installed) {\n        DPRINTF1(dev->memory, \"device %s already installed\\n\", EPO_DEVICENAME);\n        if (dev->child) {\n            can_optimize = device_wants_optimization(dev->child);\n        }\n        if (!can_optimize) {\n            DPRINTF1(dev->memory, \"child %s can't be optimized, uninstalling\\n\", dev->child->dname);\n            gx_device_unsubclass(dev);        \n            return code;\n        }\n    } else {\n        can_optimize = device_wants_optimization(dev);\n    }\n    if (is_installed) {\n        return code;\n    }\n    if (!can_optimize) {\n        DPRINTF(dev->memory, \"device doesn't want optimization, not installing\\n\");\n        return code;\n    }\n    code = gx_device_subclass(dev, (gx_device *)&gs_epo_device, sizeof(erasepage_subclass_data));\n    if (code < 0) {\n        DPRINTF1(dev->memory, \"ERROR installing device %s\\n\", EPO_DEVICENAME);\n        return code;\n    }\n    DPRINTF1(dev->memory, \"SUCCESS installed device %s\\n\", dev->dname);\n    return code;\n}", "target": 0}
{"code": "static int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t  NFC_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "    void Image::clearXmpData()\n    {\n        xmpData_.clear();\n        writeXmpFromPacket(false);\n    }", "target": 0}
{"code": "xfs_inode_set_cowblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\ttrace_xfs_inode_set_cowblocks_tag(ip);\n\treturn __xfs_inode_set_blocks_tag(ip, xfs_queue_cowblocks,\n\t\t\ttrace_xfs_perag_set_cowblocks,\n\t\t\tXFS_ICI_COWBLOCKS_TAG);\n}", "target": 0}
{"code": "static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)\n{\n  return tree->tree1d[index];\n}", "target": 0}
{"code": "static void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.nested_run_pending = 0;\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\t}\n\tfree_nested(to_vmx(vcpu));\n}", "target": 0}
{"code": "void audit_syscall_entry(int arch, int major,\n\t\t\t unsigned long a1, unsigned long a2,\n\t\t\t unsigned long a3, unsigned long a4)\n{\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *context = tsk->audit_context;\n\tenum audit_state     state;\n\tBUG_ON(!context);\n\tif (context->in_syscall) {\n\t\tstruct audit_context *newctx;\n#if AUDIT_DEBUG\n\t\tprintk(KERN_ERR\n\t\t       \"audit(:%d) pid=%d in syscall=%d;\"\n\t\t       \" entering syscall=%d\\n\",\n\t\t       context->serial, tsk->pid, context->major, major);\n#endif\n\t\tnewctx = audit_alloc_context(context->state);\n\t\tif (newctx) {\n\t\t\tnewctx->previous   = context;\n\t\t\tcontext\t\t   = newctx;\n\t\t\ttsk->audit_context = newctx;\n\t\t} else\t{\n\t\t\taudit_zero_context(context, context->state);\n\t\t}\n\t}\n\tBUG_ON(context->in_syscall || context->name_count);\n\tif (!audit_enabled)\n\t\treturn;\n\tcontext->arch\t    = arch;\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tstate = context->state;\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && (state == AUDIT_SETUP_CONTEXT || state == AUDIT_BUILD_CONTEXT))\n\t\tstate = audit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_ENTRY]);\n\tif (likely(state == AUDIT_DISABLED))\n\t\treturn;\n\tcontext->serial     = 0;\n\tcontext->ctime      = CURRENT_TIME;\n\tcontext->in_syscall = 1;\n\tcontext->auditable  = !!(state == AUDIT_RECORD_CONTEXT);\n\tcontext->ppid       = 0;\n}", "target": 0}
{"code": "static int rr_unpack_from_tempfile(READ_RECORD *info)\n{\n  if (my_b_read(info->io_cache, info->rec_buf, info->ref_length))\n    return -1;\n  (*info->unpack)(info->addon_field, info->rec_buf,\n                  info->rec_buf + info->ref_length);\n  return 0;\n}", "target": 0}
{"code": "mono_method_get_name (MonoMethod *method)\n{\n\treturn method->name;\n}", "target": 0}
{"code": "int sctp_auth_asoc_init_active_key(struct sctp_association *asoc, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes\t*secret;\n\tstruct sctp_shared_key *ep_key;\n\tif (!sctp_auth_enable || !asoc->peer.auth_capable)\n\t\treturn 0;\n\tep_key = sctp_auth_get_shkey(asoc, asoc->active_key_id);\n\tBUG_ON(!ep_key);\n\tsecret = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\tif (!secret)\n\t\treturn -ENOMEM;\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tasoc->asoc_shared_key = secret;\n\treturn 0;\n}", "target": 0}
{"code": "    void TiffReader::visitMnEntry(TiffMnEntry* object)\n    {\n        assert(object != 0);\n        readTiffEntry(object);\n        TiffFinder finder(0x010f, ifd0Id);\n        pRoot_->accept(finder);\n        TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n        std::string make;\n        if (te && te->pValue()) {\n            make = te->pValue()->toString();\n            object->mn_ = TiffMnCreator::create(object->tag(),\n                                                object->mnGroup_,\n                                                make,\n                                                object->pData_,\n                                                object->size_,\n                                                byteOrder());\n        }\n        if (object->mn_) object->mn_->setStart(object->pData());\n    } ", "target": 0}
{"code": "directory_fetches_from_authorities(const or_options_t *options)\n{\n  const routerinfo_t *me;\n  uint32_t addr;\n  int refuseunknown;\n  if (options->FetchDirInfoEarly)\n    return 1;\n  if (options->BridgeRelay == 1)\n    return 0;\n  if (server_mode(options) &&\n      router_pick_published_address(options, &addr, 1) < 0)\n    return 1; \n  refuseunknown = ! router_my_exit_policy_is_reject_star() &&\n    should_refuse_unknown_exits(options);\n  if (!dir_server_mode(options) && !refuseunknown)\n    return 0;\n  if (!server_mode(options) || !advertised_server_mode())\n    return 0;\n  me = router_get_my_routerinfo();\n  if (!me || (!me->supports_tunnelled_dir_requests && !refuseunknown))\n    return 0; \n  return 1;\n}", "target": 0}
{"code": "win_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n    if (after == NULL)\t    \n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}", "target": 0}
{"code": "ldns_str2rdf_mnemonic4int8(ldns_lookup_table *lt,\n\t\tldns_rdf **rd, const char *str)\n{\n\tif ((lt = ldns_lookup_by_name(lt, str))) {\n\t\t*rd = ldns_native2rdf_int8(LDNS_RDF_TYPE_INT8, (uint8_t) lt->id);\n\t\tif (!*rd)\n\t\t\treturn LDNS_STATUS_ERR;\n\t\telse\n\t\t\treturn LDNS_STATUS_OK;\n\t}\n\treturn ldns_str2rdf_int8(rd, str);\n}", "target": 0}
{"code": "trace_recursive_lock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned int val = cpu_buffer->current_context;\n\tunsigned long pc = preempt_count();\n\tint bit;\n\tif (!(pc & (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))\n\t\tbit = RB_CTX_NORMAL;\n\telse\n\t\tbit = pc & NMI_MASK ? RB_CTX_NMI :\n\t\t\tpc & HARDIRQ_MASK ? RB_CTX_IRQ : RB_CTX_SOFTIRQ;\n\tif (unlikely(val & (1 << (bit + cpu_buffer->nest)))) {\n\t\tbit = RB_CTX_TRANSITION;\n\t\tif (val & (1 << (bit + cpu_buffer->nest))) {\n\t\t\tdo_ring_buffer_record_recursion();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tval |= (1 << (bit + cpu_buffer->nest));\n\tcpu_buffer->current_context = val;\n\treturn 0;\n}", "target": 0}
{"code": "print_addr_index (unsigned int idx, unsigned int len)\n{\n  static char buf[15];\n  snprintf (buf, sizeof (buf), \"[%d]\", idx);\n  printf (\"%*s \", len, buf);\n}", "target": 0}
{"code": "bool SyncManager::SyncInternal::SignIn(const SyncCredentials& credentials) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK(share_.name.empty());\n  share_.name = credentials.email;\n  DVLOG(1) << \"Signing in user: \" << username_for_share();\n  if (!OpenDirectory())\n    return false;\n  syncable::ScopedDirLookup lookup(dir_manager(), username_for_share());\n  std::string unique_id;\n  std::string state;\n  if (lookup.good()) {\n    unique_id = lookup->cache_guid();\n    state = lookup->GetNotificationState();\n    DVLOG(1) << \"Read notification unique ID: \" << unique_id;\n    if (VLOG_IS_ON(1)) {\n      std::string encoded_state;\n      base::Base64Encode(state, &encoded_state);\n      DVLOG(1) << \"Read notification state: \" << encoded_state;\n    }\n    allstatus_.SetUniqueId(unique_id);\n  } else {\n    LOG(ERROR) << \"Could not read notification unique ID/state\";\n  }\n  sync_notifier_->SetUniqueId(unique_id);\n  sync_notifier_->SetState(state);\n  UpdateCredentials(credentials);\n  UpdateEnabledTypes();\n  return true;\n}", "target": 0}
{"code": "int RGWPutObj_ObjStore_S3::get_data(bufferlist& bl)\n{\n  const int ret = RGWPutObj_ObjStore::get_data(bl);\n  if (ret == 0) {\n    const int ret_auth = do_aws4_auth_completion();\n    if (ret_auth < 0) {\n      return ret_auth;\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "static ssize_t broadcast_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tif (dev_isalive(ndev))\n\t\treturn sysfs_format_mac(buf, ndev->broadcast, ndev->addr_len);\n\treturn -EINVAL;", "target": 0}
{"code": "static void __iommu_flush_iotlb(struct intel_iommu *iommu, u16 did,\n\t\t\t\tu64 addr, unsigned int size_order, u64 type)\n{\n\tint tlb_offset = ecap_iotlb_offset(iommu->ecap);\n\tu64 val = 0, val_iva = 0;\n\tunsigned long flag;\n\tswitch (type) {\n\tcase DMA_TLB_GLOBAL_FLUSH:\n\t\tval = DMA_TLB_GLOBAL_FLUSH|DMA_TLB_IVT;\n\t\tbreak;\n\tcase DMA_TLB_DSI_FLUSH:\n\t\tval = DMA_TLB_DSI_FLUSH|DMA_TLB_IVT|DMA_TLB_DID(did);\n\t\tbreak;\n\tcase DMA_TLB_PSI_FLUSH:\n\t\tval = DMA_TLB_PSI_FLUSH|DMA_TLB_IVT|DMA_TLB_DID(did);\n\t\tval_iva = size_order | addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n#if 0\n\tif (cap_read_drain(iommu->cap))\n\t\tval |= DMA_TLB_READ_DRAIN;\n#endif\n\tif (cap_write_drain(iommu->cap))\n\t\tval |= DMA_TLB_WRITE_DRAIN;\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tif (val_iva)\n\t\tdmar_writeq(iommu->reg + tlb_offset, val_iva);\n\tdmar_writeq(iommu->reg + tlb_offset + 8, val);\n\tIOMMU_WAIT_OP(iommu, tlb_offset + 8,\n\t\tdmar_readq, (!(val & DMA_TLB_IVT)), val);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\tif (DMA_TLB_IAIG(val) == 0)\n\t\tpr_err(\"Flush IOTLB failed\\n\");\n\tif (DMA_TLB_IAIG(val) != DMA_TLB_IIRG(type))\n\t\tpr_debug(\"TLB flush request %Lx, actual %Lx\\n\",\n\t\t\t(unsigned long long)DMA_TLB_IIRG(type),\n\t\t\t(unsigned long long)DMA_TLB_IAIG(val));\n}", "target": 0}
{"code": "static inline int pskb_network_may_pull(struct sk_buff *skb, unsigned int len)\n{\n\treturn pskb_may_pull(skb, skb_network_offset(skb) + len);\n}", "target": 0}
{"code": "u32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}", "target": 0}
{"code": "long keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tlong ret;\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\tret = keyring_clear(key_ref_to_ptr(keyring_ref));\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n} ", "target": 0}
{"code": "devirtualization_time_bonus (struct cgraph_node *node,\n\t\t\t     vec<tree> known_csts,\n\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n\t\t\t     vec<ipa_agg_value_set> known_aggs)\n{\n  struct cgraph_edge *ie;\n  int res = 0;\n  for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n    {\n      struct cgraph_node *callee;\n      class ipa_fn_summary *isummary;\n      enum availability avail;\n      tree target;\n      bool speculative;\n      target = ipa_get_indirect_edge_target (ie, known_csts, known_contexts,\n\t\t\t\t\t     known_aggs, &speculative);\n      if (!target)\n\tcontinue;\n      res += 1;\n      callee = cgraph_node::get (target);\n      if (!callee || !callee->definition)\n\tcontinue;\n      callee = callee->function_symbol (&avail);\n      if (avail < AVAIL_AVAILABLE)\n\tcontinue;\n      isummary = ipa_fn_summaries->get (callee);\n      if (!isummary->inlinable)\n\tcontinue;\n      int size = ipa_size_summaries->get (callee)->size;\n      int max_inline_insns_auto\n\t= opt_for_fn (callee->decl, param_max_inline_insns_auto);\n      if (size <= max_inline_insns_auto / 4)\n\tres += 31 / ((int)speculative + 1);\n      else if (size <= max_inline_insns_auto / 2)\n\tres += 15 / ((int)speculative + 1);\n      else if (size <= max_inline_insns_auto\n\t       || DECL_DECLARED_INLINE_P (callee->decl))\n\tres += 7 / ((int)speculative + 1);\n    }\n  return res;\n}", "target": 0}
{"code": "static inline void __range_cloexec(struct files_struct *cur_fds,\n\t\t\t\t   unsigned int fd, unsigned int max_fd)\n{\n\tstruct fdtable *fdt;\n\tspin_lock(&cur_fds->file_lock);\n\tfdt = files_fdtable(cur_fds);\n\tmax_fd = min(last_fd(fdt), max_fd);\n\tif (fd <= max_fd)\n\t\tbitmap_set(fdt->close_on_exec, fd, max_fd - fd + 1);\n\tspin_unlock(&cur_fds->file_lock);\n}", "target": 0}
{"code": "static void GetMedianPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  SkipList\n    *list;\n  ssize_t\n    channel;\n  size_t\n    color;\n  ssize_t\n    count;\n  unsigned short\n    channels[ListChannels];\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    channels[channel]=(unsigned short) color;\n  }\n  GetMagickPixelPacket((const Image *) NULL,pixel);\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}", "target": 0}
{"code": "void Item_cache::set_null()\n{\n  if (maybe_null)\n  {\n    null_value= TRUE;\n    value_cached= TRUE;\n  }\n}", "target": 0}
{"code": "void GfxCalGrayColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    GfxRGB rgb;\n#ifdef USE_CMS\n    if (transform && transform->getTransformPixelType() == PT_GRAY) {\n        unsigned char out[gfxColorMaxComps];\n        double in[gfxColorMaxComps];\n        double X, Y, Z;\n        getXYZ(color, &X, &Y, &Z);\n        in[0] = clip01(X);\n        in[1] = clip01(Y);\n        in[2] = clip01(Z);\n        transform->doTransform(in, out, 1);\n        *gray = byteToCol(out[0]);\n        return;\n    }\n#endif\n    getRGB(color, &rgb);\n    *gray = clip01((GfxColorComp)(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b + 0.5));\n}", "target": 0}
{"code": "void btrfs_scrub_continue(struct btrfs_fs_info *fs_info)\n{\n\tatomic_dec(&fs_info->scrub_pause_req);\n\twake_up(&fs_info->scrub_pause_wait);\n}", "target": 0}
{"code": "d_lite_friday_p(VALUE self)\n{\n    get_d1(self);\n    return f_boolcast(m_wday(dat) == 5);\n}", "target": 0}
{"code": "void gf_net_get_ntp(u32 *sec, u32 *frac)\n{\n\tu64 frac_part;\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\tif (sec) {\n\t\t*sec = (u32) (now.tv_sec) + ntp_shift;\n\t}\n\tif (frac) {\n\t\tfrac_part = now.tv_usec * 0xFFFFFFFFULL;\n\t\tfrac_part /= 1000000;\n\t\t*frac = (u32) ( frac_part );\n\t}\n}", "target": 0}
{"code": "int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,\n\t\t\t\t   struct\n\t\t\t\t   kvm_userspace_memory_region *mem,\n\t\t\t\t   int user_alloc)\n{\n\tif (mem->slot >= KVM_MEMORY_SLOTS)\n\t\treturn -EINVAL;\n\treturn kvm_set_memory_region(kvm, mem, user_alloc);\n}", "target": 0}
{"code": "openssl_enc(const EVP_CIPHER * cipher, const unsigned char *key, const unsigned char *iv,\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\tint r = SC_ERROR_INTERNAL;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tint outl = 0;\n\tint outl_tmp = 0;\n\tunsigned char iv_tmp[EVP_MAX_IV_LENGTH] = { 0 };\n\tmemcpy(iv_tmp, iv, EVP_MAX_IV_LENGTH);\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL)\n\t\tgoto out;\n\tEVP_EncryptInit_ex(ctx, cipher, NULL, key, iv_tmp);\n\tEVP_CIPHER_CTX_set_padding(ctx, 0);\n\tif (!EVP_EncryptUpdate(ctx, output, &outl, input, length))\n\t\tgoto out;\n\tif (!EVP_EncryptFinal_ex(ctx, output + outl, &outl_tmp))\n\t\tgoto out;\n\tr = SC_SUCCESS;\nout:\n\tif (ctx)\n\t    EVP_CIPHER_CTX_free(ctx);\n\treturn r;\n}", "target": 0}
{"code": "static sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}", "target": 0}
{"code": "lexer_consume_generator (parser_context_t *context_p) \n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n  if (context_p->source_p >= context_p->source_end_p || context_p->source_p[0] != LIT_CHAR_ASTERISK\n      || (context_p->source_p + 1 < context_p->source_end_p\n          && (context_p->source_p[1] == LIT_CHAR_EQUALS || context_p->source_p[1] == LIT_CHAR_ASTERISK)))\n  {\n    return false;\n  }\n  lexer_consume_next_character (context_p);\n  context_p->token.type = LEXER_MULTIPLY;\n  return true;\n} ", "target": 0}
{"code": "static int acl_extended(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tstruct ldb_control *as_system = ldb_request_get_control(req, LDB_CONTROL_AS_SYSTEM_OID);\n\tif (strcmp(req->op.extended.oid,\n\t\t   LDB_EXTENDED_SEQUENCE_NUMBER) == 0) {\n\t\treturn ldb_next_request(module, req);\n\t}\n\tif (dsdb_module_am_system(module) ||\n\t    dsdb_module_am_administrator(module) || as_system) {\n\t\treturn ldb_next_request(module, req);\n\t} else {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"acl_extended: \"\n\t\t\t\t       \"attempted database modify not permitted. \"\n\t\t\t\t       \"User %s is not SYSTEM or an administrator\",\n\t\t\t\t       acl_user_name(req, module));\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n}", "target": 0}
{"code": "void tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "LibRaw_file_datastream::~LibRaw_file_datastream()\n{\n  if (jas_file)\n    fclose(jas_file);\n}", "target": 0}
{"code": "void RenderViewTest::SendWebKeyboardEvent(\n    const blink::WebKeyboardEvent& key_event) {\n  SendInputEvent(key_event);\n}", "target": 0}
{"code": "static int _make_remark_format(struct pwb_context *ctx, int type, const char *format, ...)\n{\n\tint ret;\n\tva_list args;\n\tva_start(args, format);\n\tret = _make_remark_v(ctx, type, format, args);\n\tva_end(args);\n\treturn ret;\n}", "target": 0}
{"code": "static void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0, contiguous_blks = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tcontiguous_blks++;\n\t\t\tclear_buffer_delay(bh);\n\t\t} else if (contiguous_blks) {\n\t\t\tlblk = page->index <<\n\t\t\t       (PAGE_SHIFT - inode->i_blkbits);\n\t\t\tlblk += (curr_off >> inode->i_blkbits) -\n\t\t\t\tcontiguous_blks;\n\t\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t\t\tcontiguous_blks = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\tif (contiguous_blks) {\n\t\tlblk = page->index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlblk += (curr_off >> inode->i_blkbits) - contiguous_blks;\n\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t}\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\t\tnum_clusters--;\n\t}\n}", "target": 0}
{"code": "static void assign_proto_idx(struct proto *prot)\n{\n\tprot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);\n\tif (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {\n\t\tpr_err(\"PROTO_INUSE_NR exhausted\\n\");\n\t\treturn;\n\t}\n\tset_bit(prot->inuse_idx, proto_inuse_idx);\n}", "target": 0}
{"code": "ppp_get_stats(struct ppp *ppp, struct ppp_stats *st)\n{\n\tstruct slcompress *vj = ppp->vj;\n\tmemset(st, 0, sizeof(*st));\n\tst->p.ppp_ipackets = ppp->dev->stats.rx_packets;\n\tst->p.ppp_ierrors = ppp->dev->stats.rx_errors;\n\tst->p.ppp_ibytes = ppp->dev->stats.rx_bytes;\n\tst->p.ppp_opackets = ppp->dev->stats.tx_packets;\n\tst->p.ppp_oerrors = ppp->dev->stats.tx_errors;\n\tst->p.ppp_obytes = ppp->dev->stats.tx_bytes;\n\tif (!vj)\n\t\treturn;\n\tst->vj.vjs_packets = vj->sls_o_compressed + vj->sls_o_uncompressed;\n\tst->vj.vjs_compressed = vj->sls_o_compressed;\n\tst->vj.vjs_searches = vj->sls_o_searches;\n\tst->vj.vjs_misses = vj->sls_o_misses;\n\tst->vj.vjs_errorin = vj->sls_i_error;\n\tst->vj.vjs_tossed = vj->sls_i_tossed;\n\tst->vj.vjs_uncompressedin = vj->sls_i_uncompressed;\n\tst->vj.vjs_compressedin = vj->sls_i_compressed;\n}", "target": 0}
{"code": "bool vgacon_text_force(void)\n{\n\treturn vgacon_text_mode_force;\n}", "target": 0}
{"code": "PassRefPtrWillBeRawPtr<TagCollection> ContainerNode::getElementsByTagName(const AtomicString& localName)\n{\n    if (localName.isNull())\n        return nullptr;\n    if (document().isHTMLDocument())\n        return ensureCachedCollection<HTMLTagCollection>(HTMLTagCollectionType, localName);\n    return ensureCachedCollection<TagCollection>(TagCollectionType, localName);\n}", "target": 0}
{"code": "void Shell::HideShelf() {\n  RootWindowControllerList controllers = GetAllRootWindowControllers();\n  for (RootWindowControllerList::iterator iter = controllers.begin();\n       iter != controllers.end(); ++iter) {\n    if ((*iter)->shelf())\n      (*iter)->shelf()->ShutdownStatusAreaWidget();\n  }\n}", "target": 0}
{"code": "int acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)\n{\n\treturn -EINVAL;\n}", "target": 0}
{"code": "smb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\tif (unlock && !lock)\n\t\ttype = SMB2_LOCKFLAG_UNLOCK;\n\treturn SMB2_lock(xid, tlink_tcon(cfile->tlink),\n\t\t\t cfile->fid.persistent_fid, cfile->fid.volatile_fid,\n\t\t\t current->tgid, length, offset, type, wait);\n}", "target": 0}
{"code": "static int fts3MatchinfoSelectDoctotal(\n  Fts3Table *pTab,\n  sqlite3_stmt **ppStmt,\n  sqlite3_int64 *pnDoc,\n  const char **paLen\n){\n  sqlite3_stmt *pStmt;\n  const char *a;\n  sqlite3_int64 nDoc;\n  if( !*ppStmt ){\n    int rc = sqlite3Fts3SelectDoctotal(pTab, ppStmt);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  pStmt = *ppStmt;\n  assert( sqlite3_data_count(pStmt)==1 );\n  a = sqlite3_column_blob(pStmt, 0);\n  a += sqlite3Fts3GetVarint(a, &nDoc);\n  if( nDoc==0 ) return FTS_CORRUPT_VTAB;\n  *pnDoc = (u32)nDoc;\n  if( paLen ) *paLen = a;\n  return SQLITE_OK;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::AcceleratedSurfaceBuffersSwapped(\n    const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params_in_pixel,\n    int gpu_host_id) {\n  BufferPresentedCallback ack_callback = base::Bind(\n      &AcknowledgeBufferForGpu,\n      params_in_pixel.route_id,\n      gpu_host_id,\n      params_in_pixel.mailbox_name);\n  BuffersSwapped(params_in_pixel.size,\n                 gfx::Rect(params_in_pixel.size),\n                 params_in_pixel.scale_factor,\n                 params_in_pixel.mailbox_name,\n                 params_in_pixel.latency_info,\n                 ack_callback);\n}", "target": 0}
{"code": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}", "target": 0}
{"code": "    virtual WebNavigationPolicy decidePolicyForNavigation(\n        WebFrame*, const WebURLRequest&, WebNavigationType,\n        WebNavigationPolicy defaultPolicy, bool isRedirect)\n    {\n        EXPECT_FALSE(isRedirect);\n        return WebNavigationPolicyCurrentTab;\n    }", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_should_interrupt_javascript(Ewk_View_Smart_Data* smartData)\n{\n    INF(\"should interrupt javascript?\\n\"\n        \"\\t(HARD CODED) NO\");\n    return false;\n}", "target": 0}
{"code": "  void OnTimeout() {\n    LOG_IF(ERROR, is_removing_) << \"Timed out\";\n    SignalDone();\n  }", "target": 0}
{"code": "static gboolean send_probe_packet(gpointer dhcp_data)\n{\n\tGDHCPClient *dhcp_client;\n\tguint timeout;\n\tdhcp_client = dhcp_data;\n\tif (dhcp_client->requested_ip == 0) {\n\t\tdebug(dhcp_client, \"pick a new random address\");\n\t\tdhcp_client->requested_ip = arp_random_ip();\n\t}\n\tdebug(dhcp_client, \"sending IPV4LL probe request\");\n\tif (dhcp_client->retry_times == 1) {\n\t\tdhcp_client->state = IPV4LL_PROBE;\n\t\tswitch_listening_mode(dhcp_client, L_ARP);\n\t}\n\tarp_send_packet(dhcp_client->mac_address, 0,\n\t\t\tdhcp_client->requested_ip, dhcp_client->ifindex);\n\tif (dhcp_client->retry_times < PROBE_NUM) {\n\t\ttimeout = __connman_util_random_delay_ms(PROBE_MAX-PROBE_MIN);\n\t\ttimeout += PROBE_MIN*1000;\n\t} else\n\t\ttimeout = (ANNOUNCE_WAIT * 1000);\n\tdhcp_client->timeout = g_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\t\t\t timeout,\n\t\t\t\t\t\t ipv4ll_probe_timeout,\n\t\t\t\t\t\t dhcp_client,\n\t\t\t\t\t\t NULL);\n\treturn FALSE;\n}", "target": 0}
{"code": "  void ReadPixels(\n      GLint x, GLint y, GLsizei width, GLsizei height,\n      GLenum format, GLenum type, void* pixels) const {\n    DCHECK_GE(x, 0);\n    DCHECK_GE(y, 0);\n    DCHECK_LE(x + width, width_);\n    DCHECK_LE(y + height, height_);\n    for (GLint yy = 0; yy < height; ++yy) {\n      const int8* src = GetPixelAddress(x, y + yy);\n      const void* dst = ComputePackAlignmentAddress(0, yy, width, pixels);\n      memcpy(const_cast<void*>(dst), src, width * bytes_per_pixel_);\n    }\n  }", "target": 0}
{"code": "static int __tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tu32 type, lower, upper;\n\tstruct nlattr *publ[TIPC_NLA_PUBL_MAX + 1];\n\tint err;\n\tif (!attrs[TIPC_NLA_PUBL])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(publ, TIPC_NLA_PUBL_MAX, attrs[TIPC_NLA_PUBL],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\ttype = nla_get_u32(publ[TIPC_NLA_PUBL_TYPE]);\n\tlower = nla_get_u32(publ[TIPC_NLA_PUBL_LOWER]);\n\tupper = nla_get_u32(publ[TIPC_NLA_PUBL_UPPER]);\n\tif (lower == upper)\n\t\ttipc_tlv_sprintf(msg->rep, \" {%u,%u}\", type, lower);\n\telse\n\t\ttipc_tlv_sprintf(msg->rep, \" {%u,%u,%u}\", type, lower, upper);\n\treturn 0;\n}", "target": 0}
{"code": "static int req_remaining_field(request_rec *r)\n{\n    return r->remaining;\n}", "target": 0}
{"code": "static inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}", "target": 0}
{"code": "  void StopOnIOThread() {\n    ASSERT_TRUE(BrowserThread::CurrentlyOn(BrowserThread::IO));\n    EXPECT_EQ(EmbeddedWorkerInstance::RUNNING, worker_->status());\n    ServiceWorkerStatusCode status = worker_->Stop();\n    last_worker_status_ = worker_->status();\n    EXPECT_EQ(SERVICE_WORKER_OK, status);\n    EXPECT_EQ(EmbeddedWorkerInstance::STOPPING, last_worker_status_);\n    if (status != SERVICE_WORKER_OK && !done_closure_.is_null())\n      done_closure_.Run();\n  }", "target": 0}
{"code": "imapx_server_info_changed_cb (CamelIMAPXSummary *summary,\n\t\t\t      CamelMessageInfo *info,\n\t\t\t      gpointer user_data)\n{\n\tGHashTable *changed_meanwhile = user_data;\n\tg_return_if_fail (info != NULL);\n\tg_return_if_fail (changed_meanwhile != NULL);\n\tif (camel_message_info_uid (info)) {\n\t\tg_hash_table_insert (changed_meanwhile,\n\t\t\t(gpointer) camel_pstring_strdup (camel_message_info_uid (info)),\n\t\t\tGINT_TO_POINTER (1));\n\t}\n}", "target": 0}
{"code": "G711::G711(Mode mode, _Track *track, AFvirtualfile *fh, bool canSeek) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_savedPositionNextFrame(-1),\n\tm_savedNextFrame(-1)\n{\n\tif (mode == Decompress)\n\t\ttrack->f.compressionParams = AU_NULL_PVLIST;\n}", "target": 0}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void vmacache_update(unsigned long addr, struct vm_area_struct *newvma)\n{\n\tif (vmacache_valid_mm(newvma->vm_mm))\n\t\tcurrent->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;\n}", "target": 0}
{"code": "static void pp_error_list_macros(errflags severity)\n{\n    const MMacro *m;\n    severity |= ERR_PP_LISTMACRO | ERR_NO_SEVERITY | ERR_HERE;\n    while ((m = src_error_down())) {\n        if ((m->nolist & NL_LIST) || !m->where.filename)\n            break;\n\tnasm_error(severity, \"... from macro `%s' defined\", m->name);\n    }\n    src_error_reset();\n}", "target": 0}
{"code": "EXPORTED time_t calc_compile_time(const char *time, const char *date)\n{\n    struct tm tm;\n    char month[4];\n    memset(&tm, 0, sizeof(struct tm));\n    tm.tm_isdst = -1;\n    sscanf(time, \"%02d:%02d:%02d\", &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n    sscanf(date, \"%3s %2d %4d\", month, &tm.tm_mday, &tm.tm_year);\n    tm.tm_year -= 1900;\n    for (tm.tm_mon = 0; tm.tm_mon < 12; tm.tm_mon++) {\n        if (!strcmp(month, monthname[tm.tm_mon])) break;\n    }\n    return mktime(&tm);\n}", "target": 0}
{"code": "void ewk_view_frame_main_icon_received(Evas_Object* ewkView)\n{\n    DBG(\"ewkView=%p\", ewkView);\n    Evas_Object* frame = ewk_view_frame_main_get(ewkView);\n    evas_object_smart_callback_call(frame, \"icon,received\", 0);\n}", "target": 0}
{"code": "Open_table_context::\nrequest_backoff_action(enum_open_table_action action_arg,\n                       TABLE_LIST *table)\n{\n  if (action_arg == OT_BACKOFF_AND_RETRY && m_has_locks)\n  {\n    my_error(ER_LOCK_DEADLOCK, MYF(0));\n    m_thd->mark_transaction_to_rollback(true);\n    return TRUE;\n  }\n  if (table)\n  {\n    DBUG_ASSERT(action_arg == OT_DISCOVER || action_arg == OT_REPAIR);\n    m_failed_table= (TABLE_LIST*) m_thd->alloc(sizeof(TABLE_LIST));\n    if (m_failed_table == NULL)\n      return TRUE;\n    m_failed_table->init_one_table(table->db, table->db_length,\n                                   table->table_name,\n                                   table->table_name_length,\n                                   table->alias, TL_WRITE);\n    m_failed_table->open_strategy= table->open_strategy;\n    m_failed_table->mdl_request.set_type(MDL_EXCLUSIVE);\n  }\n  m_action= action_arg;\n  return FALSE;\n}", "target": 0}
{"code": "static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\tupdate_pvclock_gtod(tk);\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\treturn 0;\n}", "target": 0}
{"code": "static int me_pagecache_dirty(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping = page_mapping(p);\n\tSetPageError(p);\n\tif (mapping) {\n\t\tmapping_set_error(mapping, -EIO);\n\t}\n\treturn me_pagecache_clean(p, pfn);\n}", "target": 0}
{"code": "RootWindow* RootWindowHostWin::GetRootWindow() {\n  return root_window_;\n}", "target": 0}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n}", "target": 0}
{"code": "bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)\n{\n\tint i, cpu, me;\n\tcpumask_var_t cpus;\n\tbool called = true;\n\tstruct kvm_vcpu *vcpu;\n\tzalloc_cpumask_var(&cpus, GFP_ATOMIC);\n\tme = get_cpu();\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(req, vcpu);\n\t\tcpu = vcpu->cpu;\n\t\tsmp_mb__after_atomic();\n\t\tif (cpus != NULL && cpu != -1 && cpu != me &&\n\t\t      kvm_vcpu_exiting_guest_mode(vcpu) != OUTSIDE_GUEST_MODE)\n\t\t\tcpumask_set_cpu(cpu, cpus);\n\t}\n\tif (unlikely(cpus == NULL))\n\t\tsmp_call_function_many(cpu_online_mask, ack_flush, NULL, 1);\n\telse if (!cpumask_empty(cpus))\n\t\tsmp_call_function_many(cpus, ack_flush, NULL, 1);\n\telse\n\t\tcalled = false;\n\tput_cpu();\n\tfree_cpumask_var(cpus);\n\treturn called;\n}", "target": 0}
{"code": "irc_nick_find_color (const char *nickname)\n{\n    return weechat_info_get (\"nick_color\", nickname);\n}", "target": 0}
{"code": "static bool cli_dfs_check_error(struct cli_state *cli, NTSTATUS expected,\n\t\t\t\tNTSTATUS status)\n{\n\tif (!(smbXcli_conn_use_unicode(cli->conn))) {\n\t\treturn false;\n\t}\n\tif (!(smb1cli_conn_capabilities(cli->conn) & CAP_STATUS32)) {\n\t\treturn false;\n\t}\n\tif (NT_STATUS_EQUAL(status, expected)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int handle_en_event(struct hns_roce_dev *hr_dev, u8 port,\n\t\t\t   unsigned long event)\n{\n\tstruct device *dev = hr_dev->dev;\n\tstruct net_device *netdev;\n\tint ret = 0;\n\tnetdev = hr_dev->iboe.netdevs[port];\n\tif (!netdev) {\n\t\tdev_err(dev, \"port(%d) can't find netdev\\n\", port);\n\t\treturn -ENODEV;\n\t}\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGEADDR:\n\t\tret = hns_roce_set_mac(hr_dev, port, netdev->dev_addr);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"NETDEV event = 0x%x!\\n\", (u32)(event));\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "jd_to_nth_kday(VALUE jd, double sg,\n\t       VALUE *nth, int *rjd,\n\t       int *ry, int *rm, int *rn, int *rk)\n{\n    decode_jd(jd, nth, rjd);\n    c_jd_to_nth_kday(*rjd, sg, ry, rm, rn, rk);\n}", "target": 0}
{"code": "  void DeleteOriginFromDatabase(const GURL& origin, StorageType type) {\n    quota_manager_->DeleteOriginFromDatabase(origin, type);\n  }", "target": 0}
{"code": "isdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}", "target": 0}
{"code": "static int s_show(struct seq_file *m, void *p)\n{\n\tunsigned long nr_partials = 0;\n\tunsigned long nr_slabs = 0;\n\tunsigned long nr_inuse = 0;\n\tunsigned long nr_objs = 0;\n\tunsigned long nr_free = 0;\n\tstruct kmem_cache *s;\n\tint node;\n\ts = list_entry(p, struct kmem_cache, list);\n\tfor_each_online_node(node) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tnr_partials += n->nr_partial;\n\t\tnr_slabs += atomic_long_read(&n->nr_slabs);\n\t\tnr_objs += atomic_long_read(&n->total_objects);\n\t\tnr_free += count_partial(n, count_free);\n\t}\n\tnr_inuse = nr_objs - nr_free;\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\", s->name, nr_inuse,\n\t\t   nr_objs, s->size, oo_objects(s->oo),\n\t\t   (1 << oo_order(s->oo)));\n\tseq_printf(m, \" : tunables %4u %4u %4u\", 0, 0, 0);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\", nr_slabs, nr_slabs,\n\t\t   0UL);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "String openTemporaryFile(const String&, PlatformFileHandle& handle)\n{\n    handle = INVALID_HANDLE_VALUE;\n    wchar_t tempPath[MAX_PATH];\n    int tempPathLength = ::GetTempPathW(WTF_ARRAY_LENGTH(tempPath), tempPath);\n    if (tempPathLength <= 0 || tempPathLength > WTF_ARRAY_LENGTH(tempPath))\n        return String();\n    String proposedPath;\n    do {\n        wchar_t tempFile[] = L\"XXXXXXXX.tmp\"; \n        const int randomPartLength = 8;\n        cryptographicallyRandomValues(tempFile, randomPartLength * sizeof(wchar_t));\n        const char validChars[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n        for (int i = 0; i < randomPartLength; ++i)\n            tempFile[i] = validChars[tempFile[i] % (sizeof(validChars) - 1)];\n        ASSERT(wcslen(tempFile) == WTF_ARRAY_LENGTH(tempFile) - 1);\n        proposedPath = pathByAppendingComponent(tempPath, tempFile);\n        if (proposedPath.isEmpty())\n            break;\n        handle = ::CreateFileW(proposedPath.charactersWithNullTermination(), GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\n    } while (!isHandleValid(handle) && GetLastError() == ERROR_ALREADY_EXISTS);\n    if (!isHandleValid(handle))\n        return String();\n    return proposedPath;\n}", "target": 0}
{"code": "static void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_delete)\n{\n\tzval *pgsql_link, *ids;\n\tchar *table;\n\tsize_t table_len;\n\tzend_ulong option = PGSQL_DML_EXEC;\n\tPGconn *pg_link;\n\tzend_string *sql;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rsa|l\",\n\t\t\t\t\t\t\t  &pgsql_link, &table, &table_len, &ids, &option) == FAILURE) {\n\t\treturn;\n\t}\n\tif (option & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_NO_CONV|PGSQL_DML_EXEC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid option is specified\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (php_pgsql_flush_query(pg_link)) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Detected unhandled result(s) in connection\");\n\t}\n\tif (php_pgsql_delete(pg_link, table, ids, option, &sql) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (option & PGSQL_DML_STRING) {\n\t\tRETURN_STR(sql);\n\t}\n\tRETURN_TRUE;\n} ", "target": 0}
{"code": "    long DataValue::copy(byte* buf, ByteOrder ) const\n    {\n        return static_cast<long>(\n            std::copy(value_.begin(), value_.end(), buf) - buf\n            );\n    }", "target": 0}
{"code": "NotificationService::~NotificationService() {\n  lazy_tls_ptr.Pointer()->Set(NULL);\n#ifndef NDEBUG\n  for (int i = 0; i < NotificationType::NOTIFICATION_TYPE_COUNT; i++) {\n    if (observer_counts_[i] > 0) {\n      LOG(INFO) << observer_counts_[i] << \" notification observer(s) leaked\"\n          << \" of notification type \" << i;\n    }\n  }\n#endif\n  for (int i = 0; i < NotificationType::NOTIFICATION_TYPE_COUNT; i++) {\n    NotificationSourceMap omap = observers_[i];\n    for (NotificationSourceMap::iterator it = omap.begin();\n         it != omap.end(); ++it) {\n      delete it->second;\n    }\n  }\n}", "target": 0}
{"code": "struct rt6_info *rt6_add_dflt_router(const struct in6_addr *gwaddr,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     unsigned int pref)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table\t= RT6_TABLE_DFLT,\n\t\t.fc_metric\t= IP6_RT_PRIO_USER,\n\t\t.fc_ifindex\t= dev->ifindex,\n\t\t.fc_flags\t= RTF_GATEWAY | RTF_ADDRCONF | RTF_DEFAULT |\n\t\t\t\t  RTF_UP | RTF_EXPIRES | RTF_PREF(pref),\n\t\t.fc_nlinfo.portid = 0,\n\t\t.fc_nlinfo.nlh = NULL,\n\t\t.fc_nlinfo.nl_net = dev_net(dev),\n\t};\n\tcfg.fc_gateway = *gwaddr;\n\tip6_route_add(&cfg);\n\treturn rt6_get_dflt_router(gwaddr, dev);\n}", "target": 0}
{"code": "dirserv_count_measured_bws(const smartlist_t *routers)\n{\n  routers_with_measured_bw = 0;\n  SMARTLIST_FOREACH_BEGIN(routers, const routerinfo_t *, ri) {\n    if (dirserv_has_measured_bw(ri->cache_info.identity_digest)) {\n      ++routers_with_measured_bw;\n    }\n  } SMARTLIST_FOREACH_END(ri);\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, SetCollatorChangesCollationUsedForComparisons) {\n    createMatcher(fromjson(\"{$expr: {$eq: ['$x', 'abc']}}\"));\n    auto collator =\n        stdx::make_unique<CollatorInterfaceMock>(CollatorInterfaceMock::MockType::kToLowerString);\n    setCollator(collator.get());\n    ASSERT_TRUE(matches(BSON(\"x\"\n                             << \"AbC\")));\n    ASSERT_FALSE(matches(BSON(\"x\"\n                              << \"cba\")));\n}", "target": 0}
{"code": "acpi_os_map_iomem(acpi_physical_address phys, acpi_size size)\n{\n\tstruct acpi_ioremap *map;\n\tvoid __iomem *virt;\n\tacpi_physical_address pg_off;\n\tacpi_size pg_sz;\n\tif (phys > ULONG_MAX) {\n\t\tprintk(KERN_ERR PREFIX \"Cannot map memory that high\\n\");\n\t\treturn NULL;\n\t}\n\tif (!acpi_gbl_permanent_mmap)\n\t\treturn __acpi_map_table((unsigned long)phys, size);\n\tmutex_lock(&acpi_ioremap_lock);\n\tmap = acpi_map_lookup(phys, size);\n\tif (map) {\n\t\tmap->refcount++;\n\t\tgoto out;\n\t}\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\treturn NULL;\n\t}\n\tpg_off = round_down(phys, PAGE_SIZE);\n\tpg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;\n\tvirt = acpi_map(pg_off, pg_sz);\n\tif (!virt) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\tkfree(map);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&map->list);\n\tmap->virt = virt;\n\tmap->phys = pg_off;\n\tmap->size = pg_sz;\n\tmap->refcount = 1;\n\tlist_add_tail_rcu(&map->list, &acpi_ioremaps);\nout:\n\tmutex_unlock(&acpi_ioremap_lock);\n\treturn map->virt + (phys - map->phys);\n}", "target": 0}
{"code": "XML_StopParser(XML_Parser parser, XML_Bool resumable) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    if (resumable) {\n      parser->m_errorCode = XML_ERROR_SUSPENDED;\n      return XML_STATUS_ERROR;\n    }\n    parser->m_parsingStatus.parsing = XML_FINISHED;\n    break;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  default:\n    if (resumable) {\n#ifdef XML_DTD\n      if (parser->m_isParamEntity) {\n        parser->m_errorCode = XML_ERROR_SUSPEND_PE;\n        return XML_STATUS_ERROR;\n      }\n#endif\n      parser->m_parsingStatus.parsing = XML_SUSPENDED;\n    } else\n      parser->m_parsingStatus.parsing = XML_FINISHED;\n  }\n  return XML_STATUS_OK;\n}", "target": 0}
{"code": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tint        str_len = 0, out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(ch, php_curl *, &zid, -1, le_curl_name, le_curl);\n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len, 1);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "epass2003_select_file(struct sc_card *card, const sc_path_t * in_path,\n\t\tsc_file_t ** file_out)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = sc_path_print(pbuf, sizeof(pbuf), &card->cache.current_path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\tsc_log(card->ctx,\n\t       \"current path (%s, %s): %s (len: %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t       card->cache.current_path.type == SC_PATH_TYPE_DF_NAME ?\n\t       \"aid\" : \"path\",\n\t       card->cache.valid ? \"valid\" : \"invalid\", pbuf,\n\t       card->cache.current_path.len);\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (in_path->len != 2)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\treturn epass2003_select_fid(card, in_path->value[0], in_path->value[1], file_out);\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\treturn epass2003_select_aid(card, in_path, file_out);\n\tcase SC_PATH_TYPE_PATH:\n\t\treturn epass2003_select_path(card, in_path->value, in_path->len, file_out);\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n}", "target": 0}
{"code": "u32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "void UsageTracker::GetHostUsage(\n    const std::string& host, HostUsageCallback* callback) {\n  if (client_tracker_map_.size() == 0) {\n    callback->Run(host, type_, 0);\n    delete callback;\n    return;\n  }\n  if (host_usage_callbacks_.Add(host, callback)) {\n    DCHECK(outstanding_host_usage_.find(host) == outstanding_host_usage_.end());\n    outstanding_host_usage_[host].pending_clients = client_tracker_map_.size();\n    for (ClientTrackerMap::iterator iter = client_tracker_map_.begin();\n         iter != client_tracker_map_.end();\n         ++iter) {\n      iter->second->GetHostUsage(host, callback_factory_.NewCallback(\n          &UsageTracker::DidGetClientHostUsage));\n    }\n  }\n}", "target": 0}
{"code": "is_fts_index(const std::string &tablespace)\n{\n\tconst char *pattern =\n\t\t\t\"^(FTS|fts)_[0-9a-fA-f]{16}_(([0-9a-fA-]{16}_(INDEX|index)_[1-6])|\"\n\t\t\t\"DELETED_CACHE|deleted_cache|DELETED|deleted|CONFIG|config|BEING_DELETED|\"\n\t\t\t\"being_deleted|BEING_DELETED_CACHE|beign_deleted_cache)$\";\n\tconst char *error_context = \"is_fts_index\";\n\treturn check_regexp_table_name(tablespace, error_context, pattern);\n}", "target": 0}
{"code": "void ChromotingInstance::SendClipboardItem(const std::string& mime_type,\n                                           const std::string& item) {\n  if (!IsConnected()) {\n    return;\n  }\n  protocol::ClipboardEvent event;\n  event.set_mime_type(mime_type);\n  event.set_data(item);\n  host_connection_->clipboard_stub()->InjectClipboardEvent(event);\n}", "target": 0}
{"code": "GF_Err av1c_box_size(GF_Box *s) {\n\tu32 i;\n\tGF_AV1ConfigurationBox *ptr = (GF_AV1ConfigurationBox *)s;\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_BAD_PARAM;\n\t}\n\tptr->size += 4;\n\tfor (i = 0; i < gf_list_count(ptr->config->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(ptr->config->obu_array, i);\n\t\tptr->size += a->obu_length;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    if( ssl == NULL || ssl->conf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    if( ssl->out_left != 0 )\n        return( mbedtls_ssl_flush_output( ssl ) );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> send alert message\" ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"send alert level=%u message=%u\", level, message ));\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;\n    ssl->out_msglen = 2;\n    ssl->out_msg[0] = level;\n    ssl->out_msg[1] = message;\n    if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= send alert message\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "decode_jd(VALUE jd, VALUE *nth, int *rjd)\n{\n    *nth = f_idiv(jd, INT2FIX(CM_PERIOD));\n    if (f_zero_p(*nth)) {\n\t*rjd = FIX2INT(jd);\n\treturn;\n    }\n    *rjd = FIX2INT(f_mod(jd, INT2FIX(CM_PERIOD)));\n}", "target": 0}
{"code": "    void Converter::cnvToXmp()\n    {\n        for (unsigned int i = 0; i < EXV_COUNTOF(conversion_); ++i) {\n            const Conversion& c = conversion_[i];\n            if (   (c.metadataId_ == mdExif && exifData_)\n                || (c.metadataId_ == mdIptc && iptcData_)) {\n                EXV_CALL_MEMBER_FN(*this, c.key1ToKey2_)(c.key1_, c.key2_);\n            }\n        }\n    }", "target": 0}
{"code": "void ahdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "\tSharedPtr(T *ptr) : m_ptr(ptr)\n\t{\n\t\tif (m_ptr) m_ptr->retain();\n\t}", "target": 0}
{"code": "XML_SetHashSalt(XML_Parser parser, unsigned long hash_salt) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_parentParser)\n    return XML_SetHashSalt(parser->m_parentParser, hash_salt);\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n  parser->m_hash_secret_salt = hash_salt;\n  return 1;\n}", "target": 0}
{"code": "static bool cma_protocol_roce(const struct rdma_cm_id *id)\n{\n\tstruct ib_device *device = id->device;\n\tconst u32 port_num = id->port_num ?: rdma_start_port(device);\n\treturn rdma_protocol_roce(device, port_num);\n}", "target": 0}
{"code": "void usbredirparser_send_set_alt_setting(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_set_alt_setting_header *set_alt_setting)\n{\n    usbredirparser_queue(parser, usb_redir_set_alt_setting, id,\n                         set_alt_setting, NULL, 0);\n}", "target": 0}
{"code": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tset_root_rcu(nd);\n\twhile (1) {\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (read_seqcount_retry(&old->d_seq, nd->seq))\n\t\t\t\tgoto failed;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up_rcu(&nd->path))\n\t\t\tbreak;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tfollow_mount_rcu(nd);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\nfailed:\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\tunlock_rcu_walk();\n\treturn -ECHILD;\n}", "target": 0}
{"code": "void PrepareFrameAndViewForPrint::didStopLoading() {\n  DCHECK(!on_ready_.is_null());\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::Bind(&PrepareFrameAndViewForPrint::CallOnReady,\n                            weak_ptr_factory_.GetWeakPtr()));\n}", "target": 0}
{"code": "unsigned LibRaw::ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}", "target": 0}
{"code": "static const char *req_content_encoding_field(request_rec *r)\n{\n    return r->content_encoding;\n}", "target": 0}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n {\n \tstruct cifsSesInfo *ses;\n \twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->linux_uid != ses->linux_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strncmp(ses->userName, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    strncmp(ses->password, vol->password,\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n \t\t++ses->ses_count;\n \t\twrite_unlock(&cifs_tcp_ses_lock);\n \t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 0}
{"code": "string_full_free (gpointer ptr)\n{\n  g_string_free (ptr, TRUE);\n}", "target": 0}
{"code": "unlink_log(int type)\n{\nif (type == lt_debug) unlink(CS debuglog_name);\n}", "target": 0}
{"code": "static void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}", "target": 0}
{"code": "static int ct_press_key(struct media_player *mp, uint8_t avc_key,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_press(player, avc_key);\n}", "target": 0}
{"code": "static void iommu_set_root_entry(struct intel_iommu *iommu)\n{\n\tu64 addr;\n\tu32 sts;\n\tunsigned long flag;\n\taddr = virt_to_phys(iommu->root_entry);\n\tif (sm_supported(iommu))\n\t\taddr |= DMA_RTADDR_SMT;\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tdmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);\n\twritel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_RTPS), sts);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n}", "target": 0}
{"code": "int zmq::stream_engine_t::pull_msg_from_session (msg_t *msg_)\n{\n    return session->pull_msg (msg_);\n}", "target": 0}
{"code": "read_data_into_pages(struct TCP_Server_Info *server, struct page **pages,\n\t\t     unsigned int npages, unsigned int len)\n{\n\tint i;\n\tint length;\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = pages[i];\n\t\tsize_t n;\n\t\tn = len;\n\t\tif (len >= PAGE_SIZE) {\n\t\t\tn = PAGE_SIZE;\n\t\t\tlen -= n;\n\t\t} else {\n\t\t\tzero_user(page, len, PAGE_SIZE - len);\n\t\t\tlen = 0;\n\t\t}\n\t\tlength = cifs_read_page_from_socket(server, page, 0, n);\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "DLLIMPORT cfg_errfunc_t cfg_set_error_function(cfg_t *cfg, cfg_errfunc_t errfunc)\n{\n\tcfg_errfunc_t old;\n\tif (!cfg) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\told = cfg->errfunc;\n\tcfg->errfunc = errfunc;\n\treturn old;\n}", "target": 0}
{"code": "MATCHER_P(DecodedResourcesEq, expected, \"\") {\n  const bool equal = std::equal(arg.begin(), arg.end(), expected.begin(), expected.end(),\n                                TestUtility::decodedResourceEq);\n  if (!equal) {\n    const auto format_resources =\n        [](const std::vector<Config::DecodedResourceRef>& resources) -> std::string {\n      std::vector<std::string> resource_strs;\n      std::transform(\n          resources.begin(), resources.end(), std::back_inserter(resource_strs),\n          [](const Config::DecodedResourceRef& resource) -> std::string {\n            return fmt::format(\n                \"<name: {}, aliases: {}, version: {}, resource: {}>\", resource.get().name(),\n                absl::StrJoin(resource.get().aliases(), \",\"), resource.get().version(),\n                resource.get().hasResource() ? resource.get().resource().DebugString() : \"(none)\");\n          });\n      return absl::StrJoin(resource_strs, \", \");\n    };\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected resources:\") << \"\\n\"\n                     << format_resources(expected) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"are not equal to actual resources:\")\n                     << \"\\n\"\n                     << format_resources(arg) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "    LangAltValue::LangAltValue()\n        : XmpValue(langAlt)\n    {\n    }", "target": 0}
{"code": "void GroupFromFirstDocumentTransformation::optimize() {\n    for (auto&& expr : _accumulatorExprs) {\n        expr.second = expr.second->optimize();\n    }\n}", "target": 0}
{"code": "bool WebGraphicsContext3DDefaultImpl::getActiveUniform(WebGLId program, unsigned long index, ActiveInfo& info)\n{\n    makeContextCurrent();\n    GLint maxNameLength = -1;\n    glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxNameLength);\n    if (maxNameLength < 0)\n        return false;\n    GLchar* name = 0;\n    if (!tryFastMalloc(maxNameLength * sizeof(GLchar)).getValue(name)) {\n        synthesizeGLError(GL_OUT_OF_MEMORY);\n        return false;\n    }\n    GLsizei length = 0;\n    GLint size = -1;\n    GLenum type = 0;\n    glGetActiveUniform(program, index, maxNameLength,\n                       &length, &size, &type, name);\n    if (size < 0) {\n        fastFree(name);\n        return false;\n    }\n    info.name = WebString::fromUTF8(name, length);\n    info.type = type;\n    info.size = size;\n    fastFree(name);\n    return true;\n}", "target": 0}
{"code": "static void si_dbus_match_rule_update(struct session_info *info)\n{\n    DBusError error;\n    if (info->connection == NULL)\n        return;\n    si_dbus_match_remove(info);\n    if (info->seat != NULL) {\n        info->match_seat_signals =\n            g_strdup_printf (\"type='signal',interface='%s',path='%s',\"\n                             \"member='ActiveSessionChanged'\",\n                             INTERFACE_CONSOLE_KIT_SEAT,\n                             info->seat);\n        if (info->verbose)\n            syslog(LOG_DEBUG, \"(console-kit) seat match: %s\",\n                   info->match_seat_signals);\n        dbus_error_init(&error);\n        dbus_bus_add_match(info->connection,\n                           info->match_seat_signals,\n                           &error);\n        if (dbus_error_is_set(&error)) {\n            syslog(LOG_WARNING, \"Unable to add dbus rule match: %s\",\n                   error.message);\n            dbus_error_free(&error);\n            g_clear_pointer(&info->match_seat_signals, g_free);\n        }\n    }\n    if (info->active_session != NULL) {\n        info->match_session_signals =\n            g_strdup_printf (\"type='signal',interface='%s',path='%s'\",\n                             INTERFACE_CONSOLE_KIT_SESSION,\n                             info->active_session);\n        if (info->verbose)\n            syslog(LOG_DEBUG, \"(console-kit) session match: %s\",\n                   info->match_session_signals);\n        dbus_error_init(&error);\n        dbus_bus_add_match(info->connection,\n                           info->match_session_signals,\n                           &error);\n        if (dbus_error_is_set(&error)) {\n            syslog(LOG_WARNING, \"Unable to add dbus rule match: %s\",\n                   error.message);\n            dbus_error_free(&error);\n            g_clear_pointer(&info->match_session_signals, g_free);\n        }\n    }\n}", "target": 0}
{"code": "set_optimize_map_info(regex_t* reg, OptMapInfo* m)\n{\n  int i;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    reg->map[i] = m->map[i];\n  reg->optimize   = ONIG_OPTIMIZE_MAP;\n  reg->dmin       = m->mmd.min;\n  reg->dmax       = m->mmd.max;\n  if (reg->dmin != ONIG_INFINITE_DISTANCE) {\n    reg->threshold_len = (int )(reg->dmin + 1);\n  }\n}", "target": 0}
{"code": "static __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}", "target": 0}
{"code": "inline static void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t)\n{\n\tint dr,dg,db,p,r,g,b;\n\tdr = gdTrueColorGetRed(color);\n\tdg = gdTrueColorGetGreen(color);\n\tdb = gdTrueColorGetBlue(color);\n\tp = gdImageGetPixel(im,x,y);\n\tr = gdTrueColorGetRed(p);\n\tg = gdTrueColorGetGreen(p);\n\tb = gdTrueColorGetBlue(p);\n\tBLEND_COLOR(t, dr, r, dr);\n\tBLEND_COLOR(t, dg, g, dg);\n\tBLEND_COLOR(t, db, b, db);\n\tim->tpixels[y][x]=gdTrueColorAlpha(dr, dg, db,  gdAlphaOpaque);\n}", "target": 0}
{"code": "__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}", "target": 0}
{"code": "    bool TiffEncoder::dirty() const\n    {\n        if (dirty_ || exifData_.count() > 0) return true;\n        return false;\n    }", "target": 0}
{"code": "bool table_already_fk_prelocked(TABLE_LIST *tl, LEX_STRING *db,\n                                LEX_STRING *table, thr_lock_type lock_type)\n{\n  for (; tl; tl= tl->next_global )\n  {\n    if (tl->lock_type >= lock_type &&\n        tl->prelocking_placeholder == TABLE_LIST::FK &&\n        strcmp(tl->db, db->str) == 0 &&\n        strcmp(tl->table_name, table->str) == 0)\n      return true;\n  }\n  return false;\n}", "target": 0}
{"code": "void PPB_URLLoader_Impl::SaveResponse(const WebURLResponse& response) {\n  scoped_refptr<PPB_URLResponseInfo_Impl> response_info(\n      new PPB_URLResponseInfo_Impl(pp_instance()));\n  if (response_info->Initialize(response))\n    response_info_ = response_info;\n}", "target": 0}
{"code": "static inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n  ssize_t\n    count;\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}", "target": 0}
{"code": "static int lua_ap_exists_config_define(lua_State *L)\n{\n    int returnValue;\n    const char     *name;\n    luaL_checktype(L, 1, LUA_TSTRING);\n    name = lua_tostring(L, 1);\n    returnValue = ap_exists_config_define(name);\n    lua_pushboolean(L, returnValue);\n    return 1;\n}", "target": 0}
{"code": "static void php_disable_classes(void)\n{\n\tchar *s = NULL, *e;\n\tif (!*(INI_STR(\"disable_classes\"))) {\n\t\treturn;\n\t}\n\te = PG(disable_classes) = strdup(INI_STR(\"disable_classes\"));\n\twhile (*e) {\n\t\tswitch (*e) {\n\t\t\tcase ' ':\n\t\t\tcase ',':\n\t\t\t\tif (s) {\n\t\t\t\t\t*e = '\\0';\n\t\t\t\t\tzend_disable_class(s, e-s);\n\t\t\t\t\ts = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!s) {\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\te++;\n\t}\n\tif (s) {\n\t\tzend_disable_class(s, e-s);\n\t}\n}", "target": 0}
{"code": "  void FixResourceIdInChangeList(ChangeList* change_list) {\n    std::vector<ResourceEntry>* entries = change_list->mutable_entries();\n    std::vector<std::string>* parent_resource_ids =\n        change_list->mutable_parent_resource_ids();\n    for (size_t i = 0; i < entries->size(); ++i) {\n      ResourceEntry* entry = &(*entries)[i];\n      if (entry->has_resource_id())\n        entry->set_resource_id(FixResourceId(entry->resource_id()));\n      (*parent_resource_ids)[i] = FixResourceId((*parent_resource_ids)[i]);\n    }\n  }", "target": 0}
{"code": "static bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}", "target": 0}
{"code": "int EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)\n{\n    if (group == NULL)\n        return 0;\n    if (EC_GROUP_method_of(group)->group_set_curve !=\n        ec_GF2m_simple_group_set_curve || !((group->poly[0] != 0)\n                                            && (group->poly[1] != 0)\n                                            && (group->poly[2] == 0))) {\n        ECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (k)\n        *k = group->poly[1];\n    return 1;\n}", "target": 0}
{"code": "static void vhost_vdpa_iotlb_unmap(struct vhost_vdpa *v, u64 start, u64 last)\n{\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tif (vdpa->use_va)\n\t\treturn vhost_vdpa_va_unmap(v, start, last);\n\treturn vhost_vdpa_pa_unmap(v, start, last);\n}", "target": 0}
{"code": "find_abbrev_map_by_offset (dwarf_vma offset)\n{\n  unsigned long i;\n  for (i = 0; i < next_free_abbrev_map_entry; i++)\n    if (cu_abbrev_map[i].start <= offset\n\t&& cu_abbrev_map[i].end > offset)\n      return cu_abbrev_map + i;\n  return NULL;\t\n}", "target": 0}
{"code": "m_df(union DateData *x)\n{\n    if (simple_dat_p(x))\n\treturn 0;\n    else {\n\tget_c_df(x);\n\treturn x->c.df;\n    }\n}", "target": 0}
{"code": "    void MrwImage::setIptcData(const IptcData& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"MRW\"));\n    }", "target": 0}
{"code": "reg_named_captures_iter(const OnigUChar *name, const OnigUChar *name_end,\n          int back_num, int *back_refs, OnigRegex regex, void *arg)\n{\n    VALUE hash = (VALUE)arg;\n    VALUE ary = rb_ary_new2(back_num);\n    int i;\n    for (i = 0; i < back_num; i++)\n        rb_ary_store(ary, i, INT2NUM(back_refs[i]));\n    rb_hash_aset(hash, rb_str_new((const char*)name, name_end-name),ary);\n    return 0;\n}", "target": 0}
{"code": "static int process_command(MYSQL_THD thd, LEX_CSTRING event_command,\n                           my_bool consume_event)\n{\n  LEX_CSTRING abort_ret_command= { C_STRING_WITH_LEN(\"ABORT_RET\") };\n  if (!my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                         (const uchar *)event_command.str,\n                                         event_command.length,\n                                         (const uchar *)abort_ret_command.str,\n                                         abort_ret_command.length, 0))\n  {\n    int ret_code = (int)THDVAR(thd, abort_value);\n    const char *err_message = (const char *)THDVAR(thd, abort_message);\n    LEX_CSTRING status = { C_STRING_WITH_LEN(\"EVENT-ORDER-ABORT\") };\n    LEX_CSTRING order_cstr;\n    lex_cstring_set(&order_cstr, \n                    (const char *)THDVAR(thd, event_order_check));\n    if (consume_event)\n    {\n      memmove((char *) order_cstr.str,\n              (void *) status.str, status.length + 1);\n      THDVAR(thd, abort_value)= 1;\n      THDVAR(thd, abort_message)= 0;\n    }\n    if (err_message)\n    {\n      my_message(ER_AUDIT_API_ABORT, err_message, MYF(0));\n      THDVAR(thd, event_order_check)= (char *)order_cstr.str;\n    }\n    return ret_code;\n  }\n  return 0;\n}", "target": 0}
{"code": "  Media_Query_Obj Parser::parse_media_query()\n  {\n    advanceToNextToken();\n    Media_Query_Obj media_query = SASS_MEMORY_NEW(Media_Query, pstate);\n    if (lex < kwd_not >()) { media_query->is_negated(true); lex < css_comments >(false); }\n    else if (lex < kwd_only >()) { media_query->is_restricted(true); lex < css_comments >(false); }\n    if (lex < identifier_schema >())  media_query->media_type(parse_identifier_schema());\n    else if (lex < identifier >())    media_query->media_type(parse_interpolated_chunk(lexed));\n    else                             media_query->append(parse_media_expression());\n    while (lex_css < kwd_and >()) media_query->append(parse_media_expression());\n    if (lex < identifier_schema >()) {\n      String_Schema_Ptr schema = SASS_MEMORY_NEW(String_Schema, pstate);\n      schema->append(media_query->media_type());\n      schema->append(SASS_MEMORY_NEW(String_Constant, pstate, \" \"));\n      schema->append(parse_identifier_schema());\n      media_query->media_type(schema);\n    }\n    while (lex_css < kwd_and >()) media_query->append(parse_media_expression());\n    media_query->update_pstate(pstate);\n    return media_query;\n  }", "target": 0}
{"code": "static inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}", "target": 0}
{"code": "static int cred_has_capability(const struct cred *cred,\n\t\t\t       int cap, unsigned int opts, bool initns)\n{\n\tstruct common_audit_data ad;\n\tstruct av_decision avd;\n\tu16 sclass;\n\tu32 sid = cred_sid(cred);\n\tu32 av = CAP_TO_MASK(cap);\n\tint rc;\n\tad.type = LSM_AUDIT_DATA_CAP;\n\tad.u.cap = cap;\n\tswitch (CAP_TO_INDEX(cap)) {\n\tcase 0:\n\t\tsclass = initns ? SECCLASS_CAPABILITY : SECCLASS_CAP_USERNS;\n\t\tbreak;\n\tcase 1:\n\t\tsclass = initns ? SECCLASS_CAPABILITY2 : SECCLASS_CAP2_USERNS;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"SELinux:  out of range capability %d\\n\", cap);\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\trc = avc_has_perm_noaudit(&selinux_state,\n\t\t\t\t  sid, sid, sclass, av, 0, &avd);\n\tif (!(opts & CAP_OPT_NOAUDIT)) {\n\t\tint rc2 = avc_audit(&selinux_state,\n\t\t\t\t    sid, sid, sclass, av, &avd, rc, &ad, 0);\n\t\tif (rc2)\n\t\t\treturn rc2;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static WERROR dcesrv_DnssrvEnumRecords(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct DnssrvEnumRecords *r)\n{\n\tstruct dnsserver_state *dsstate;\n\tstruct dnsserver_zone *z;\n\tWERROR ret;\n\tZERO_STRUCTP(r->out.pdwBufferLength);\n\tZERO_STRUCTP(r->out.pBuffer);\n\tif ((dsstate = dnsserver_connect(dce_call)) == NULL) {\n\t\treturn WERR_DNS_ERROR_DS_UNAVAILABLE;\n\t}\n\tif (r->in.pszZone == NULL) {\n\t\treturn WERR_DNS_ERROR_NAME_DOES_NOT_EXIST;\n\t}\n\tif (strcasecmp(r->in.pszZone, \"..RootHints\") == 0) {\n\t\tret = dnsserver_enumerate_root_records(dsstate, mem_ctx,\n\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\tr->in.pszNodeName,\n\t\t\t\t\tr->in.wRecordType,\n\t\t\t\t\tr->in.fSelectFlag,\n\t\t\t\t\tr->out.pdwBufferLength,\n\t\t\t\t\tr->out.pBuffer);\n\t} else {\n\t\tz = dnsserver_find_zone(dsstate->zones, r->in.pszZone);\n\t\tif (z == NULL) {\n\t\t\treturn WERR_DNS_ERROR_NAME_DOES_NOT_EXIST;\n\t\t}\n\t\tret = dnsserver_enumerate_records(dsstate, mem_ctx, z,\n\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\tr->in.pszNodeName,\n\t\t\t\t\tr->in.pszStartChild,\n\t\t\t\t\tr->in.wRecordType,\n\t\t\t\t\tr->in.fSelectFlag,\n\t\t\t\t\tr->in.pszFilterStart,\n\t\t\t\t\tr->in.pszFilterStop,\n\t\t\t\t\tr->out.pdwBufferLength,\n\t\t\t\t\tr->out.pBuffer);\n\t}\n\tif (W_ERROR_EQUAL(ret, WERR_CALL_NOT_IMPLEMENTED)) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(DnssrvEnumRecords, NDR_IN, r);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void do_release_file_info(struct file_info *f)\n{\n\tif (!f)\n\t\treturn;\n\tfree(f->controller);\n\tfree(f->cgroup);\n\tfree(f->file);\n\tfree(f->buf);\n\tfree(f);\n}", "target": 0}
{"code": "static ssize_t disk_events_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\treturn __disk_events_show(disk->events, buf);\n}", "target": 0}
{"code": "void LibRaw::parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &LibRaw::eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &LibRaw::unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}", "target": 0}
{"code": "void LibRaw::Nikon_NRW_WBtag(int wb, int skip)\n{\n#define icWB imgdata.color.WB_Coeffs\n  int r, g0, g1, b;\n  if (skip)\n    get4(); \n  r = get4();\n  g0 = get4();\n  g1 = get4();\n  b = get4();\n  if (r && g0 && g1 && b)\n  {\n    icWB[wb][0] = r << 1;\n    icWB[wb][1] = g0;\n    icWB[wb][2] = b << 1;\n    icWB[wb][3] = g1;\n  }\n  return;\n#undef icWB\n}", "target": 0}
{"code": "static void parse_output_words(struct output_struct *words, short *levels,\n\t\t\t       const char *str, uchar priority)\n{\n\tconst char *s;\n\tint j, len, lev;\n\tfor ( ; str; str = s) {\n\t\tif ((s = strchr(str, ',')) != NULL)\n\t\t\tlen = s++ - str;\n\t\telse\n\t\t\tlen = strlen(str);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (!isDigit(str)) {\n\t\t\twhile (len && isDigit(str+len-1))\n\t\t\t\tlen--;\n\t\t}\n\t\tlev = isDigit(str+len) ? atoi(str+len) : 1;\n\t\tif (lev > MAX_OUT_LEVEL)\n\t\t\tlev = MAX_OUT_LEVEL;\n\t\tif (len == 4 && strncasecmp(str, \"help\", 4) == 0) {\n\t\t\toutput_item_help(words);\n\t\t\texit_cleanup(0);\n\t\t}\n\t\tif (len == 4 && strncasecmp(str, \"none\", 4) == 0)\n\t\t\tlen = lev = 0;\n\t\telse if (len == 3 && strncasecmp(str, \"all\", 3) == 0)\n\t\t\tlen = 0;\n\t\tfor (j = 0; words[j].name; j++) {\n\t\t\tif (!len\n\t\t\t || (len == words[j].namelen && strncasecmp(str, words[j].name, len) == 0)) {\n\t\t\t\tif (priority >= words[j].priority) {\n\t\t\t\t\twords[j].priority = priority;\n\t\t\t\t\tlevels[j] = lev;\n\t\t\t\t}\n\t\t\t\tif (len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (len && !words[j].name) {\n\t\t\trprintf(FERROR, \"Unknown %s item: \\\"%.*s\\\"\\n\",\n\t\t\t\twords[j].help, len, str);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t}\n}", "target": 0}
{"code": "char *LibRaw::strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}", "target": 0}
{"code": "static void player_destroy(gpointer data)\n{\n\tstruct avrcp_player *player = data;\n\tif (player->destroy)\n\t\tplayer->destroy(player->user_data);\n\tif (player->changed_id > 0)\n\t\tg_source_remove(player->changed_id);\n\tg_slist_free(player->sessions);\n\tg_free(player->path);\n\tg_free(player->change_path);\n\tg_free(player->features);\n\tg_free(player);\n}", "target": 0}
{"code": "DevToolsDownloadManagerDelegate::GetInstance() {\n  if (!g_devtools_manager_delegate)\n    new DevToolsDownloadManagerDelegate();\n  return g_devtools_manager_delegate;\n}", "target": 0}
{"code": "p_rel_addr(FILE* f, RelAddrType rel_addr, Operation* p, Operation* start)\n{\n  RelAddrType curr = (RelAddrType )(p - start);\n  fprintf(f, \"{%d/%d}\", rel_addr, curr + rel_addr);\n}", "target": 0}
{"code": "static void AddNodePixelList(PixelList *pixel_list,const size_t color)\n{\n  SkipList\n    *p;\n  ssize_t\n    level;\n  size_t\n    search,\n    update[9];\n  p=(&pixel_list->skip_list);\n  p->nodes[color].signature=pixel_list->signature;\n  p->nodes[color].count=1;\n  search=65536UL;\n  for (level=p->level; level >= 0; level--)\n  {\n    while (p->nodes[search].next[level] < color)\n      search=p->nodes[search].next[level];\n    update[level]=search;\n  }\n  for (level=0; ; level++)\n  {\n    pixel_list->seed=(pixel_list->seed*42893621L)+1L;\n    if ((pixel_list->seed & 0x300) != 0x300)\n      break;\n  }\n  if (level > 8)\n    level=8;\n  if (level > (p->level+2))\n    level=p->level+2;\n  while (level > p->level)\n  {\n    p->level++;\n    update[p->level]=65536UL;\n  }\n  do\n  {\n    p->nodes[color].next[level]=p->nodes[update[level]].next[level];\n    p->nodes[update[level]].next[level]=color;\n  } while (level-- > 0);\n}", "target": 0}
{"code": "static inline ssize_t DitherX(const ssize_t x,const size_t columns)\n{\n  ssize_t\n    index;\n  index=x+DitherMatrix[x & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) columns)\n    return((ssize_t) columns-1L);\n  return(index);\n}", "target": 0}
{"code": "static ssize_t aliases_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", s->refcount - 1);\n}", "target": 0}
{"code": "gx_dc_pattern2_get_bbox(const gx_device_color * pdevc, gs_fixed_rect *bbox)\n{\n    gs_pattern2_instance_t *pinst =\n        (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n    int code;\n    if (!pinst->templat.Shading->params.have_BBox)\n        return 0;\n    code = gx_dc_pattern2_shade_bbox_transform2fixed(\n                &pinst->templat.Shading->params.BBox, (gs_gstate *)pinst->saved, bbox);\n    if (code < 0)\n        return code;\n    return 1;\n}", "target": 0}
{"code": "void HTMLMediaElement::RequireOfficialPlaybackPositionUpdate() const {\n  official_playback_position_needs_update_ = true;\n}", "target": 0}
{"code": "vte_sequence_handler_ta (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tlong old_len, newcol, col;\n\tscreen = terminal->pvt->screen;\n\tnewcol = col = screen->cursor_current.col;\n\tg_assert (col >= 0);\n\tif (terminal->pvt->tabstops != NULL) {\n\t\tfor (newcol++; newcol < VTE_TAB_MAX; newcol++) {\n\t\t\tif (_vte_terminal_get_tabstop(terminal, newcol)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (newcol >= terminal->column_count) {\n\t\tnewcol = terminal->column_count - 1;\n\t}\n\tif (col < newcol) {\n\t\tVteRowData *rowdata = _vte_terminal_ensure_row (terminal);\n\t\told_len = _vte_row_data_length (rowdata);\n\t\t_vte_row_data_fill (rowdata, &screen->fill_defaults, newcol);\n\t\t{\n\t\t\tglong i;\n\t\t\tgboolean found = FALSE;\n\t\t\tfor (i = old_len; i > col; i--) {\n\t\t\t\tconst VteCell *cell = _vte_row_data_get (rowdata, i - 1);\n\t\t\t\tif (cell->attr.fragment || cell->c != 0) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tVteCell *cell = _vte_row_data_get_writable (rowdata, col);\n\t\t\t\tVteCell tab = *cell;\n\t\t\t\ttab.attr.columns = newcol - col;\n\t\t\t\ttab.c = '\\t';\n\t\t\t\tif (tab.attr.columns == newcol - col) {\n\t\t\t\t\t*cell = tab;\n\t\t\t\t\tfor (i = col + 1; i < newcol; i++) {\n\t\t\t\t\t\tcell = _vte_row_data_get_writable (rowdata, i);\n\t\t\t\t\t\tcell->c = '\\t';\n\t\t\t\t\t\tcell->attr.columns = 1;\n\t\t\t\t\t\tcell->attr.fragment = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_vte_invalidate_cells (terminal,\n\t\t\t\tscreen->cursor_current.col,\n\t\t\t\tnewcol - screen->cursor_current.col,\n\t\t\t\tscreen->cursor_current.row, 1);\n\t\tscreen->cursor_current.col = newcol;\n\t}\n}", "target": 0}
{"code": "void OmniboxViewWin::OnLButtonDblClk(UINT keys, const CPoint& point) {\n  tracking_double_click_ = true;\n  double_click_point_ = point;\n  double_click_time_ = GetCurrentMessage()->time;\n  possible_drag_ = false;\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  OnBeforePossibleChange();\n  DefWindowProc(WM_LBUTTONDBLCLK, keys,\n                MAKELPARAM(ClipXCoordToVisibleText(point.x, false), point.y));\n  OnAfterPossibleChange();\n  gaining_focus_.reset();  \n}", "target": 0}
{"code": "void ring_buffer_reset(struct ring_buffer *buffer)\n{\n\tint cpu;\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n}", "target": 0}
{"code": "RtmpProtocol::RtmpProtocol() {\n    _packet_pool.setSize(64);\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C0C1(data, len);\n    };\n}", "target": 0}
{"code": "static zend_never_inline int ZEND_FASTCALL add_function_slow(zval *result, zval *op1, zval *op2) \n{\n\tzval op1_copy, op2_copy;\n\tint converted = 0;\n\twhile (1) {\n\t\tif (Z_ISREF_P(op1)) {\n\t\t\top1 = Z_REFVAL_P(op1);\n\t\t} else if (Z_ISREF_P(op2)) {\n\t\t\top2 = Z_REFVAL_P(op2);\n\t\t} else if (!converted) {\n\t\t\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_ADD, add_function);\n\t\t\tif (EXPECTED(op1 != op2)) {\n\t\t\t\top1 = zendi_convert_scalar_to_number(op1, &op1_copy, result, 0);\n\t\t\t\top2 = zendi_convert_scalar_to_number(op2, &op2_copy, result, 0);\n\t\t\t} else {\n\t\t\t\top1 = zendi_convert_scalar_to_number(op1, &op1_copy, result, 0);\n\t\t\t\top2 = op1;\n\t\t\t}\n\t\t\tif (EG(exception)) {\n\t\t\t\tif (result != op1) {\n\t\t\t\t\tZVAL_UNDEF(result);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tconverted = 1;\n\t\t} else {\n\t\t\tif (result != op1) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\tzend_throw_error(NULL, \"Unsupported operand types\");\n\t\t\treturn FAILURE; \n\t\t}\n\t\tif (add_function_fast(result, op1, op2) == SUCCESS) {\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n} ", "target": 0}
{"code": "TIFFjpeg_finish_decompress(JPEGState* sp)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_finish_decompress(&sp->cinfo.d));\n}", "target": 0}
{"code": "static inline void skb_reset_inner_network_header(struct sk_buff *skb)\n{\n\tskb->inner_network_header = skb->data;\n}", "target": 0}
{"code": "static inline unsigned char *PopHexPixel(const char hex_digits[][3],\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++ & 0xff);\n  *pixels++=(unsigned char) (*hex & 0xff);\n  return(pixels);\n}", "target": 0}
{"code": "static int irda_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_irda *addr = (struct sockaddr_irda *) uaddr;\n\tstruct irda_sock *self = irda_sk(sk);\n\tint err;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tif (addr_len != sizeof(struct sockaddr_irda))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n#ifdef CONFIG_IRDA_ULTRA\n\tif ((sk->sk_type == SOCK_DGRAM) &&\n\t    (sk->sk_protocol == IRDAPROTO_ULTRA)) {\n\t\tself->pid = addr->sir_lsap_sel;\n\t\terr = -EOPNOTSUPP;\n\t\tif (self->pid & 0x80) {\n\t\t\tIRDA_DEBUG(0, \"%s(), extension in PID not supp!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\terr = irda_open_lsap(self, self->pid);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tsock->state = SS_CONNECTED;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\terr = 0;\n\t\tgoto out;\n\t}\n#endif \n\tself->ias_obj = irias_new_object(addr->sir_name, jiffies);\n\terr = -ENOMEM;\n\tif (self->ias_obj == NULL)\n\t\tgoto out;\n\terr = irda_open_tsap(self, addr->sir_lsap_sel, addr->sir_name);\n\tif (err < 0) {\n\t\tirias_delete_object(self->ias_obj);\n\t\tself->ias_obj = NULL;\n\t\tgoto out;\n\t}\n\tirias_add_integer_attrib(self->ias_obj, \"IrDA:TinyTP:LsapSel\",\n\t\t\t\t self->stsap_sel, IAS_KERNEL_ATTR);\n\tirias_insert_object(self->ias_obj);\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "OmniboxViewWin::ScopedSuspendUndo::~ScopedSuspendUndo() {\n  if (text_object_model_)\n    text_object_model_->Undo(tomResume, NULL);\n}", "target": 0}
{"code": "__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}", "target": 0}
{"code": "void show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n#if BITS_PER_LONG == 32\n\tprintk(KERN_INFO\n\t\t\"  task                PC stack   pid father\\n\");\n#else\n\tprintk(KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\");\n#endif\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\ttouch_nmi_watchdog();\n\t\tif (!state_filter || (p->state & state_filter))\n\t\t\tsched_show_task(p);\n\t}\n\ttouch_all_softlockup_watchdogs();\n#ifdef CONFIG_SCHED_DEBUG\n\tsysrq_sched_debug_show();\n#endif\n\trcu_read_unlock();\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}", "target": 0}
{"code": "void rfc_send_credit(tRFC_MCB* p_mcb, uint8_t dlci, uint8_t credit) {\n uint8_t* p_data;\n uint8_t cr = RFCOMM_CR(p_mcb->is_initiator, true);\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | cr | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_UIH | RFCOMM_PF;\n *p_data++ = RFCOMM_EA | 0;\n *p_data++ = credit;\n *p_data = RFCOMM_UIH_FCS((uint8_t*)(p_buf + 1) + p_buf->offset, dlci);\n  p_buf->len = 5;\n  rfc_check_send_cmd(p_mcb, p_buf);\n}", "target": 0}
{"code": "methodHandle LinkResolver::linktime_resolve_interface_method(const LinkInfo& link_info,\n                                                             TRAPS) {\n  methodHandle resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);\n  assert(resolved_method->name() != vmSymbols::object_initializer_name(), \"should have been checked in verifier\");\n  assert(resolved_method->name() != vmSymbols::class_initializer_name (), \"should have been checked in verifier\");\n  return resolved_method;\n}", "target": 0}
{"code": "static ssize_t read_iter_zero(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tsize_t written = 0;\n\twhile (iov_iter_count(iter)) {\n\t\tsize_t chunk = iov_iter_count(iter), n;\n\t\tif (chunk > PAGE_SIZE)\n\t\t\tchunk = PAGE_SIZE;\t\n\t\tn = iov_iter_zero(chunk, iter);\n\t\tif (!n && iov_iter_count(iter))\n\t\t\treturn written ? written : -EFAULT;\n\t\twritten += n;\n\t\tif (signal_pending(current))\n\t\t\treturn written ? written : -ERESTARTSYS;\n\t\tcond_resched();\n\t}\n\treturn written;\n}", "target": 0}
{"code": "static void mpeg4_encode_visual_object_header(MpegEncContext *s)\n{\n    int profile_and_level_indication;\n    int vo_ver_id;\n    if (s->avctx->profile != FF_PROFILE_UNKNOWN) {\n        profile_and_level_indication = s->avctx->profile << 4;\n    } else if (s->max_b_frames || s->quarter_sample) {\n        profile_and_level_indication = 0xF0;  \n    } else {\n        profile_and_level_indication = 0x00;  \n    }\n    if (s->avctx->level != FF_LEVEL_UNKNOWN)\n        profile_and_level_indication |= s->avctx->level;\n    else\n        profile_and_level_indication |= 1;   \n    if (profile_and_level_indication >> 4 == 0xF)\n        vo_ver_id = 5;\n    else\n        vo_ver_id = 1;\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VOS_STARTCODE);\n    put_bits(&s->pb, 8, profile_and_level_indication);\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VISUAL_OBJ_STARTCODE);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 4, vo_ver_id);\n    put_bits(&s->pb, 3, 1);     \n    put_bits(&s->pb, 4, 1);     \n    put_bits(&s->pb, 1, 0);     \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 0}
{"code": "void WebContentsImpl::UpdateTitle(RenderViewHost* rvh,\n                                  int32 page_id,\n                                  const string16& title,\n                                  base::i18n::TextDirection title_direction) {\n  SetNotWaitingForResponse();\n  NavigationEntryImpl* entry = controller_.GetEntryWithPageID(\n      rvh->GetSiteInstance(), page_id);\n  if (!entry && rvh != GetRenderViewHost())\n    return;\n  if (!UpdateTitleForEntry(entry, title))\n    return;\n  if (entry == controller_.GetEntryAtOffset(0))\n    NotifyNavigationStateChanged(INVALIDATE_TYPE_TITLE);\n}", "target": 0}
{"code": "void get_command_type(struct st_command* command)\n{\n  char save;\n  uint type;\n  DBUG_ENTER(\"get_command_type\");\n  if (*command->query == '}')\n  {\n    command->type = Q_END_BLOCK;\n    DBUG_VOID_RETURN;\n  }\n  save= command->query[command->first_word_len];\n  command->query[command->first_word_len]= 0;\n  type= find_type(command->query, &command_typelib, FIND_TYPE_NO_PREFIX);\n  command->query[command->first_word_len]= save;\n  if (type > 0)\n  {\n    command->type=(enum enum_commands) type;\t\t\n    if (type == Q_QUERY)\n    {\n      command->query= command->first_argument;\n    }\n  }\n  else\n  {\n    if (command->type != Q_COMMENT_WITH_COMMAND)\n    {\n      command->type= Q_QUERY;\n    }\n    else\n    {\n      report_or_die(\"Found line beginning with --  that didn't contain \" \\\n          \"a valid mysqltest command, check your syntax or \"            \\\n          \"use # if you intended to write a comment\");\n      command->type= Q_COMMENT;\n    }\n  }\n  memcpy(&command->expected_errors, &saved_expected_errors,\n         sizeof(saved_expected_errors));\n  DBUG_PRINT(\"info\", (\"There are %d expected errors\",\n                      command->expected_errors.count));\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "smtp_user_msg(uschar *code, uschar *user_msg)\n{\nint len = 3;\nsmtp_message_code(&code, &len, &user_msg, NULL, TRUE);\nsmtp_respond(code, len, TRUE, user_msg);\n}", "target": 0}
{"code": "static void dbus_name_lost(GDBusConnection *connection,\n\t\t\t   const gchar *name,\n\t\t\t   gpointer user_data)\n{\n\ttcmu_dbg(\"name lost\\n\");\n}", "target": 0}
{"code": "join_read_first(JOIN_TAB *tab)\n{\n  int error= 0;\n  TABLE *table=tab->table;\n  DBUG_ENTER(\"join_read_first\");\n  DBUG_ASSERT(table->no_keyread ||\n              !table->covering_keys.is_set(tab->index) ||\n              table->file->keyread == tab->index);\n  tab->table->status=0;\n  tab->read_record.read_record_func= join_read_next;\n  tab->read_record.table=table;\n  if (!table->file->inited)\n    error= table->file->ha_index_init(tab->index, tab->sorted);\n  if (likely(!error))\n    error= table->file->prepare_index_scan();\n  if (unlikely(error) ||\n      unlikely(error= tab->table->file->ha_index_first(tab->table->record[0])))\n  {\n    if (error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE)\n      report_error(table, error);\n    DBUG_RETURN(-1);\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "GF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tptr->size+= 4;\n\treturn GF_OK;\n}", "target": 0}
{"code": "ZEND_API int zend_update_static_property_string(zend_class_entry *scope, const char *name, int name_length, const char *value TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_STRING(tmp, value, 1);\n\treturn zend_update_static_property(scope, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "RecordAClientStateChange(CallbackListPtr *pcbl, void *nulldata,\n                         void *calldata)\n{\n    NewClientInfoRec *pci = (NewClientInfoRec *) calldata;\n    int i;\n    ClientPtr pClient = pci->client;\n    RecordContextPtr *ppAllContextsCopy = NULL;\n    int numContextsCopy = 0;\n    switch (pClient->clientState) {\n    case ClientStateRunning:   \n        for (i = 0; i < numContexts; i++) {\n            RecordClientsAndProtocolPtr pRCAP;\n            RecordContextPtr pContext = ppAllContexts[i];\n            if ((pRCAP = RecordFindClientOnContext(pContext,\n                                                   XRecordFutureClients, NULL)))\n            {\n                RecordAddClientToRCAP(pRCAP, pClient->clientAsMask);\n                if (pContext->pRecordingClient && pRCAP->clientStarted)\n                    RecordConnectionSetupInfo(pContext, pci);\n            }\n        }\n        break;\n    case ClientStateGone:\n    case ClientStateRetained:  \n        if (!(numContextsCopy = numContexts))\n            break;\n        ppAllContextsCopy = xallocarray(numContextsCopy,\n                                        sizeof(RecordContextPtr));\n        assert(ppAllContextsCopy);\n        memcpy(ppAllContextsCopy, ppAllContexts,\n               numContextsCopy * sizeof(RecordContextPtr));\n        for (i = 0; i < numContextsCopy; i++) {\n            RecordClientsAndProtocolPtr pRCAP;\n            RecordContextPtr pContext = ppAllContextsCopy[i];\n            int pos;\n            if (pContext->pRecordingClient == pClient)\n                RecordDisableContext(pContext);\n            if ((pRCAP = RecordFindClientOnContext(pContext,\n                                                   pClient->clientAsMask,\n                                                   &pos))) {\n                if (pContext->pRecordingClient && pRCAP->clientDied)\n                    RecordAProtocolElement(pContext, pClient,\n                                           XRecordClientDied, NULL, 0, 0, 0);\n                RecordDeleteClientFromRCAP(pRCAP, pos);\n            }\n        }\n        free(ppAllContextsCopy);\n        break;\n    default:\n        break;\n    }                           \n}                               ", "target": 0}
{"code": "void RegexMatchExpression::_init() {\n    uassert(\n        ErrorCodes::BadValue, \"Regular expression is too long\", _regex.size() <= kMaxPatternSize);\n    uassert(ErrorCodes::BadValue,\n            \"Regular expression cannot contain an embedded null byte\",\n            _regex.find('\\0') == std::string::npos);\n    uassert(ErrorCodes::BadValue,\n            \"Regular expression options string cannot contain an embedded null byte\",\n            _flags.find('\\0') == std::string::npos);\n    uassert(\n        5108300, \"Regular expression is invalid UTF-8\", isValidUTF8(_regex) && isValidUTF8(_flags));\n}", "target": 0}
{"code": "DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)\n{\n\tint ph, nc, retval=0;\n\tif(height<1 || subsamp<0 || subsamp>=TJ_NUMSAMP)\n\t\t_throw(\"tjPlaneHeight(): Invalid argument\");\n\tnc=(subsamp==TJSAMP_GRAY? 1:3);\n\tif(componentID<0 || componentID>=nc)\n\t\t_throw(\"tjPlaneHeight(): Invalid argument\");\n\tph=PAD(height, tjMCUHeight[subsamp]/8);\n\tif(componentID==0)\n\t\tretval=ph;\n\telse\n\t\tretval=ph*8/tjMCUHeight[subsamp];\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "static void get_block_sizes(ALSDecContext *ctx, unsigned int *div_blocks,\n                            uint32_t *bs_info)\n{\n    ALSSpecificConfig *sconf     = &ctx->sconf;\n    GetBitContext *gb            = &ctx->gb;\n    unsigned int *ptr_div_blocks = div_blocks;\n    unsigned int b;\n    if (sconf->block_switching) {\n        unsigned int bs_info_len = 1 << (sconf->block_switching + 2);\n        *bs_info = get_bits_long(gb, bs_info_len);\n        *bs_info <<= (32 - bs_info_len);\n    }\n    ctx->num_blocks = 0;\n    parse_bs_info(*bs_info, 0, 0, &ptr_div_blocks, &ctx->num_blocks);\n    for (b = 0; b < ctx->num_blocks; b++)\n        div_blocks[b] = ctx->sconf.frame_length >> div_blocks[b];\n    if (ctx->cur_frame_length != ctx->sconf.frame_length) {\n        unsigned int remaining = ctx->cur_frame_length;\n        for (b = 0; b < ctx->num_blocks; b++) {\n            if (remaining <= div_blocks[b]) {\n                div_blocks[b] = remaining;\n                ctx->num_blocks = b + 1;\n                break;\n            }\n            remaining -= div_blocks[b];\n        }\n    }\n}", "target": 0}
{"code": "void Document::CheckCompleted() {\n  if (!ShouldComplete())\n    return;\n  if (frame_) {\n    frame_->Client()->RunScriptsAtDocumentIdle();\n    if (!frame_)\n      return;\n    if (!ShouldComplete())\n      return;\n  }\n  SetReadyState(kComplete);\n  if (LoadEventStillNeeded())\n    ImplicitClose();\n  if (!frame_ || !frame_->IsAttached())\n    return;\n  if (frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n      SavePreviousDocumentResources::kUntilOnLoad) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  frame_->GetNavigationScheduler().StartTimer();\n  View()->HandleLoadCompleted();\n  if (!AllDescendantsAreComplete(frame_))\n    return;\n  if (!Loader()->SentDidFinishLoad()) {\n    if (frame_->IsMainFrame())\n      ViewportDescription().ReportMobilePageStats(frame_);\n    Loader()->SetSentDidFinishLoad();\n    frame_->Client()->DispatchDidFinishLoad();\n    if (!frame_)\n      return;\n  }\n  frame_->Loader().DidFinishNavigation();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectBasicTwoPredCompoundMatchesIdxOrder2) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"b\" << 1));\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a:1, b:1}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {b:1}, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:1}, node: \"\n        \"{ixscan: {filter: null, pattern: {b:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1, b: 1}, node: {andSorted: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {a:1}}},\"\n        \"{ixscan: {filter: null, pattern: {b:1}}}]}}}}\");\n}", "target": 0}
{"code": "static int vidioc_streamon(struct file *file, void *private_data, enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\topener = file->private_data;\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\topener->type = WRITER;\n\t\tdev->ready_for_output = 0;\n\t\tif (!dev->ready_for_capture) {\n\t\t\tint ret = allocate_buffers(dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tdev->ready_for_capture = 1;\n\t\t}\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\topener->type = READER;\n\t\tif (!dev->ready_for_capture)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n        return -EINVAL;\n}", "target": 0}
{"code": "isdn_net_adjust_hdr(struct sk_buff *skb, struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tif (!skb)\n\t\treturn;\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\n\t\tconst int pullsize = skb_network_offset(skb) - ETH_HLEN;\n\t\tif (pullsize > 0) {\n\t\t\tprintk(KERN_DEBUG \"isdn_net: Pull junk %d\\n\", pullsize);\n\t\t\tskb_pull(skb, pullsize);\n\t\t}\n\t}\n}", "target": 0}
{"code": "process_anchor(struct parsed_tag *tag, char *tagbuf)\n{\n    if (parsedtag_need_reconstruct(tag)) {\n\tparsedtag_set_value(tag, ATTR_HSEQ, Sprintf(\"%d\", cur_hseq++)->ptr);\n\treturn parsedtag2str(tag);\n    }\n    else {\n\tStr tmp = Sprintf(\"<a hseq=\\\"%d\\\"\", cur_hseq++);\n\tStrcat_charp(tmp, tagbuf + 2);\n\treturn tmp;\n    }\n}", "target": 0}
{"code": "  explicit OverlayWindowFrameView(views::Widget* widget) : widget_(widget) {}", "target": 0}
{"code": "bool error_if_full_join(JOIN *join)\n{\n  for (JOIN_TAB *tab=first_top_level_tab(join, WITH_CONST_TABLES); tab;\n       tab= next_top_level_tab(join, tab))\n  {\n    if (tab->type == JT_ALL && (!tab->select || !tab->select->quick))\n    {\n      my_message(ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE,\n                 ER_THD(join->thd,\n                        ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE), MYF(0));\n      return(1);\n    }\n  }\n  return(0);\n}", "target": 0}
{"code": "check_password(char *cp)\n{\n\tunsigned int i;\n\tif (cp == NULL)\n\t\treturn PR_FALSE;\n\tfor (i = 0; cp[i] != 0; i++) {\n\t\tif (!isprint(cp[i]))\n\t\t\treturn PR_FALSE;\n\t}\n\tif (i == 0)\n\t\treturn PR_FALSE;\n\treturn PR_TRUE;\n}", "target": 0}
{"code": "static inline void dec_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\tatomic_long_dec(&n->nr_slabs);\n\tatomic_long_sub(objects, &n->total_objects);\n}", "target": 0}
{"code": "TextCheckerClient* EditorClientBlackBerry::textChecker()\n{\n    return this;\n}", "target": 0}
{"code": "    void TiffDecoder::visitDataEntry(TiffDataEntry* object)\n    {\n        decodeTiffEntry(object);\n    }", "target": 0}
{"code": "soup_client_context_ref (SoupClientContext *client)\n{\n\tclient->ref_count++;\n\treturn client;\n}", "target": 0}
{"code": "    Image::UniquePtr ImageFactory::open(const std::wstring& wpath, bool useCurl)\n    {\n        Image::UniquePtr image = open(ImageFactory::createIo(wpath, useCurl)); \n        if (image.get() == 0) throw WError(kerFileContainsUnknownImageType, wpath);\n        return image;\n    }", "target": 0}
{"code": "Method* InstanceKlass::find_method(const Array<Method*>* methods,\n                                   const Symbol* name,\n                                   const Symbol* signature) {\n  return InstanceKlass::find_method_impl(methods,\n                                         name,\n                                         signature,\n                                         find_overpass,\n                                         find_static,\n                                         find_private);\n}", "target": 0}
{"code": "int mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write\" ) );\n    if( ssl == NULL || ssl->conf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ( ret = ssl_check_ctr_renegotiate( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_check_ctr_renegotiate\", ret );\n        return( ret );\n    }\n#endif\n    if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )\n    {\n        if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    ret = ssl_write_split( ssl, buf, len );\n#else\n    ret = ssl_write_real( ssl, buf, len );\n#endif\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write\" ) );\n    return( ret );\n}", "target": 0}
{"code": "seamless_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tchar *buf;\n\tstruct stream packet = *s;\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);\n\t}\n\tpkglen = s->end - s->p;\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n#if 0\n\tprintf(\"seamless recv:\\n\");\n\thexdump(s->p, pkglen);\n#endif\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\txfree(buf);\n}", "target": 0}
{"code": "void HTMLSelectElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == sizeAttr) {\n        int oldSize = m_size;\n        int size = value.toInt();\n        AtomicString attrSize = AtomicString::number(size);\n        if (attrSize != value) {\n            if (Attribute* sizeAttribute = ensureUniqueElementData()->getAttributeItem(sizeAttr))\n                sizeAttribute->setValue(attrSize);\n        }\n        size = max(size, 1);\n        if (oldSize != size)\n            updateListItemSelectedStates();\n        m_size = size;\n        setNeedsValidityCheck();\n        if (m_size != oldSize && inActiveDocument()) {\n            lazyReattachIfAttached();\n            setRecalcListItems();\n        }\n    } else if (name == multipleAttr)\n        parseMultipleAttribute(value);\n    else if (name == accesskeyAttr) {\n    } else\n        HTMLFormControlElementWithState::parseAttribute(name, value);\n}", "target": 0}
{"code": "SWFShape_drawScaledLine(SWFShape shape, int dx, int dy)\n{\n\tShapeRecord record;\n\tif ( shape->isEnded )\n\t\treturn;\n\tif ( dx == 0 && dy == 0 )\n\t\treturn;\n\trecord = newShapeRecord(shape, SHAPERECORD_LINETO);\n\tSWF_assert(SWFOutput_numSBits(dx) < 18);\n\tSWF_assert(SWFOutput_numSBits(dy) < 18);\n\trecord.record.lineTo->dx = dx;\n\trecord.record.lineTo->dy = dy;\n\tshape->xpos += dx;\n\tshape->ypos += dy;\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}", "target": 0}
{"code": "cmsBool OpenOutput(const char* FileName)\n{\n\tOutFile = fopen(FileName, \"wb\");\n\tif (OutFile == NULL) {\n\t\tFatalError(\"Cannot create '%s'\", FileName);\n\t}\n\tCompressor.err                   = jpeg_std_error(&ErrorHandler.pub);\n\tErrorHandler.pub.error_exit      = my_error_exit;\n\tErrorHandler.pub.output_message  = my_error_exit;\n\tCompressor.input_components = Compressor.num_components = 4;\n\tjpeg_create_compress(&Compressor);\n\tjpeg_stdio_dest(&Compressor, OutFile);\n\treturn TRUE;\n}", "target": 0}
{"code": "int sldns_str2wire_ilnp64_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d;\n\tuint16_t shorts[4];\n\tint l;\n\tif(*len < sizeof(shorts))\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%4x:%4x:%4x:%4x%n\", &a, &b, &c, &d, &l) != 4 ||\n\t\t\tl != (int)strlen(str) || \n\t\t\tstrpbrk(str, \"+-\")       \n\t\t\t)\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_ILNP64;\n\tshorts[0] = htons(a);\n\tshorts[1] = htons(b);\n\tshorts[2] = htons(c);\n\tshorts[3] = htons(d);\n\tmemmove(rd, &shorts, sizeof(shorts));\n\t*len = sizeof(shorts);\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "static void opj_j2k_setup_decoding_tile (opj_j2k_t *p_j2k)\n{\n        assert(p_j2k != 00);\n        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_one_tile);\n}", "target": 0}
{"code": "static void encrypted_destroy(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tif (!epayload)\n\t\treturn;\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(key->payload.data);\n}", "target": 0}
{"code": "void audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\tselinux_get_task_sid(current, &sid);\n\tif (!sid)\n\t\treturn;\n\terror = selinux_sid_to_string(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tkfree(ctx);\n\treturn;\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn;\n}", "target": 0}
{"code": "void RootWindow::ShowCursor(bool show) {\n  cursor_shown_ = show;\n  host_->ShowCursor(show);\n}", "target": 0}
{"code": "static int rb_head_page_set_update(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t   struct buffer_page *head,\n\t\t\t\t   struct buffer_page *prev,\n\t\t\t\t   int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_UPDATE);\n}", "target": 0}
{"code": "static int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_openres *o_res = &data->o_res;\n        int status;\n\tstatus = nfs4_run_open_task(data, 1);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\treturn status;\n}", "target": 0}
{"code": "win_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = frame_minheight(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_noroom));\n\t    first = FALSE;\n\t}\n    }\n}", "target": 0}
{"code": "escape_remove_attachment (int argc, char **argv, compose_env_t *env)\n{\n  size_t count;\n  unsigned long n;\n  char *p;\n  if (escape_check_args (argc, argv, 2, 2))\n    return 1;\n  n = strtoul (argv[1], &p, 10);\n  if (*p)\n    {\n      mu_error (_(\"not a valid number: %s\"), argv[1]);\n      return 1;\n    }\n  mu_list_count (env->attlist, &count);\n  if (n == 0 || n > count)\n    {\n      mu_error (_(\"index out of range\"));\n      return 1;\n    }\n  return mu_list_remove_nth (env->attlist, n - 1);\n}", "target": 0}
{"code": "vmcs12_guest_cr0(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t\t(vmcs_readl(GUEST_CR0) & vcpu->arch.cr0_guest_owned_bits) |\n\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask) |\n\t\t(vmcs_readl(CR0_READ_SHADOW) & ~(vmcs12->cr0_guest_host_mask |\n\t\t\tvcpu->arch.cr0_guest_owned_bits));\n}", "target": 0}
{"code": "\tGenerationPtr getGeneration(unsigned int number) const {\n\t\treturn ptr(new Generation(path, number));\n\t}", "target": 0}
{"code": "  static inline float Tg(void) throw() { return 256.0f; }", "target": 0}
{"code": "linux_md_remove_component_device_not_seen_cb (gpointer user_data)\n{\n  RemoveComponentData *data = user_data;\n  throw_error (data->context,\n               ERROR_FAILED,\n               \"Error removing component: timeout (10s) waiting for slave to stop being busy\");\n  g_signal_handler_disconnect (data->slave->priv->daemon, data->device_changed_signal_handler_id);\n  remove_component_data_unref (data);\n  return FALSE;\n}", "target": 0}
{"code": "static int dsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,\n                          ASN1_PCTX *ctx)\n{\n    return do_dsa_print(bp, pkey->pkey.dsa, indent, 2);\n}", "target": 0}
{"code": "u32 kvm_read_and_reset_pf_reason(void)\n{\n\tu32 reason = 0;\n\tif (__this_cpu_read(apf_reason.enabled)) {\n\t\treason = __this_cpu_read(apf_reason.reason);\n\t\t__this_cpu_write(apf_reason.reason, 0);\n\t}\n\treturn reason;\n}", "target": 0}
{"code": "void wrap_ident(THD *thd, Item **conds)\n{\n  Item_direct_ref_to_ident *wrapper;\n  DBUG_ASSERT((*conds)->type() == Item::FIELD_ITEM || (*conds)->type() == Item::REF_ITEM);\n  Query_arena *arena, backup;\n  arena= thd->activate_stmt_arena_if_needed(&backup);\n  if ((wrapper= new (thd->mem_root) Item_direct_ref_to_ident(thd, (Item_ident *) (*conds))))\n    (*conds)= (Item*) wrapper;\n  if (arena)\n    thd->restore_active_arena(arena, &backup);\n}", "target": 0}
{"code": "sg_last_dev(void)\n{\n\tint k = -1;\n\tunsigned long iflags;\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tidr_for_each(&sg_index_idr, sg_idr_max_id, &k);\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn k + 1;\t\t\n}", "target": 0}
{"code": "void DHT::refine_idiag_dirs(int i)\n{\n  int iwidth = libraw.imgdata.sizes.iwidth;\n  for (int j = 0; j < iwidth; j++)\n  {\n    int x = j + nr_leftmargin;\n    int y = i + nr_topmargin;\n    if (ndir[nr_offset(y, x)] & DIASH)\n      continue;\n    int nv = (ndir[nr_offset(y - 1, x)] & LURD) +\n             (ndir[nr_offset(y + 1, x)] & LURD) +\n             (ndir[nr_offset(y, x - 1)] & LURD) +\n             (ndir[nr_offset(y, x + 1)] & LURD) +\n             (ndir[nr_offset(y - 1, x - 1)] & LURD) +\n             (ndir[nr_offset(y - 1, x + 1)] & LURD) +\n             (ndir[nr_offset(y + 1, x - 1)] & LURD) +\n             (ndir[nr_offset(y + 1, x + 1)] & LURD);\n    int nh = (ndir[nr_offset(y - 1, x)] & RULD) +\n             (ndir[nr_offset(y + 1, x)] & RULD) +\n             (ndir[nr_offset(y, x - 1)] & RULD) +\n             (ndir[nr_offset(y, x + 1)] & RULD) +\n             (ndir[nr_offset(y - 1, x - 1)] & RULD) +\n             (ndir[nr_offset(y - 1, x + 1)] & RULD) +\n             (ndir[nr_offset(y + 1, x - 1)] & RULD) +\n             (ndir[nr_offset(y + 1, x + 1)] & RULD);\n    bool codir = (ndir[nr_offset(y, x)] & LURD)\n                     ? ((ndir[nr_offset(y - 1, x - 1)] & LURD) ||\n                        (ndir[nr_offset(y + 1, x + 1)] & LURD))\n                     : ((ndir[nr_offset(y - 1, x + 1)] & RULD) ||\n                        (ndir[nr_offset(y + 1, x - 1)] & RULD));\n    nv /= LURD;\n    nh /= RULD;\n    if ((ndir[nr_offset(y, x)] & LURD) && nh > 7)\n    {\n      ndir[nr_offset(y, x)] &= ~LURD;\n      ndir[nr_offset(y, x)] |= RULD;\n    }\n    if ((ndir[nr_offset(y, x)] & RULD) && nv > 7)\n    {\n      ndir[nr_offset(y, x)] &= ~RULD;\n      ndir[nr_offset(y, x)] |= LURD;\n    }\n  }\n}", "target": 0}
{"code": "int snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, true);\n\telse\n\t\treturn snd_timer_stop1(timeri, true);\n}", "target": 0}
{"code": "void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t      struct net_device *netdev, const u8 *bssid,\n\t\t\t      const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\trekey_attr = nla_nest_start(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, rekey_attr);\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "cmsToneCurve* CMSEXPORT cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[])\n{\n    cmsCurveSegment Seg[3];\n    Seg[0].x0 = MINUS_INF;\n    Seg[0].x1 = 0;\n    Seg[0].Type = 6;\n    Seg[0].Params[0] = 1;\n    Seg[0].Params[1] = 0;\n    Seg[0].Params[2] = 0;\n    Seg[0].Params[3] = values[0];\n    Seg[0].Params[4] = 0;\n    Seg[1].x0 = 0;\n    Seg[1].x1 = 1.0;\n    Seg[1].Type = 0;\n    Seg[1].nGridPoints = nEntries;\n    Seg[1].SampledPoints = (cmsFloat32Number*) values;\n\tSeg[2].x0 = 1.0;\n\tSeg[2].x1 = PLUS_INF;\n\tSeg[2].Type = 6;\n    Seg[2].Params[0] = 1;\n    Seg[2].Params[1] = 0;\n    Seg[2].Params[2] = 0;\n    Seg[2].Params[3] = values[nEntries-1];\n    Seg[2].Params[4] = 0;\n    return cmsBuildSegmentedToneCurve(ContextID, 3, Seg);\n}", "target": 0}
{"code": "static int stat_to_qid(V9fsPDU *pdu, const struct stat *stbuf, V9fsQID *qidp)\n{\n    int err;\n    size_t size;\n    if (pdu->s->ctx.export_flags & V9FS_REMAP_INODES) {\n        err = qid_path_suffixmap(pdu, stbuf, &qidp->path);\n        if (err == -ENFILE) {\n            err = qid_path_fullmap(pdu, stbuf, &qidp->path);\n        }\n        if (err) {\n            return err;\n        }\n    } else {\n        if (pdu->s->dev_id != stbuf->st_dev) {\n            if (pdu->s->ctx.export_flags & V9FS_FORBID_MULTIDEVS) {\n                error_report_once(\n                    \"9p: Multiple devices detected in same VirtFS export. \"\n                    \"Access of guest to additional devices is (partly) \"\n                    \"denied due to virtfs option 'multidevs=forbid' being \"\n                    \"effective.\"\n                );\n                return -ENODEV;\n            } else {\n                warn_report_once(\n                    \"9p: Multiple devices detected in same VirtFS export, \"\n                    \"which might lead to file ID collisions and severe \"\n                    \"misbehaviours on guest! You should either use a \"\n                    \"separate export for each device shared from host or \"\n                    \"use virtfs option 'multidevs=remap'!\"\n                );\n            }\n        }\n        memset(&qidp->path, 0, sizeof(qidp->path));\n        size = MIN(sizeof(stbuf->st_ino), sizeof(qidp->path));\n        memcpy(&qidp->path, &stbuf->st_ino, size);\n    }\n    qidp->version = stbuf->st_mtime ^ (stbuf->st_size << 8);\n    qidp->type = 0;\n    if (S_ISDIR(stbuf->st_mode)) {\n        qidp->type |= P9_QID_TYPE_DIR;\n    }\n    if (S_ISLNK(stbuf->st_mode)) {\n        qidp->type |= P9_QID_TYPE_SYMLINK;\n    }\n    return 0;\n}", "target": 0}
{"code": "JNIid::JNIid(Klass* holder, int offset, JNIid* next) {\n  _holder = holder;\n  _offset = offset;\n  _next = next;\n  debug_only(_is_static_field_id = false;)\n}", "target": 0}
{"code": "void LibRaw::lossy_dng_load_raw() {}", "target": 0}
{"code": "static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)\n{\n  size_t oldsize = p->size, i;\n  if(!ucvector_resize(p, size)) return 0;\n  for(i = oldsize; i < size; i++) p->data[i] = value;\n  return 1;\n}", "target": 0}
{"code": "epass2003_finish(sc_card_t *card)\n{\n\tepass2003_exdata *exdata = (epass2003_exdata *)card->drv_data;\n\tif (exdata)\n\t\tfree(exdata);\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "\tvirtual void describe()\n\t{\n\t\tm_outChunk->f.byteOrder = m_inChunk->f.byteOrder == AF_BYTEORDER_BIGENDIAN ?\n\t\t\tAF_BYTEORDER_LITTLEENDIAN : AF_BYTEORDER_BIGENDIAN;\n\t}", "target": 0}
{"code": "bool Browser::CheckMediaAccessPermission(content::WebContents* web_contents,\n                                         const GURL& security_origin,\n                                         content::MediaStreamType type) {\n  return ::CheckMediaAccessPermission(web_contents, security_origin, type);\n}", "target": 0}
{"code": "cp1251_apply_all_case_fold(OnigCaseFoldType flag,\n\t\t\t       OnigApplyAllCaseFoldFunc f, void* arg, OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             numberof(CaseFoldMap), CaseFoldMap, 0,\n             flag, f, arg);\n}", "target": 0}
{"code": "   Format a local date/time */\nPHP_FUNCTION(date)\n{\n\tphp_date(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);", "target": 0}
{"code": "static void to_words52(BN_ULONG *out, int out_len,\n                       const BN_ULONG *in, int in_bitsize)\n{\n    uint8_t *in_str = NULL;\n    assert(out != NULL);\n    assert(in != NULL);\n    assert(out_len >= number_of_digits(in_bitsize, DIGIT_SIZE));\n    in_str = (uint8_t *)in;\n    for (; in_bitsize >= (2 * DIGIT_SIZE); in_bitsize -= (2 * DIGIT_SIZE), out += 2) {\n        out[0] = (*(uint64_t *)in_str) & DIGIT_MASK;\n        in_str += 6;\n        out[1] = ((*(uint64_t *)in_str) >> 4) & DIGIT_MASK;\n        in_str += 7;\n        out_len -= 2;\n    }\n    if (in_bitsize > DIGIT_SIZE) {\n        uint64_t digit = get_digit52(in_str, 7);\n        out[0] = digit & DIGIT_MASK;\n        in_str += 6;\n        in_bitsize -= DIGIT_SIZE;\n        digit = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out[1] = digit >> 4;\n        out += 2;\n        out_len -= 2;\n    } else if (in_bitsize > 0) {\n        out[0] = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out++;\n        out_len--;\n    }\n    while (out_len > 0) {\n        *out = 0;\n        out_len--;\n        out++;\n    }\n}", "target": 0}
{"code": "int APE::Properties::version() const\n{\n  return d->version;\n}", "target": 0}
{"code": "gfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}", "target": 0}
{"code": "static inline void unix_get_secdata(struct scm_cookie *scm, struct sk_buff *skb)\n{ }", "target": 0}
{"code": "String GetTypeExtension(Document* document,\n                        const StringOrDictionary& string_or_options,\n                        ExceptionState& exception_state) {\n  if (string_or_options.IsNull())\n    return g_empty_string;\n  if (string_or_options.IsString()) {\n    UseCounter::Count(document,\n                      WebFeature::kDocumentCreateElement2ndArgStringHandling);\n    return string_or_options.GetAsString();\n  }\n  if (string_or_options.IsDictionary()) {\n    Dictionary dict = string_or_options.GetAsDictionary();\n    ElementCreationOptions impl;\n    V8ElementCreationOptions::ToImpl(dict.GetIsolate(), dict.V8Value(), impl,\n                                     exception_state);\n    if (exception_state.HadException())\n      return g_empty_string;\n    if (impl.hasIs())\n      return impl.is();\n  }\n  return g_empty_string;\n}", "target": 0}
{"code": "static ha_rows get_quick_record_count(THD *thd, SQL_SELECT *select,\n\t\t\t\t      TABLE *table,\n\t\t\t\t      const key_map *keys,ha_rows limit)\n{\n  int error;\n  DBUG_ENTER(\"get_quick_record_count\");\n  uchar buff[STACK_BUFF_ALLOC];\n  if (check_stack_overrun(thd, STACK_MIN_SIZE, buff))\n    DBUG_RETURN(0);                           \n  if (select)\n  {\n    select->head=table;\n    table->reginfo.impossible_range=0;\n    if ((error= select->test_quick_select(thd, *(key_map *)keys,(table_map) 0,\n                                          limit, 0, FALSE, \n                                          TRUE )) == 1)\n      DBUG_RETURN(select->quick->records);\n    if (error == -1)\n    {\n      table->reginfo.impossible_range=1;\n      DBUG_RETURN(0);\n    }\n    DBUG_PRINT(\"warning\",(\"Couldn't use record count on const keypart\"));\n  }\n  DBUG_RETURN(HA_POS_ERROR);\t\t\t\n}", "target": 0}
{"code": "static int lxcfs_releasedir(const char *path, struct fuse_file_info *fi)\n{\n\tif (strcmp(path, \"/\") == 0)\n\t\treturn 0;\n\tif (strncmp(path, \"/cgroup\", 7) == 0) {\n\t\treturn cg_releasedir(path, fi);\n\t}\n\tif (strcmp(path, \"/proc\") == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "void gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}", "target": 0}
{"code": "static int get_alloted(char *me, char *intype, char *link,\n\t\t       struct alloted_s **alloted)\n{\n\tint n, ret;\n\tchar name[100], type[100], br[100];\n\tchar **groups;\n\tFILE *fin;\n\tint count = 0;\n\tsize_t len = 0;\n\tchar *line = NULL;\n\tfin = fopen(LXC_USERNIC_CONF, \"r\");\n\tif (!fin) {\n\t\tusernic_error(\"Failed to open \\\"%s\\\": %s\\n\", LXC_USERNIC_CONF,\n\t\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name,\n\t\t\t     type, br, &n);\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(name, me)) {\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name + 1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype))\n\t\t\tcontinue;\n\t\tif (strcmp(link, br))\n\t\t\tcontinue;\n\t\tif (!append_alloted(alloted, name, n)) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\treturn count;\n}", "target": 0}
{"code": "ChildProcessSecurityPolicy* ChildProcessSecurityPolicy::GetInstance() {\n  return Singleton<ChildProcessSecurityPolicy>::get();\n}", "target": 0}
{"code": "void SimpleSoftOMXComponent::onMessageReceived(const sp<AMessage> &msg) {\n Mutex::Autolock autoLock(mLock);\n uint32_t msgType = msg->what();\n    ALOGV(\"msgType = %d\", msgType);\n switch (msgType) {\n case kWhatSendCommand:\n {\n int32_t cmd, param;\n            CHECK(msg->findInt32(\"cmd\", &cmd));\n            CHECK(msg->findInt32(\"param\", &param));\n            onSendCommand((OMX_COMMANDTYPE)cmd, (OMX_U32)param);\n break;\n }\n case kWhatEmptyThisBuffer:\n case kWhatFillThisBuffer:\n {\n            OMX_BUFFERHEADERTYPE *header;\n            CHECK(msg->findPointer(\"header\", (void **)&header));\n            CHECK(mState == OMX_StateExecuting && mTargetState == mState);\n bool found = false;\n size_t portIndex = (kWhatEmptyThisBuffer == msgType)?\n                    header->nInputPortIndex: header->nOutputPortIndex;\n PortInfo *port = &mPorts.editItemAt(portIndex);\n for (size_t j = 0; j < port->mBuffers.size(); ++j) {\n BufferInfo *buffer = &port->mBuffers.editItemAt(j);\n if (buffer->mHeader == header) {\n                    CHECK(!buffer->mOwnedByUs);\n                    buffer->mOwnedByUs = true;\n                    CHECK((msgType == kWhatEmptyThisBuffer\n && port->mDef.eDir == OMX_DirInput)\n || (port->mDef.eDir == OMX_DirOutput));\n                    port->mQueue.push_back(buffer);\n                    onQueueFilled(portIndex);\n                    found = true;\n break;\n }\n }\n            CHECK(found);\n break;\n }\n default:\n            TRESPASS();\n break;\n }\n}", "target": 0}
{"code": "static float lite_font_stringwidth( wmfAPI* API, wmfFont* font, char* str)\n{\n#if 0\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  DrawInfo\n    *draw_info;\n  ExceptionInfo\n    *exception;\n  TypeMetric\n    metrics;\n  float\n    stringwidth = 0;\n  double\n    orig_x_resolution,\n    orig_y_resolution;\n  ResolutionType\n    orig_resolution_units;\n  orig_x_resolution = image->resolution.x;\n  orig_y_resolution = image->resolution.y;\n  orig_resolution_units = image->units;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=12;\n  draw_info->text=str;\n  image->resolution.x = 72;\n  image->resolution.y = 72;\n  image->units = PixelsPerInchResolution;\n  exception=ddata->exception;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    stringwidth = ((metrics.width * 72)/(image->resolution.x * draw_info->pointsize)); \n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"\\nlite_font_stringwidth\\n\");\n  printf(\"string                  = \\\"%s\\\"\\n\", str);\n  printf(\"WMF_FONT_NAME           = \\\"%s\\\"\\n\", WMF_FONT_NAME(font));\n  printf(\"WMF_FONT_PSNAME         = \\\"%s\\\"\\n\", WMF_FONT_PSNAME(font));\n  printf(\"stringwidth             = %g\\n\", stringwidth);\n  fflush(stdout);\n#endif\n  image->resolution.x = orig_x_resolution;\n  image->resolution.y = orig_y_resolution;\n  image->units = orig_resolution_units;\n  return stringwidth;\n#else\n  (void) API;\n  (void) font;\n  (void) str;\n  return 0;\n#endif\n}", "target": 0}
{"code": "GfxColorSpace *GfxDeviceCMYKColorSpace::copy() const\n{\n    return new GfxDeviceCMYKColorSpace();\n}", "target": 0}
{"code": "InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser& parser, TRAPS) {\n  const int size = InstanceKlass::size(parser.vtable_size(),\n                                       parser.itable_size(),\n                                       nonstatic_oop_map_size(parser.total_oop_map_count()),\n                                       parser.is_interface());\n  const Symbol* const class_name = parser.class_name();\n  assert(class_name != NULL, \"invariant\");\n  ClassLoaderData* loader_data = parser.loader_data();\n  assert(loader_data != NULL, \"invariant\");\n  InstanceKlass* ik;\n  if (REF_NONE == parser.reference_type()) {\n    if (class_name == vmSymbols::java_lang_Class()) {\n      ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n    }\n    else if (is_class_loader(class_name, parser)) {\n      ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n    } else {\n      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);\n    }\n  } else {\n    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n  }\n  if (HAS_PENDING_EXCEPTION) {\n    return NULL;\n  }\n  return ik;\n}", "target": 0}
{"code": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\t*_dest_keyring = NULL;\n\tif (ringid == 0)\n\t\treturn 0;\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\treturn -ENOKEY;\n}", "target": 0}
{"code": "static void isdn_ppp_mp_cleanup(isdn_net_local *lp)\n{\n\tstruct sk_buff *frag = lp->netdev->pb->frags;\n\tstruct sk_buff *nextfrag;\n\twhile (frag) {\n\t\tnextfrag = frag->next;\n\t\tisdn_ppp_mp_free_skb(lp->netdev->pb, frag);\n\t\tfrag = nextfrag;\n\t}\n\tlp->netdev->pb->frags = NULL;\n}", "target": 0}
{"code": "njs_string_decode_uri_cp(const int8_t *hex, const u_char **start,\n    const u_char *end, njs_bool_t expect_percent)\n{\n    int8_t                d0, d1;\n    uint32_t              cp;\n    const u_char          *p;\n    njs_unicode_decode_t  ctx;\n    njs_utf8_decode_init(&ctx);\n    cp = njs_utf8_decode(&ctx, start, end);\n    if (njs_fast_path(cp != '%')) {\n        return expect_percent ? NJS_UNICODE_ERROR : cp;\n    }\n    p = *start;\n    if (njs_slow_path((p + 1) >= end)) {\n        return NJS_UNICODE_ERROR;\n    }\n    d0 = hex[*p++];\n    if (njs_slow_path(d0 < 0)) {\n        return NJS_UNICODE_ERROR;\n    }\n    d1 = hex[*p++];\n    if (njs_slow_path(d1 < 0)) {\n        return NJS_UNICODE_ERROR;\n    }\n    *start += 2;\n    return (d0 << 4) + d1;\n}", "target": 0}
{"code": "static void xennet_tx_setup_grant(unsigned long gfn, unsigned int offset,\n\t\t\t\t  unsigned int len, void *data)\n{\n\tstruct xennet_gnttab_make_txreq *info = data;\n\tunsigned int id;\n\tstruct xen_netif_tx_request *tx;\n\tgrant_ref_t ref;\n\tstruct page *page = info->page;\n\tstruct netfront_queue *queue = info->queue;\n\tstruct sk_buff *skb = info->skb;\n\tid = get_id_from_list(&queue->tx_skb_freelist, queue->tx_link);\n\ttx = RING_GET_REQUEST(&queue->tx, queue->tx.req_prod_pvt++);\n\tref = gnttab_claim_grant_reference(&queue->gref_tx_head);\n\tWARN_ON_ONCE(IS_ERR_VALUE((unsigned long)(int)ref));\n\tgnttab_grant_foreign_access_ref(ref, queue->info->xbdev->otherend_id,\n\t\t\t\t\tgfn, GNTMAP_readonly);\n\tqueue->tx_skbs[id] = skb;\n\tqueue->grant_tx_page[id] = page;\n\tqueue->grant_tx_ref[id] = ref;\n\tinfo->tx_local.id = id;\n\tinfo->tx_local.gref = ref;\n\tinfo->tx_local.offset = offset;\n\tinfo->tx_local.size = len;\n\tinfo->tx_local.flags = 0;\n\t*tx = info->tx_local;\n\tadd_id_to_list(&queue->tx_pend_queue, queue->tx_link, id);\n\tinfo->tx = tx;\n\tinfo->size += info->tx_local.size;\n}", "target": 0}
{"code": "rfbMulM64(uint64_t x, uint64_t y, uint64_t m)\n{\n  uint64_t r;\n  for(r=0;x>0;x>>=1)\n  {\n    if (x&1) r=rfbAddM64(r,y,m);\n    y=rfbAddM64(y,y,m);\n  }\n  return r;\n}", "target": 0}
{"code": "GLSurfaceOzoneEGL::~GLSurfaceOzoneEGL() {\n  Destroy();  \n}", "target": 0}
{"code": "crm_ipc_close(crm_ipc_t * client)\n{\n    if (client) {\n        crm_trace(\"Disconnecting %s IPC connection %p (%p.%p)\", client->name, client, client->ipc);\n        if (client->ipc) {\n            qb_ipcc_connection_t *ipc = client->ipc;\n            client->ipc = NULL;\n            qb_ipcc_disconnect(ipc);\n        }\n    }\n}", "target": 0}
{"code": "void LIRGenerator::increment_counter(address counter, BasicType type, int step) {\n  LIR_Opr pointer = new_pointer_register();\n  __ move(LIR_OprFact::intptrConst(counter), pointer);\n  LIR_Address* addr = new LIR_Address(pointer, type);\n  increment_counter(addr, step);\n}", "target": 0}
{"code": "void ThreadWatcher::ActivateThreadWatching() {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  if (active_) return;\n  active_ = true;\n  ping_count_ = unresponsive_threshold_;\n  ResetHangCounters();\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::Bind(&ThreadWatcher::PostPingMessage,\n                            weak_ptr_factory_.GetWeakPtr()));\n}", "target": 0}
{"code": "ui::EventTargeter* Shell::GetEventTargeter() {\n  NOTREACHED();\n  return nullptr;\n}", "target": 0}
{"code": "int snd_card_free_when_closed(struct snd_card *card)\n{\n\tint ret = snd_card_disconnect(card);\n\tif (ret)\n\t\treturn ret;\n\tput_device(&card->card_dev);\n\treturn 0;\n}", "target": 0}
{"code": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}", "target": 0}
{"code": "set_alignment(struct readbuffer *obuf, struct parsed_tag *tag)\n{\n    long flag = -1;\n    int align;\n    if (parsedtag_get_value(tag, ATTR_ALIGN, &align)) {\n\tswitch (align) {\n\tcase ALIGN_CENTER:\n\t    flag = RB_CENTER;\n\t    break;\n\tcase ALIGN_RIGHT:\n\t    flag = RB_RIGHT;\n\t    break;\n\tcase ALIGN_LEFT:\n\t    flag = RB_LEFT;\n\t}\n    }\n    RB_SAVE_FLAG(obuf);\n    if (flag != -1) {\n\tRB_SET_ALIGN(obuf, flag);\n    }\n}", "target": 0}
{"code": "dcputchar(char c)\n{\n\tdcchkstr(1);\n\t*dcptr++=c;\n\t*dcptr='\\000';\n\tstrsize++;\n}", "target": 0}
{"code": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}", "target": 0}
{"code": "FileSystemOperation::TaskParamsForDidGetQuota::TaskParamsForDidGetQuota()\n    : type(kFileSystemTypeUnknown) {\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ShardFilterNestedProjCovered) {\n    params.options = QueryPlannerParams::INCLUDE_SHARD_FILTER;\n    params.shardKey = BSON(\"a\" << 1 << \"b.c\" << 1);\n    addIndex(BSON(\"a\" << 1 << \"b.c\" << 1));\n    runQuerySortProj(fromjson(\"{a: 1}\"), BSONObj(), fromjson(\"{_id: 0, a: 1, 'b.c': 1}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1, 'b.c': 1 }, type: 'default', node: \"\n        \"{sharding_filter: {node: \"\n        \"{ixscan: {filter: null, pattern: {a: 1, 'b.c': 1}}}}}}}\");\n}", "target": 0}
{"code": "TEST(LtOp, MatchesScalar) {\n    BSONObj operand = BSON(\"$lt\" << 5);\n    LTMatchExpression lt(\"a\", operand[\"$lt\"]);\n    ASSERT(lt.matchesBSON(BSON(\"a\" << 4.5), NULL));\n    ASSERT(!lt.matchesBSON(BSON(\"a\" << 6), NULL));\n}", "target": 0}
{"code": "u32 gf_fs_get_http_max_rate(GF_FilterSession *fs)\n{\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_data_rate(fs->download_manager);\n}", "target": 0}
{"code": "static inline u32 perc(u32 count, u32 total)\n{\n\treturn (count * 100 + (total / 2)) / total;\n}", "target": 0}
{"code": "  PropertiesPrivate() : length(0), bitrate(0), sampleRate(0), channels(0), bitsPerSample(0) {}", "target": 0}
{"code": "static int test_asc2bn(void)\n{\n    BIGNUM *bn = NULL;\n    int st = 0;\n    if (!TEST_ptr(bn = BN_new()))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"0\"))\n            || !TEST_BN_eq_zero(bn)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"256\"))\n            || !TEST_BN_eq_word(bn, 256)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"-42\"))\n            || !TEST_BN_abs_eq_word(bn, 42)\n            || !TEST_BN_lt_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"0x1234\"))\n            || !TEST_BN_eq_word(bn, 0x1234)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"0X1234\"))\n            || !TEST_BN_eq_word(bn, 0x1234)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"-0xabcd\"))\n            || !TEST_BN_abs_eq_word(bn, 0xabcd)\n            || !TEST_BN_lt_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"-0\"))\n            || !TEST_BN_eq_zero(bn)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    if (!TEST_true(BN_asc2bn(&bn, \"123trailing garbage is ignored\"))\n            || !TEST_BN_eq_word(bn, 123)\n            || !TEST_BN_ge_zero(bn))\n        goto err;\n    st = 1;\n err:\n    BN_free(bn);\n    return st;\n}", "target": 0}
{"code": "ref_stack_allow_expansion(ref_stack_t *pstack, bool expand)\n{\n    pstack->params->allow_expansion = expand;\n}", "target": 0}
{"code": "static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}", "target": 0}
{"code": "void _WM_do_control_dummy(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n}", "target": 0}
{"code": "static int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\tstruct tnum range = tnum_range(0, 1);\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\terr = copy_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller);\n\t}\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "\tReturns the quota set to the mailbox account qroot */\nPHP_FUNCTION(imap_get_quota)\n{\n\tzval *streamind;\n\tzend_string *qroot;\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rS\", &streamind, &qroot) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tIMAPG(quota_return) = &return_value;\n\tmail_parameters(NIL, SET_QUOTA, (void *) mail_getquota);\n\tif (!imap_getquota(imap_le_struct->imap_stream, ZSTR_VAL(qroot))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"c-client imap_getquota failed\");\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "Value ExpressionRandom::evaluate(const Document& root, Variables* variables) const {\n    return Value(getRandomValue());\n}", "target": 0}
{"code": "on_randr_event (GnomeRRScreen *screen, gpointer data)\n{\n        GsdXrandrManager *manager = GSD_XRANDR_MANAGER (data);\n        GsdXrandrManagerPrivate *priv = manager->priv;\n        guint32 change_timestamp, config_timestamp;\n        if (!priv->running)\n                return;\n        gnome_rr_screen_get_timestamps (screen, &change_timestamp, &config_timestamp);\n        if (change_timestamp > config_timestamp) {\n                show_timestamps_dialog (manager, \"ignoring since change > config\");\n        } else {\n#if 1\n                auto_configure_outputs (manager, config_timestamp);\n#else\n                char *intended_filename;\n                GError *error;\n                gboolean success;\n                show_timestamps_dialog (manager, \"need to deal with reconfiguration, as config >= change\");\n                intended_filename = gnome_rr_config_get_intended_filename ();\n                error = NULL;\n                success = apply_configuration_from_filename (manager, intended_filename, TRUE, config_timestamp, &error);\n                g_free (intended_filename);\n                if (!success) {\n                        if (error)\n                                g_error_free (error);\n                        auto_configure_outputs (manager, config_timestamp);\n                }\n#endif\n        }\n        refresh_tray_icon_menu_if_active (manager, MAX (change_timestamp, config_timestamp));\n}", "target": 0}
{"code": "PHPAPI void var_destroy(php_unserialize_data_t *var_hashx)\n{\n\tvoid *next;\n\tlong i;\n\tvar_entries *var_hash = var_hashx->first;\n\twhile (var_hash) {\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n\tvar_hash = var_hashx->first_dtor;\n\twhile (var_hash) {\n\t\tfor (i = 0; i < var_hash->used_slots; i++) {\n\t\t\tzval_ptr_dtor(&var_hash->data[i]);\n\t\t}\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n}", "target": 0}
{"code": "struct btrfs_device *btrfs_scan_one_device(const char *path, fmode_t flags,\n\t\t\t\t\t   void *holder)\n{\n\tstruct btrfs_super_block *disk_super;\n\tbool new_device_added = false;\n\tstruct btrfs_device *device = NULL;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tu64 bytenr;\n\tlockdep_assert_held(&uuid_mutex);\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\tif (btrfs_read_disk_super(bdev, bytenr, &page, &disk_super)) {\n\t\tdevice = ERR_PTR(-EINVAL);\n\t\tgoto error_bdev_put;\n\t}\n\tdevice = device_list_add(path, disk_super, &new_device_added);\n\tif (!IS_ERR(device)) {\n\t\tif (new_device_added)\n\t\t\tbtrfs_free_stale_devices(path, device);\n\t}\n\tbtrfs_release_disk_super(page);\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\n\treturn device;\n}", "target": 0}
{"code": "    void TiffReader::setOrigState()\n    {\n        pState_ = &origState_;\n    }", "target": 0}
{"code": "static void ide_atapi_cmd_read_pio(IDEState *s, int lba, int nb_sectors,\n                                   int sector_size)\n{\n    s->lba = lba;\n    s->packet_transfer_size = nb_sectors * sector_size;\n    s->elementary_transfer_size = 0;\n    s->io_buffer_index = sector_size;\n    s->cd_sector_size = sector_size;\n    s->status = READY_STAT | SEEK_STAT;\n    ide_atapi_cmd_reply_end(s);\n}", "target": 0}
{"code": "bool ParamTraits<gfx::Vector2dF>::Read(const Message* m,\n                                      PickleIterator* iter,\n                                      gfx::Vector2dF* r) {\n  float x, y;\n  if (!ParamTraits<float>::Read(m, iter, &x) ||\n      !ParamTraits<float>::Read(m, iter, &y))\n    return false;\n  r->set_x(x);\n  r->set_y(y);\n  return true;\n}", "target": 0}
{"code": "void RouteToGpuProcessHostUIShimTask(int host_id, const IPC::Message& msg) {\n  GpuProcessHostUIShim* ui_shim = GpuProcessHostUIShim::FromID(host_id);\n  if (ui_shim)\n    ui_shim->OnMessageReceived(msg);\n}", "target": 0}
{"code": "static void curlfile_set_property(char *name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tchar *arg = NULL;\n\tint arg_len;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &arg, &arg_len) == FAILURE) {\n\t\treturn;\n\t}\n\tzend_update_property_string(curl_CURLFile_class, getThis(), name, strlen(name), arg TSRMLS_CC);\n}", "target": 0}
{"code": "utf32be_is_mbc_newline(const UChar* p, const UChar* end,\n\t\t       OnigEncoding enc ARG_UNUSED)\n{\n  if (p + 3 < end) {\n    if (*(p+3) == 0x0a && *(p+2) == 0 && *(p+1) == 0 && *p == 0)\n      return 1;\n#ifdef USE_UNICODE_ALL_LINE_TERMINATORS\n    if ((\n#ifndef USE_CRNL_AS_LINE_TERMINATOR\n\t *(p+3) == 0x0d ||\n#endif\n\t *(p+3) == 0x85)\n\t&& *(p+2) == 0 && *(p+1) == 0 && *p == 0x00)\n      return 1;\n    if (*(p+2) == 0x20 && (*(p+3) == 0x29 || *(p+3) == 0x28)\n\t&& *(p+1) == 0 && *p == 0)\n      return 1;\n#endif\n  }\n  return 0;\n}", "target": 0}
{"code": "static void ppp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ppp_netdev_ops;\n\tdev->hard_header_len = PPP_HDRLEN;\n\tdev->mtu = PPP_MTU;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 3;\n\tdev->type = ARPHRD_PPP;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}", "target": 0}
{"code": "set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,\n    int from, int to, const char *s, enum vdc vdc)\n{\n\tint r;\n\tswitch (vdc) {\n\tcase VDC_STD:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_LOWERCASE:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a1_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_UCS2:\n\tcase VDC_UCS2_DIRECT:\n\t\tr = set_str_utf16be(a, bp+from, s, to - from + 1,\n\t\t    0x0020, vdc);\n\t\tbreak;\n\tdefault:\n\t\tr = ARCHIVE_FATAL;\n\t}\n\treturn (r);\n}", "target": 0}
{"code": "void WebContentsImpl::DecrementCapturerCount() {\n  --capturer_count_;\n  DVLOG(1) << \"There are now \" << capturer_count_\n           << \" capturing(s) of WebContentsImpl@\" << this;\n  DCHECK_LE(0, capturer_count_);\n  if (is_being_destroyed_)\n    return;\n  if (IsHidden()) {\n    DVLOG(1) << \"Executing delayed WasHidden().\";\n    WasHidden();\n  }\n}", "target": 0}
{"code": "    int Image::pixelWidth() const\n    {\n        return pixelWidth_;\n    }", "target": 0}
{"code": "SPL_METHOD(SplFileObject, eof)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(php_stream_eof(intern->u.file.stream));\n} ", "target": 0}
{"code": "static void __qdisc_destroy(struct rcu_head *head)\n{\n\tstruct Qdisc *qdisc = container_of(head, struct Qdisc, q_rcu);\n\tkfree((char *) qdisc - qdisc->padded);\n}", "target": 0}
{"code": "static NTSTATUS ldapsrv_AbandonRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_AbandonRequest *req = &call->request->r.AbandonRequest;\n\tstruct ldapsrv_call *c = NULL;\n\tstruct ldapsrv_call *n = NULL;\n\tDEBUG(10, (\"AbandonRequest\\n\"));\n\tfor (c = call->conn->pending_calls; c != NULL; c = n) {\n\t\tn = c->next;\n\t\tif (c->request->messageid != req->messageid) {\n\t\t\tcontinue;\n\t\t}\n\t\tDLIST_REMOVE(call->conn->pending_calls, c);\n\t\tTALLOC_FREE(c);\n\t}\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "bool XSSAuditor::filterButtonToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, buttonTag));\n    return eraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin, SrcLikeAttribute);\n}", "target": 0}
{"code": "nsim_map_lookup_elem(struct bpf_offloaded_map *offmap, void *key, void *value)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx;\n\tmutex_lock(&nmap->mutex);\n\tidx = nsim_map_key_find(offmap, key);\n\tif (idx >= 0)\n\t\tmemcpy(value, nmap->entry[idx].value, offmap->map.value_size);\n\tmutex_unlock(&nmap->mutex);\n\treturn idx < 0 ? idx : 0;\n}", "target": 0}
{"code": "void ConnectDialogEdit::validate() {\n\tqsName = qleName->text().simplified();\n\tqsHostname = qleServer->text().simplified();\n\tusPort = qlePort->text().toUShort();\n\tqsUsername = qleUsername->text().simplified();\n\tqsPassword = qlePassword->text();\n\tqlePort->setDisabled(!qsHostname.isEmpty() && qsHostname.startsWith(QLatin1Char('@')));\n\tif (qsUsername.toLower() == QLatin1String(\"superuser\")) {\n\t\tqliPassword->setVisible(true);\n\t\tqlePassword->setVisible(true);\n\t\tqcbShowPassword->setVisible(true);\n\t\tadjustSize();\n\t} else if (qsPassword.isEmpty()) {\n\t\tqliPassword->setVisible(false);\n\t\tqlePassword->setVisible(false);\n\t\tqcbShowPassword->setVisible(false);\n\t\tadjustSize();\n\t}\n\tbOk = ! qsHostname.isEmpty() && ! qsUsername.isEmpty() && usPort;\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(bOk);\n}", "target": 0}
{"code": "decompileSETMEMBER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *var, *obj;\n\tval = pop();\n\tvar = pop();\n\tobj = pop();\n#ifdef DEBUG\n\tprintf(\"*SETMember* varName %s (type=%d)  objName=%s (type=%d)\\n\",getName(var),var->Type, getName(obj),obj->Type);\n#endif\n\tif (obj->Type == 12)\t\t\t\t\n\t{\n\t\tobj->Type = PUSH_VARIABLE;\t\t\n\t\treturn 0;\n\t}\n\tINDENT\n\tif (obj->Type == 11)\t\t\t\t\n\t{\n\t\tdecompilePUSHPARAM(obj,0);\n\t\tprintln(\";\");\n\t\treturn 0;\n\t}\n\tdecompilePUSHPARAM(obj,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t    || var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"[\");\n\t}\n\telse\n\t{\n\t\tputs(\".\");\n\t\tif (OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER)\n\t\t{\n\t\t\tstruct SWF_ACTIONSTOREREGISTER *sactv2 = (struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\t\tif (sactv2->Register==0)\n\t\t\t\tregs[0]=newVar3(getName(obj),\".\",getName(var));\t\t\n\t\t}\n\t}\n\tdecompilePUSHPARAM(var,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t\t|| var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"]\");\n\t}\n\tprintf(\" = \" );\n\tif ( OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER ) {\n\t\tstruct SWF_ACTIONSTOREREGISTER *sr =\n\t\t\t(struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\tprintf(\"R%d\", sr->Register);\n\t}\n\telse if (val->Type != PUSH_VARIABLE) {\n\t\tdecompilePUSHPARAM(val,1);\n\t}\n\telse {\n\t\tdecompilePUSHPARAM(val,0);\n\t}\n\tprintln(\";\");\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t psi_memory_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_MEM);\n}", "target": 0}
{"code": "LayerTilerChromium::LayerTilerChromium(LayerRendererChromium* layerRenderer, const IntSize& tileSize)\n    : m_skipsDraw(false)\n    , m_layerRenderer(layerRenderer)\n{\n    setTileSize(tileSize);\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_lo_close)\n{\n\tzval *pgsql_lofp;\n\tpgLofp *pgsql;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &pgsql_lofp) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_lofp, -1, \"PostgreSQL large object\", le_lofp);\n\tif (lo_close((PGconn *)pgsql->conn, pgsql->lofd) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to close PostgreSQL large object descriptor %d\", pgsql->lofd);\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tRETVAL_TRUE;\n\t}\n\tzend_list_delete(Z_RESVAL_P(pgsql_lofp));\n\treturn;\n}", "target": 0}
{"code": "static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}", "target": 0}
{"code": "bool SyncManager::SyncInternal::OpenDirectory() {\n  DCHECK(!initialized_) << \"Should only happen once\";\n  change_observer_ =\n      browser_sync::MakeWeakHandle(js_mutation_event_observer_.AsWeakPtr());\n  bool share_opened =\n      dir_manager()->Open(\n          username_for_share(),\n          this,\n          unrecoverable_error_handler_,\n          browser_sync::MakeWeakHandle(\n              js_mutation_event_observer_.AsWeakPtr()));\n  if (!share_opened) {\n    LOG(ERROR) << \"Could not open share for:\" << username_for_share();\n    return false;\n  }\n  syncable::ScopedDirLookup lookup(dir_manager(), username_for_share());\n  if (!lookup.good()) {\n    NOTREACHED();\n    return false;\n  }\n  connection_manager()->set_client_id(lookup->cache_guid());\n  return true;\n}", "target": 0}
{"code": "static size_t oncore_payload_cksum_length(unsigned char id1, unsigned char id2)\n{\n    size_t l;\n#define ONCTYPE(id2,id3) ((((unsigned int)id2)<<8)|(id3))\n    switch (ONCTYPE(id1,id2)) {\n    case ONCTYPE('A','b'): l = 10; break; \n    case ONCTYPE('A','w'): l =  8; break; \n    case ONCTYPE('A','c'): l = 11; break; \n    case ONCTYPE('A','a'): l = 10; break; \n    case ONCTYPE('A','d'): l = 11; break; \n    case ONCTYPE('A','e'): l = 11; break; \n    case ONCTYPE('A','f'): l = 15; break; \n    case ONCTYPE('E','a'): l = 76; break; \n    case ONCTYPE('A','g'): l =  8; break; \n    case ONCTYPE('B','b'): l = 92; break; \n    case ONCTYPE('B','j'): l =  8; break; \n    case ONCTYPE('A','q'): l =  8; break; \n    case ONCTYPE('A','p'): l = 25; break; \n    case ONCTYPE('C','h'): l =  9; break; \n    case ONCTYPE('C','b'): l = 33; break; \n    case ONCTYPE('S','z'): l =  8; break; \n    case ONCTYPE('C','j'): l = 294; break; \n    case ONCTYPE('F','a'): l =  9; break; \n    case ONCTYPE('C','f'): l =  7; break; \n    case ONCTYPE('E','q'): l = 96; break; \n    case ONCTYPE('A','u'): l = 12; break; \n    case ONCTYPE('A','v'): l =  8; break; \n    case ONCTYPE('A','N'): l =  8; break; \n    case ONCTYPE('A','O'): l =  8; break; \n    case ONCTYPE('C','c'): l = 80; break; \n    case ONCTYPE('C','k'): l =  7; break; \n    case ONCTYPE('B','o'): l =  8; break; \n    case ONCTYPE('A','z'): l = 11; break; \n    case ONCTYPE('A','y'): l = 11; break; \n    case ONCTYPE('A','P'): l =  8; break; \n    case ONCTYPE('A','s'): l = 20; break; \n    case ONCTYPE('A','t'): l =  8; break; \n    case ONCTYPE('E','n'): l = 69; break; \n    default:\n\treturn 0;\n    }\n    return l - 6;\t\t\n}", "target": 0}
{"code": "u32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static int domain_detach_iommu(struct dmar_domain *domain,\n\t\t\t       struct intel_iommu *iommu)\n{\n\tint num, count;\n\tassert_spin_locked(&device_domain_lock);\n\tassert_spin_locked(&iommu->lock);\n\tdomain->iommu_refcnt[iommu->seq_id] -= 1;\n\tcount = --domain->iommu_count;\n\tif (domain->iommu_refcnt[iommu->seq_id] == 0) {\n\t\tnum = domain->iommu_did[iommu->seq_id];\n\t\tclear_bit(num, iommu->domain_ids);\n\t\tset_iommu_domain(iommu, num, NULL);\n\t\tdomain_update_iommu_cap(domain);\n\t\tdomain->iommu_did[iommu->seq_id] = 0;\n\t}\n\treturn count;\n}", "target": 0}
{"code": "void mce_inject_log(struct mce *m)\n{\n\tmutex_lock(&mce_log_mutex);\n\tmce_log(m);\n\tmutex_unlock(&mce_log_mutex);\n}", "target": 0}
{"code": "compat_sys_io_setup(unsigned nr_reqs, u32 __user *ctx32p)\n{\n\tlong ret;\n\taio_context_t ctx64;\n\tmm_segment_t oldfs = get_fs();\n\tif (unlikely(get_user(ctx64, ctx32p)))\n\t\treturn -EFAULT;\n\tset_fs(KERNEL_DS);\n\tret = sys_io_setup(nr_reqs, (aio_context_t __user *) &ctx64);\n\tset_fs(oldfs);\n\tif (!ret)\n\t\tret = put_user((u32) ctx64, ctx32p);\n\treturn ret;\n}", "target": 0}
{"code": "should_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": "datetime_s_httpdate(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 01 Jan -4712 00:00:00 GMT\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        argv2[1] = opt;\n        if (!NIL_P(opt)) argc2++;\n\tVALUE hash = date_s__httpdate(argc2, argv2, klass);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "float LibRaw::find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n  if (width > 2064)\n    return 0.f; \n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  if (sum[0] >= 1.0 && sum[1] >= 1.0)\n    return 100 * log(sum[0] / sum[1]);\n  else\n    return 0.f;\n}", "target": 0}
{"code": "get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n\t\t     int index)\n{\n  struct ipa_agg_replacement_value *aggval;\n  aggval = ipa_get_agg_replacements_for_node (node);\n  while (aggval)\n    {\n      if (aggval->offset == offset\n\t  && aggval->index == index)\n\treturn aggval->value;\n      aggval = aggval->next;\n    }\n  return NULL_TREE;\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, SymmetricAveragePoolActivationRelu) {\n  SymmetricQuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_INT8, {1, 2, 4, 1}, -15.9375, 15.8130},\n      2, 2,\n      {TensorType_INT8, {}, -15.9375, 15.8130}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU);\n  m.SetInput({\n      0, -6, 2, 4,   \n      3, 2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75}, 0.0030)));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128 - 128, 134 - 128}));\n}", "target": 0}
{"code": "struct dst_entry *icmp6_dst_alloc(struct net_device *dev,\n\t\t\t\t  struct neighbour *neigh,\n\t\t\t\t  struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct inet6_dev *idev = in6_dev_get(dev);\n\tstruct net *net = dev_net(dev);\n\tif (unlikely(!idev))\n\t\treturn ERR_PTR(-ENODEV);\n\trt = ip6_dst_alloc(net, dev, 0, NULL);\n\tif (unlikely(!rt)) {\n\t\tin6_dev_put(idev);\n\t\tdst = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tif (neigh)\n\t\tneigh_hold(neigh);\n\telse {\n\t\tneigh = ip6_neigh_lookup(&rt->dst, NULL, &fl6->daddr);\n\t\tif (IS_ERR(neigh)) {\n\t\t\tin6_dev_put(idev);\n\t\t\tdst_free(&rt->dst);\n\t\t\treturn ERR_CAST(neigh);\n\t\t}\n\t}\n\trt->dst.flags |= DST_HOST;\n\trt->dst.output  = ip6_output;\n\trt->n = neigh;\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->rt6i_dst.addr = fl6->daddr;\n\trt->rt6i_dst.plen = 128;\n\trt->rt6i_idev     = idev;\n\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT, 255);\n\tspin_lock_bh(&icmp6_dst_lock);\n\trt->dst.next = icmp6_dst_gc_list;\n\ticmp6_dst_gc_list = &rt->dst;\n\tspin_unlock_bh(&icmp6_dst_lock);\n\tfib6_force_start_gc(net);\n\tdst = xfrm_lookup(net, &rt->dst, flowi6_to_flowi(fl6), NULL, 0);\nout:\n\treturn dst;\n}", "target": 0}
{"code": "is_like_DeviceRGB(gx_device * dev)\n{\n    subclass_color_mappings         scm;\n    frac                            cm_comp_fracs[3];\n    int                             i;\n    if ( dev->color_info.num_components != 3                   ||\n         dev->color_info.polarity != GX_CINFO_POLARITY_ADDITIVE  )\n        return false;\n    scm = get_color_mapping_procs_subclass(dev);\n    map_rgb_subclass(scm, 0, frac_1 / 4, frac_1 / 3, 3 * frac_1 / 4,cm_comp_fracs);\n    cm_comp_fracs[0] -= frac_1 / 4;\n    cm_comp_fracs[1] -= frac_1 / 3;\n    cm_comp_fracs[2] -= 3 * frac_1 / 4;\n    for ( i = 0;\n           i < 3                            &&\n           -frac_1 / 100 < cm_comp_fracs[i] &&\n           cm_comp_fracs[i] < frac_1 / 100;\n          i++ )\n        ;\n    return i == 3;\n}", "target": 0}
{"code": "void kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (__kvm_set_cr8(vcpu, cr8))\n\t\tkvm_inject_gp(vcpu, 0);\n}", "target": 0}
{"code": "static void mark_curve_tr(fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, fixed base_y, fixed height, int *table, int *index, int *id, int depth)\n{\n    fixed ax = (sx + c1x)>>1;\n    fixed ay = (sy + c1y)>>1;\n    fixed bx = (c1x + c2x)>>1;\n    fixed by = (c1y + c2y)>>1;\n    fixed cx = (c2x + ex)>>1;\n    fixed cy = (c2y + ey)>>1;\n    fixed dx = (ax + bx)>>1;\n    fixed dy = (ay + by)>>1;\n    fixed fx = (bx + cx)>>1;\n    fixed fy = (by + cy)>>1;\n    fixed gx = (dx + fx)>>1;\n    fixed gy = (dy + fy)>>1;\n    assert(depth >= 0);\n    if (depth == 0) {\n        *id += 1;\n        mark_line_tr(sx, sy, ex, ey, base_y, height, table, index, *id);\n    } else {\n        depth--;\n        mark_curve_tr(sx, sy, ax, ay, dx, dy, gx, gy, base_y, height, table, index, id, depth);\n        mark_curve_tr(gx, gy, fx, fy, cx, cy, ex, ey, base_y, height, table, index, id, depth);\n    }\n}", "target": 0}
{"code": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)\n{\n  DrawInfo\n    *clone_info;\n  MagickBooleanType\n    closed_path;\n  MagickStatusType\n    status;\n  PrimitiveInfo\n    *stroke_polygon;\n  const PrimitiveInfo\n    *p,\n    *q;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,&clone_info->stroke_pattern->exception);\n  clone_info->stroke.opacity=(Quantum) TransparentOpacity;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    if (p->coordinates == 1)\n      continue;\n    stroke_polygon=TraceStrokePolygon(draw_info,p,&image->exception);\n    if (stroke_polygon == (PrimitiveInfo *) NULL)\n      {\n        status=0;\n        break;\n      }\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon);\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    if (status == 0)\n      break;\n    q=p+p->coordinates-1;\n    closed_path=p->closed_subpath;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        status&=DrawRoundLinecap(image,draw_info,p);\n        status&=DrawRoundLinecap(image,draw_info,q);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 0}
{"code": "bool V8DOMWindow::namedSecurityCheckCustom(v8::Local<v8::Object> host, v8::Local<v8::Value> key, v8::AccessType type, v8::Local<v8::Value>)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::Handle<v8::Object> window = host->FindInstanceInPrototypeChain(V8DOMWindow::GetTemplate(isolate, worldTypeInMainThread(isolate)));\n    if (window.IsEmpty())\n        return false;  \n    DOMWindow* targetWindow = V8DOMWindow::toNative(window);\n    ASSERT(targetWindow);\n    Frame* target = targetWindow->frame();\n    if (!target)\n        return false;\n    if (target->loader()->stateMachine()->isDisplayingInitialEmptyDocument())\n        target->loader()->didAccessInitialDocument();\n    if (key->IsString()) {\n        DEFINE_STATIC_LOCAL(AtomicString, nameOfProtoProperty, (\"__proto__\", AtomicString::ConstructFromLiteral));\n        String name = toWebCoreString(key);\n        Frame* childFrame = target->tree()->scopedChild(name);\n        if (type == v8::ACCESS_HAS && childFrame)\n            return true;\n        v8::Handle<v8::String> keyString = key->ToString();\n        if (type == v8::ACCESS_GET\n            && childFrame\n            && !host->HasRealNamedProperty(keyString)\n            && !window->HasRealNamedProperty(keyString)\n            && name != nameOfProtoProperty)\n             return true;\n     }\n    return BindingSecurity::shouldAllowAccessToFrame(target, DoNotReportSecurityError);\n}", "target": 0}
{"code": "void gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}", "target": 0}
{"code": "static void smbd_deferred_open_timer(struct event_context *ev,\n\t\t\t\t     struct timed_event *te,\n\t\t\t\t     struct timeval _tval,\n\t\t\t\t     void *private_data)\n{\n\tstruct pending_message_list *msg = talloc_get_type(private_data,\n\t\t\t\t\t   struct pending_message_list);\n\tTALLOC_CTX *mem_ctx = talloc_tos();\n\tuint16_t mid = SVAL(msg->buf.data,smb_mid);\n\tuint8_t *inbuf;\n\tinbuf = (uint8_t *)talloc_memdup(mem_ctx, msg->buf.data,\n\t\t\t\t\t msg->buf.length);\n\tif (inbuf == NULL) {\n\t\texit_server(\"smbd_deferred_open_timer: talloc failed\\n\");\n\t\treturn;\n\t}\n\tDEBUG(5,(\"smbd_deferred_open_timer: trigger mid %u.\\n\",\n\t\t(unsigned int)mid ));\n\tmsg->processed = true;\n\tprocess_smb(smbd_server_conn, inbuf,\n\t\t    msg->buf.length, 0,\n\t\t    msg->seqnum, msg->encrypted, &msg->pcd);\n\tmsg = get_open_deferred_message(mid);\n\tif (msg && msg->processed) {\n\t\tremove_deferred_open_smb_message(mid);\n\t}\n}", "target": 0}
{"code": "    Exifdatum& Exifdatum::operator=(const Rational& value)\n    {\n        return Exiv2::setValue(*this, value);\n    }", "target": 0}
{"code": "static inline void loaded_vmcs_init(struct loaded_vmcs *loaded_vmcs)\n{\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}", "target": 0}
{"code": "APE::Properties::Properties(File *file, ReadStyle style) : AudioProperties(style)\n{\n  d = new PropertiesPrivate(file, file->length());\n  read();\n}", "target": 0}
{"code": "PHP_FUNCTION(ceil) \n{\n\tzval **value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &value) == FAILURE) {\n\t\treturn;\n\t}\n\tconvert_scalar_to_number_ex(value);\n\tif (Z_TYPE_PP(value) == IS_DOUBLE) {\n\t\tRETURN_DOUBLE(ceil(Z_DVAL_PP(value)));\n\t} else if (Z_TYPE_PP(value) == IS_LONG) {\n\t\tconvert_to_double_ex(value);\n\t\tRETURN_DOUBLE(Z_DVAL_PP(value));\n\t}\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static int coroutine_fn bdrv_mirror_top_flush(BlockDriverState *bs)\n{\n    if (bs->backing == NULL) {\n        return 0;\n    }\n    return bdrv_co_flush(bs->backing->bs);\n}", "target": 0}
{"code": "GF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "int blk_rq_unmap_user(struct bio *bio)\n{\n\tstruct bio *next_bio;\n\tint ret = 0, ret2;\n\twhile (bio) {\n\t\tif (bio->bi_private) {\n\t\t\tret2 = bio_uncopy_user(bio);\n\t\t\tif (ret2 && !ret)\n\t\t\t\tret = ret2;\n\t\t} else {\n\t\t\tbio_release_pages(bio, bio_data_dir(bio) == READ);\n\t\t}\n\t\tnext_bio = bio;\n\t\tbio = bio->bi_next;\n\t\tbio_put(next_bio);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "vte_sequence_handler_fs (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->status_line = FALSE;\n}", "target": 0}
{"code": "fbFetch_b8g8r8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = 0xff000000;\n#if IMAGE_BYTE_ORDER == MSBFirst\n        b |= (READ(pixel++));\n        b |= (READ(pixel++) << 8);\n        b |= (READ(pixel++) << 16);\n#else\n        b |= (READ(pixel++) << 16);\n        b |= (READ(pixel++) << 8);\n        b |= (READ(pixel++));\n#endif\n    }\n}", "target": 0}
{"code": "    CImgList<T>& remove(const unsigned int pos1, const unsigned int pos2) {\n      const unsigned int\n        npos1 = pos1<pos2?pos1:pos2,\n        tpos2 = pos1<pos2?pos2:pos1,\n        npos2 = tpos2<_width?tpos2:_width - 1;\n      if (npos1>=_width)\n        throw CImgArgumentException(_cimglist_instance\n                                    \"remove(): Invalid remove request at positions %u->%u.\",\n                                    cimglist_instance,\n                                    npos1,tpos2);\n      else {\n        if (tpos2>=_width)\n          throw CImgArgumentException(_cimglist_instance\n                                      \"remove(): Invalid remove request at positions %u->%u.\",\n                                      cimglist_instance,\n                                      npos1,tpos2);\n        for (unsigned int k = npos1; k<=npos2; ++k) _data[k].assign();\n        const unsigned int nb = 1 + npos2 - npos1;\n        if (!(_width-=nb)) return assign();\n        if (_width>(_allocated_width>>2) || _allocated_width<=16) { \n          if (npos1!=_width) std::memmove(_data + npos1,_data + npos2 + 1,sizeof(CImg<T>)*(_width - npos1));\n          std::memset(_data + _width,0,sizeof(CImg<T>)*nb);\n        } else { \n          _allocated_width>>=2;\n          while (_allocated_width>16 && _width<(_allocated_width>>1)) _allocated_width>>=1;\n          CImg<T> *const new_data = new CImg<T>[_allocated_width];\n          if (npos1) std::memcpy(new_data,_data,sizeof(CImg<T>)*npos1);\n          if (npos1!=_width) std::memcpy(new_data + npos1,_data + npos2 + 1,sizeof(CImg<T>)*(_width - npos1));\n          if (_width!=_allocated_width) std::memset(new_data + _width,0,sizeof(CImg<T>)*(_allocated_width - _width));\n          std::memset(_data,0,sizeof(CImg<T>)*(_width + nb));\n          delete[] _data;\n          _data = new_data;", "target": 0}
{"code": "void NetworkScreen::ClearErrors() {\n  if (bubble_)\n    bubble_->Close();\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}", "target": 0}
{"code": "  Parser Parser::from_c_str(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source, bool allow_parent)\n  {\n    pstate.offset.column = 0;\n    pstate.offset.line = 0;\n    Parser p(ctx, pstate, traces, allow_parent);\n    p.source   = source ? source : beg;\n    p.position = beg ? beg : p.source;\n    p.end      = p.position + strlen(p.position);\n    Block_Obj root = SASS_MEMORY_NEW(Block, pstate);\n    p.block_stack.push_back(root);\n    root->is_root(true);\n    return p;\n  }", "target": 0}
{"code": "    **/\n    CImg<T> rotate(const float u, const float v, const float w, const float angle,\n                   const float cx, const float cy, const float cz,\n                   const unsigned int interpolation=1, const unsigned int boundary_conditions=0) {\n      const float nangle = cimg::mod(angle,360.0f);\n      if (nangle==0.0f) return *this;\n      return get_rotate(u,v,w,nangle,cx,cy,cz,interpolation,boundary_conditions).move_to(*this);", "target": 0}
{"code": "bool Shell::HasInstance() {\n  return !!instance_;\n}", "target": 0}
{"code": "static int copy_reference_state(struct bpf_func_state *dst, const struct bpf_func_state *src)\n{\n\tdst->refs = copy_array(dst->refs, src->refs, src->acquired_refs,\n\t\t\t       sizeof(struct bpf_reference_state), GFP_KERNEL);\n\tif (!dst->refs)\n\t\treturn -ENOMEM;\n\tdst->acquired_refs = src->acquired_refs;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)\n{\n\tskb->queue_mapping = queue_mapping;\n}", "target": 0}
{"code": "static ssize_t xps_cpus_store(struct netdev_queue *queue,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct net_device *dev = queue->dev;\n\tunsigned long index;\n\tcpumask_var_t mask;\n\tint err;\n\tif (!netif_is_multiqueue(dev))\n\t\treturn -ENOENT;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tindex = get_netdev_queue_index(queue);\n\terr = bitmap_parse(buf, len, cpumask_bits(mask), nr_cpumask_bits);\n\tif (err) {\n\t\tfree_cpumask_var(mask);\n\t\treturn err;\n\t}\n\terr = netif_set_xps_queue(dev, mask, index);\n\tfree_cpumask_var(mask);\n\treturn err ? : len;", "target": 0}
{"code": "void task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tunsigned long data, text, lib, swap;\n\tunsigned long hiwater_vm, total_vm, hiwater_rss, total_rss;\n\thiwater_vm = total_vm = mm->total_vm;\n\tif (hiwater_vm < mm->hiwater_vm)\n\t\thiwater_vm = mm->hiwater_vm;\n\thiwater_rss = total_rss = get_mm_rss(mm);\n\tif (hiwater_rss < mm->hiwater_rss)\n\t\thiwater_rss = mm->hiwater_rss;\n\tdata = mm->total_vm - mm->shared_vm - mm->stack_vm;\n\ttext = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;\n\tlib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;\n\tswap = get_mm_counter(mm, MM_SWAPENTS);\n\tseq_printf(m,\n\t\t\"VmPeak:\\t%8lu kB\\n\"\n\t\t\"VmSize:\\t%8lu kB\\n\"\n\t\t\"VmLck:\\t%8lu kB\\n\"\n\t\t\"VmHWM:\\t%8lu kB\\n\"\n\t\t\"VmRSS:\\t%8lu kB\\n\"\n\t\t\"VmData:\\t%8lu kB\\n\"\n\t\t\"VmStk:\\t%8lu kB\\n\"\n\t\t\"VmExe:\\t%8lu kB\\n\"\n\t\t\"VmLib:\\t%8lu kB\\n\"\n\t\t\"VmPTE:\\t%8lu kB\\n\"\n\t\t\"VmSwap:\\t%8lu kB\\n\",\n\t\thiwater_vm << (PAGE_SHIFT-10),\n\t\t(total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),\n\t\tmm->locked_vm << (PAGE_SHIFT-10),\n\t\thiwater_rss << (PAGE_SHIFT-10),\n\t\ttotal_rss << (PAGE_SHIFT-10),\n\t\tdata << (PAGE_SHIFT-10),\n\t\tmm->stack_vm << (PAGE_SHIFT-10), text, lib,\n\t\t(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10,\n\t\tswap << (PAGE_SHIFT-10));\n}", "target": 0}
{"code": "static int NAttrFlag(ntfs_attr *na, FILE_ATTR_FLAGS flag)\n{\n\tif (na->type == AT_DATA && na->name == AT_UNNAMED)\n\t\treturn (na->ni->flags & flag);\n\treturn 0;\n}", "target": 0}
{"code": "    PreviewProperties LoaderExifDataJpeg::getProperties() const\n    {\n        PreviewProperties prop = Loader::getProperties();\n        prop.mimeType_ = \"image/jpeg\";\n        prop.extension_ = \".jpg\";\n#ifdef EXV_UNICODE_PATH\n        prop.wextension_ = EXV_WIDEN(\".jpg\");\n#endif\n        return prop;\n    }", "target": 0}
{"code": "static int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}", "target": 0}
{"code": "void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {\n  switch (loader_type) {\n  case ClassLoader::BOOT_LOADER:\n    _misc_flags |= _misc_is_shared_boot_class;\n    break;\n  case ClassLoader::PLATFORM_LOADER:\n    _misc_flags |= _misc_is_shared_platform_class;\n    break;\n  case ClassLoader::APP_LOADER:\n    _misc_flags |= _misc_is_shared_app_class;\n    break;\n  default:\n    ShouldNotReachHere();\n    break;\n  }\n}", "target": 0}
{"code": "MagickExport const char *GetPixelCacheFilename(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->cache_filename);\n}", "target": 0}
{"code": "static uint nr_of_decimals(const char *str, const char *end)\n{\n  const char *decimal_point;\n  for (;;)\n  {\n    if (str == end)\n      return 0;\n    if (*str == 'e' || *str == 'E')\n      return NOT_FIXED_DEC;    \n    if (*str++ == '.')\n      break;\n  }\n  decimal_point= str;\n  for ( ; str < end && my_isdigit(system_charset_info, *str) ; str++)\n    ;\n  if (str < end && (*str == 'e' || *str == 'E'))\n    return NOT_FIXED_DEC;\n  return (uint) (str - decimal_point);\n}", "target": 0}
{"code": "static void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n  ExceptionInfo\n    *exception;\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent-2,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  message[MagickPathExtent-2]='\\0';\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}", "target": 0}
{"code": "struct tipc_crypto *tipc_node_crypto_rx_by_addr(struct net *net, u32 addr)\n{\n\tstruct tipc_node *n;\n\tn = tipc_node_find(net, addr);\n\treturn (n) ? n->crypto_rx : NULL;\n}", "target": 0}
{"code": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn whichfork != XFS_COW_FORK &&\n\t\tXFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}", "target": 0}
{"code": "void _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn 1ULL << 20;\n\tif (period == 0)\n\t\treturn 0;\n\treturn div64_u64(runtime << 20, period);\n}", "target": 0}
{"code": "Opal::Call::get_id () const\n{\n  return GetToken ();\n}", "target": 0}
{"code": "TEST(HeaderDataConstructorTest, ExactMatchSpecifier) {\n  const std::string yaml = R\"EOF(\nname: test-header\nexact_match: value\n  )EOF\";\n  HeaderUtility::HeaderData header_data =\n      HeaderUtility::HeaderData(parseHeaderMatcherFromYaml(yaml));\n  EXPECT_EQ(\"test-header\", header_data.name_.get());\n  EXPECT_EQ(HeaderUtility::HeaderMatchType::Value, header_data.header_match_type_);\n  EXPECT_EQ(\"value\", header_data.value_);\n}", "target": 0}
{"code": "static void update_depend_map(JOIN *join)\n{\n  JOIN_TAB *join_tab;\n  for (join_tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITH_CONST_TABLES); \n       join_tab;\n       join_tab= next_linear_tab(join, join_tab, WITH_BUSH_ROOTS))\n  {\n    TABLE_REF *ref= &join_tab->ref;\n    table_map depend_map=0;\n    Item **item=ref->items;\n    uint i;\n    for (i=0 ; i < ref->key_parts ; i++,item++)\n      depend_map|=(*item)->used_tables();\n    depend_map&= ~OUTER_REF_TABLE_BIT;\n    ref->depend_map= depend_map;\n    for (JOIN_TAB **tab=join->map2table;\n         depend_map ;\n         tab++,depend_map>>=1 )\n    {\n      if (depend_map & 1)\n        ref->depend_map|=(*tab)->ref.depend_map;\n    }\n  }\n}", "target": 0}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "\tboost::int64_t lazy_entry::dict_find_int_value(char const* name, boost::int64_t default_val) const\n\t{\n\t\tlazy_entry const* e = dict_find(name);\n\t\tif (e == 0 || e->type() != lazy_entry::int_t) return default_val;\n\t\treturn e->int_value();\n\t}", "target": 0}
{"code": "queue_item (GQueue *queue,\n\t    guint type,\n\t    EmpathyMessage *msg,\n\t    const char *str)\n{\n\tQueuedItem *item = g_slice_new0 (QueuedItem);\n\titem->type = type;\n\tif (msg != NULL)\n\t\titem->msg = g_object_ref (msg);\n\titem->str = g_strdup (str);\n\tg_queue_push_tail (queue, item);\n\treturn item;\n}", "target": 0}
{"code": "    void set_enabled(bool enabled) {\n      enabled_ = enabled;\n    }", "target": 0}
{"code": "static bool display_is_local(const char *display) {\n        assert(display);\n        return\n                display[0] == ':' &&\n                display[1] >= '0' &&\n                display[1] <= '9';\n}", "target": 0}
{"code": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\tlock_map_release(&__fs_reclaim_map);\n}", "target": 0}
{"code": "uint32_t reds_qxl_ram_size(RedsState *reds)\n{\n    QXLInstance *first;\n    if (reds->qxl_instances.empty()) {\n        return 0;\n    }\n    first = *reds->qxl_instances.begin();\n    return red_qxl_get_ram_size(first);\n}", "target": 0}
{"code": "flatpak_run_setup_usr_links (FlatpakBwrap *bwrap,\n                             GFile        *runtime_files,\n                             const char   *sysroot)\n{\n  int i;\n  if (runtime_files == NULL)\n    return;\n  for (i = 0; flatpak_abs_usrmerged_dirs[i] != NULL; i++)\n    {\n      const char *subdir = flatpak_abs_usrmerged_dirs[i];\n      g_autoptr(GFile) runtime_subdir = NULL;\n      g_assert (subdir[0] == '/');\n      runtime_subdir = g_file_get_child (runtime_files, subdir + 1);\n      if (g_file_query_exists (runtime_subdir, NULL))\n        {\n          g_autofree char *link = g_strconcat (\"usr\", subdir, NULL);\n          g_autofree char *create = NULL;\n          if (sysroot != NULL)\n            create = g_strconcat (sysroot, subdir, NULL);\n          else\n            create = g_strdup (subdir);\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--symlink\", link, create,\n                                  NULL);\n        }\n      else\n        {\n          g_debug (\"%s does not exist\",\n                   flatpak_file_get_path_cached (runtime_subdir));\n        }\n    }\n}", "target": 0}
{"code": "    void PsdImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo);  \n        io_->close();\n        io_->transfer(*tempIo);  \n    }  ", "target": 0}
{"code": "static void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\n}", "target": 0}
{"code": "bool RenderViewImpl::didTapMultipleTargets(\n    const WebKit::WebGestureEvent& event,\n    const WebVector<WebRect>& target_rects) {\n  gfx::Rect finger_rect(\n      event.x - event.data.tap.width / 2, event.y - event.data.tap.height / 2,\n      event.data.tap.width, event.data.tap.height);\n  gfx::Rect zoom_rect;\n  float scale = DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(\n      finger_rect, target_rects, GetSize(), &zoom_rect);\n  if (!scale)\n    return false;\n  gfx::Size canvas_size = zoom_rect.size();\n  canvas_size = ToCeiledSize(gfx::ScaleSize(canvas_size, scale));\n  TransportDIB* transport_dib = NULL;\n  {\n    scoped_ptr<skia::PlatformCanvas> canvas(\n        RenderProcess::current()->GetDrawingCanvas(&transport_dib,\n                                                   gfx::Rect(canvas_size)));\n    if (!canvas.get())\n      return false;\n    canvas->scale(scale, scale);\n    canvas->translate(-zoom_rect.x(), -zoom_rect.y());\n    webwidget_->paint(webkit_glue::ToWebCanvas(canvas.get()), zoom_rect,\n        WebWidget::ForceSoftwareRenderingAndIgnoreGPUResidentContent);\n  }\n  Send(new ViewHostMsg_ShowDisambiguationPopup(routing_id_,\n                                               zoom_rect,\n                                               canvas_size,\n                                               transport_dib->id()));\n  return true;\n}", "target": 0}
{"code": "static size_t php_pgsql_fd_write(php_stream *stream, const char *buf, size_t count) \n{\n\treturn 0;\n} ", "target": 0}
{"code": "NCR_ModifyPolltarget(NCR_Instance inst, int new_poll_target)\n{\n  inst->poll_target = new_poll_target;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new polltarget %d\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_poll_target);\n}", "target": 0}
{"code": "static bool _bank_free_cb(void *user, void *data, ut32 id) {\n\tr_io_bank_free ((RIOBank *)data);\n\treturn true;\n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == 0xdf && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_4_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1; \n}", "target": 0}
{"code": "static bool torture_winbind_struct_getdcname(struct torture_context *torture)\n{\n\tbool ok;\n\tbool strict = torture_setting_bool(torture, \"strict mode\", false);\n\tconst char *domain_name = torture_setting_string(torture,\n\t\t\t\t\t\"winbindd_netbios_domain\",\n\t\t\t\t\tlpcfg_workgroup(torture->lp_ctx));\n\tstruct torture_trust_domain *listd = NULL;\n\tuint32_t i, count = 0;\n\ttorture_comment(torture, \"Running WINBINDD_GETDCNAME (struct based)\\n\");\n\tok = get_trusted_domains(torture, &listd);\n\ttorture_assert(torture, ok, \"failed to get trust list\");\n\tfor (i=0; listd && listd[i].netbios_name; i++) {\n\t\tstruct winbindd_request req;\n\t\tstruct winbindd_response rep;\n\t\tif (strequal(listd[i].netbios_name, \"BUILTIN\") ||\n\t\t    strequal(listd[i].netbios_name, domain_name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tZERO_STRUCT(req);\n\t\tZERO_STRUCT(rep);\n\t\tfstrcpy(req.domain_name, listd[i].netbios_name);\n\t\tok = true;\n\t\tDO_STRUCT_REQ_REP_EXT(WINBINDD_GETDCNAME, &req, &rep,\n\t\t\t\t      NSS_STATUS_SUCCESS,\n\t\t\t\t      (i <2 || strict), ok = false,\n\t\t\t\t      talloc_asprintf(torture, \"DOMAIN '%s'\",\n\t\t\t\t      \t\t      req.domain_name));\n\t\tif (!ok) continue;\n\t\ttorture_comment(torture, \"DOMAIN '%s' => DCNAME '%s'\\n\",\n\t\t\t\treq.domain_name, rep.data.dc_name);\n\t\tcount++;\n\t}\n\tif (strict) {\n\t\ttorture_assert(torture, count > 0,\n\t\t\t       \"WiNBINDD_GETDCNAME was not tested\");\n\t}\n\treturn true;\n}", "target": 0}
{"code": "rsrc_cmp_node(const struct archive_rb_node *n1,\n    const struct archive_rb_node *n2)\n{\n\tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n\tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n\treturn (strcmp(e2->rsrcname.s, e1->rsrcname.s));\n}", "target": 0}
{"code": "PassRefPtrWillBeRawPtr<Node> ContainerNode::appendChild(PassRefPtrWillBeRawPtr<Node> newChild, ExceptionState& exceptionState)\n{\n    RefPtrWillBeRawPtr<ContainerNode> protect(this);\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n    if (!checkAcceptChild(newChild.get(), 0, exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return newChild;\n    }\n    ASSERT(newChild);\n    if (newChild == m_lastChild) \n        return newChild;\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(*newChild, targets, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n    if (targets.isEmpty())\n        return newChild;\n    if (!checkAcceptChildGuaranteedNodeTypes(*newChild, nullptr, exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return newChild;\n    }\n    InspectorInstrumentation::willInsertDOMNode(this);\n    ChildListMutationScope mutation(*this);\n    for (const auto& targetNode : targets) {\n        ASSERT(targetNode);\n        Node& child = *targetNode;\n        if (child.parentNode())\n            break;\n        {\n            EventDispatchForbiddenScope assertNoEventDispatch;\n            ScriptForbiddenScope forbidScript;\n            treeScope().adoptIfNeeded(child);\n            appendChildCommon(child);\n        }\n        updateTreeAfterInsertion(child);\n    }\n    dispatchSubtreeModifiedEvent();\n    return newChild;\n}", "target": 0}
{"code": "static int verify_chunk_dev_extent_mapping(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tread_lock(&em_tree->lock);\n\tfor (node = rb_first_cached(&em_tree->map); node; node = rb_next(node)) {\n\t\tem = rb_entry(node, struct extent_map, rb_node);\n\t\tif (em->map_lookup->num_stripes !=\n\t\t    em->map_lookup->verified_stripes) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"chunk %llu has missing dev extent, have %d expect %d\",\n\t\t\t\t  em->start, em->map_lookup->verified_stripes,\n\t\t\t\t  em->map_lookup->num_stripes);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tread_unlock(&em_tree->lock);\n\treturn ret;\n}", "target": 0}
{"code": "virSecuritySELinuxSetUSBLabel(virUSBDevice *dev G_GNUC_UNUSED,\n                              const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}", "target": 0}
{"code": "static void vnc_qmp_event(VncState *vs, QAPIEvent event)\n{\n    VncServerInfo *si;\n    if (!vs->info) {\n        return;\n    }\n    si = vnc_server_info_get(vs->vd);\n    if (!si) {\n        return;\n    }\n    switch (event) {\n    case QAPI_EVENT_VNC_CONNECTED:\n        qapi_event_send_vnc_connected(si, qapi_VncClientInfo_base(vs->info));\n        break;\n    case QAPI_EVENT_VNC_INITIALIZED:\n        qapi_event_send_vnc_initialized(si, vs->info);\n        break;\n    case QAPI_EVENT_VNC_DISCONNECTED:\n        qapi_event_send_vnc_disconnected(si, vs->info);\n        break;\n    default:\n        break;\n    }\n    qapi_free_VncServerInfo(si);\n}", "target": 0}
{"code": "MagickExport MagickSizeType GetImageExtent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetPixelCacheNexusExtent(cache_info,cache_info->nexus_info[id]));\n}", "target": 0}
{"code": "void RenderView::exitFullscreenForNode(const WebKit::WebNode& node) {\n  NOTIMPLEMENTED();\n}", "target": 0}
{"code": "lexer_scan_private_identifier (parser_context_t *context_p) \n{\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  return (context_p->source_p < context_p->source_end_p && lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS));\n} ", "target": 0}
{"code": "irc_server_switch_address (struct t_irc_server *server, int connection)\n{\n    if (server->addresses_count > 1)\n    {\n        irc_server_set_index_current_address (\n            server,\n            (server->index_current_address + 1) % server->addresses_count);\n        weechat_printf (\n            server->buffer,\n            _(\"%s%s: switching address to %s/%d\"),\n            weechat_prefix (\"network\"),\n            IRC_PLUGIN_NAME,\n            server->current_address,\n            server->current_port);\n        if (connection)\n        {\n            if (server->index_current_address == 0)\n                irc_server_reconnect_schedule (server);\n            else\n                irc_server_connect (server);\n        }\n    }\n    else\n    {\n        if (connection)\n            irc_server_reconnect_schedule (server);\n    }\n}", "target": 0}
{"code": "SPL_METHOD(SplObjectStorage, contains)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_object_storage_contains(intern, getThis(), obj TSRMLS_CC));\n} ", "target": 0}
{"code": "ref_param_write_typed_array(gs_param_list * plist, gs_param_name pkey,\n                            void *pvalue, uint count,\n                            int (*make)(ref *, const void *, uint,\n                                        gs_ref_memory_t *))\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    ref value;\n    uint i;\n    ref *pe;\n    int code;\n    if ((code = ref_array_param_requested(iplist, pkey, &value, count,\n                                       \"ref_param_write_typed_array\")) <= 0)\n        return code;\n    for (i = 0, pe = value.value.refs; i < count; ++i, ++pe)\n        if ((code = (*make) (pe, pvalue, i, iplist->ref_memory)) < 0)\n            return code;\n    return ref_param_write(iplist, pkey, &value);\n}", "target": 0}
{"code": "static struct key *request_user_key(const char *master_desc, u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tstruct user_key_payload *upayload;\n\tstruct key *ukey;\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\tdown_read(&ukey->sem);\n\tupayload = ukey->payload.data;\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}", "target": 0}
{"code": "objArrayOop InstanceKlass::allocate_objArray(int n, int length, TRAPS) {\n  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n  int size = objArrayOopDesc::object_size(length);\n  Klass* ak = array_klass(n, CHECK_NULL);\n  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n                                                                 true, CHECK_NULL);\n  return o;\n}", "target": 0}
{"code": "deref_function_name(\n\t    char_u\t**arg,\n\t    char_u\t**tofree,\n\t    evalarg_T\t*evalarg,\n\t    int\t\tverbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n    ref.v_type = VAR_UNKNOWN;\n    if (eval7(arg, &ref, evalarg, FALSE) == FAIL)\n    {\n\tdictitem_T\t*v;\n\tv = find_var_also_in_script(name, NULL, FALSE);\n\tif (v == NULL)\n\t    return NULL;\n\tcopy_tv(&v->di_tv, &ref);\n    }\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}", "target": 0}
{"code": "xfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\treturn __xfs_inode_free_quota_eofblocks(ip, xfs_icache_free_eofblocks);\n}", "target": 0}
{"code": "util_curl_unsetopt(CurlObject *self, int option)\n{\n    int res;\n#define SETOPT2(o,x) \\\n    if ((res = curl_easy_setopt(self->handle, (o), (x))) != CURLE_OK) goto error\n#define SETOPT(x)   SETOPT2((CURLoption)option, (x))\n    switch (option)\n    {\n    case CURLOPT_SHARE:\n        SETOPT((CURLSH *) NULL);\n        Py_XDECREF(self->share);\n        self->share = NULL;\n        break;\n    case CURLOPT_HTTPPOST:\n        SETOPT((void *) 0);\n        curl_formfree(self->httppost);\n        util_curl_xdecref(self, PYCURL_MEMGROUP_HTTPPOST, self->handle);\n        self->httppost = NULL;\n        break;\n    case CURLOPT_INFILESIZE:\n        SETOPT((long) -1);\n        break;\n    case CURLOPT_WRITEHEADER:\n        SETOPT((void *) 0);\n        Py_CLEAR(self->writeheader_fp);\n        break;\n    case CURLOPT_CAINFO:\n    case CURLOPT_CAPATH:\n    case CURLOPT_COOKIE:\n    case CURLOPT_COOKIEJAR:\n    case CURLOPT_CUSTOMREQUEST:\n    case CURLOPT_EGDSOCKET:\n    case CURLOPT_FTPPORT:\n    case CURLOPT_PROXYUSERPWD:\n#ifdef HAVE_CURLOPT_PROXYUSERNAME\n    case CURLOPT_PROXYUSERNAME:\n    case CURLOPT_PROXYPASSWORD:\n#endif\n    case CURLOPT_RANDOM_FILE:\n    case CURLOPT_SSL_CIPHER_LIST:\n    case CURLOPT_USERPWD:\n#ifdef HAVE_CURLOPT_USERNAME\n    case CURLOPT_USERNAME:\n    case CURLOPT_PASSWORD:\n#endif\n    case CURLOPT_RANGE:\n#if LIBCURL_VERSION_NUM >= 0x072b00 \n    case CURLOPT_SERVICE_NAME:\n    case CURLOPT_PROXY_SERVICE_NAME:\n#endif\n        SETOPT((char *) 0);\n        break;\n#ifdef HAVE_CURLOPT_CERTINFO\n    case CURLOPT_CERTINFO:\n        SETOPT((long) 0);\n        break;\n#endif\n    case CURLOPT_COOKIEFILE:\n    default:\n        PyErr_SetString(PyExc_TypeError, \"unsetopt() is not supported for this option\");\n        return NULL;\n    }\n    Py_RETURN_NONE;\nerror:\n    CURLERROR_RETVAL();\n#undef SETOPT\n#undef SETOPT2\n}", "target": 0}
{"code": "void gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color)\n{\n\tif ((s % 360) == (e % 360)) {\n\t\tgdImageEllipse(im, cx, cy, w, h, color);\n\t} else {\n\t\tgdImageFilledArc(im, cx, cy, w, h, s, e, color, gdNoFill);\n\t}\n}", "target": 0}
{"code": "ZEND_API void object_properties_init(zend_object *object, zend_class_entry *class_type) \n{\n\tint i;\n\tif (class_type->default_properties_count) {\n\t\tobject->properties_table = emalloc(sizeof(zval*) * class_type->default_properties_count);\n\t\tfor (i = 0; i < class_type->default_properties_count; i++) {\n\t\t\tobject->properties_table[i] = class_type->default_properties_table[i];\n\t\t\tif (class_type->default_properties_table[i]) {\n#if ZTS\n\t\t\t\tALLOC_ZVAL( object->properties_table[i]);\n\t\t\t\tMAKE_COPY_ZVAL(&class_type->default_properties_table[i], object->properties_table[i]);\n#else\n\t\t\t\tZ_ADDREF_P(object->properties_table[i]);\n#endif\n\t\t\t}\n\t\t}\n\t\tobject->properties = NULL;\n\t}\n}", "target": 0}
{"code": "void RenderViewTest::SendInputEvent(const blink::WebInputEvent& input_event) {\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->OnMessageReceived(InputMsg_HandleInputEvent(\n      0, &input_event, std::vector<const WebInputEvent*>(), ui::LatencyInfo(),\n      InputEventDispatchType::DISPATCH_TYPE_BLOCKING));\n}", "target": 0}
{"code": "Item::remove_eq_conds(THD *thd, Item::cond_result *cond_value, bool top_level_arg)\n{\n  if (const_item() && !is_expensive())\n  {\n    *cond_value= eval_const_cond() ? Item::COND_TRUE : Item::COND_FALSE;\n    return (COND*) 0;\n  }\n  *cond_value= Item::COND_OK;\n  return this;                                        \n}", "target": 0}
{"code": "set_up_outpe(context *ctx, int fd, Pe *inpe, Pe **outpe)\n{\n\tsize_t size;\n\tchar *addr;\n\taddr = pe_rawfile(inpe, &size);\n\toff_t offset = lseek(fd, 0, SEEK_SET);\n\tif (offset < 0) {\n\t\tctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,\n\t\t\t\"could not read output file: %m\");\n\t\treturn -1;\n\t}\n\tint rc = ftruncate(fd, size);\n\tif (rc < 0) {\n\t\tctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,\n\t\t\t\"could not extend output file: %m\");\n\t\treturn -1;\n\t}\n\trc = write(fd, addr, size);\n\tif (rc < 0) {\n\t\tctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,\n\t\t\t\"could not write to output file: %m\");\n\t\treturn -1;\n\t}\n\t*outpe = pe_begin(fd, PE_C_RDWR_MMAP, NULL);\n\tif (!*outpe)\n\t\t*outpe = pe_begin(fd, PE_C_RDWR, NULL);\n\tif (!*outpe) {\n\t\tctx->cms->log(ctx->cms, ctx->priority|LOG_ERR,\n\t\t\t\"could not set up output: %s\",\n\t\t\tpe_errmsg(pe_errno()));\n\t\treturn -1;\n\t}\n\tpe_clearcert(*outpe);\n\treturn 0;\n}", "target": 0}
{"code": "IIRFilterNode* BaseAudioContext::createIIRFilter(\n    Vector<double> feedforward_coef,\n    Vector<double> feedback_coef,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return IIRFilterNode::Create(*this, feedforward_coef, feedback_coef,\n                               exception_state);\n}", "target": 0}
{"code": "static int packet_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po;\n\tstruct packet_fanout *f;\n\tstruct net *net;\n\tunion tpacket_req_u req_u;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tpo = pkt_sk(sk);\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&net->packet.sklist_lock);\n\tpreempt_disable();\n\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\tpreempt_enable();\n\tspin_lock(&po->bind_lock);\n\tunregister_prot_hook(sk, false);\n\tpacket_cached_dev_reset(po);\n\tif (po->prot_hook.dev) {\n\t\tdev_put(po->prot_hook.dev);\n\t\tpo->prot_hook.dev = NULL;\n\t}\n\tspin_unlock(&po->bind_lock);\n\tpacket_flush_mclist(sk);\n\tif (po->rx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 0);\n\t}\n\tif (po->tx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 1);\n\t}\n\tf = fanout_release(sk);\n\tsynchronize_net();\n\tif (f) {\n\t\tkfree(po->rollover);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tpacket_free_pending(po);\n\tsk_refcnt_debug_release(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 0}
{"code": "BGD_DECLARE(int) gdImageGetTrueColorPixel (gdImagePtr im, int x, int y)\n{\n\tint p = gdImageGetPixel (im, x, y);\n\tif (!im->trueColor) {\n\t\treturn gdTrueColorAlpha (im->red[p], im->green[p], im->blue[p],\n\t\t                         (im->transparent == p) ? gdAlphaTransparent :\n\t\t                         im->alpha[p]);\n\t} else {\n\t\treturn p;\n\t}\n}", "target": 0}
{"code": "static void *__slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, void *addr, struct kmem_cache_cpu *c)\n{\n\tvoid **object;\n\tstruct page *new;\n\tgfpflags &= ~__GFP_ZERO;\n\tif (!c->page)\n\t\tgoto new_slab;\n\tslab_lock(c->page);\n\tif (unlikely(!node_match(c, node)))\n\t\tgoto another_slab;\n\tstat(c, ALLOC_REFILL);\nload_freelist:\n\tobject = c->page->freelist;\n\tif (unlikely(!object))\n\t\tgoto another_slab;\n\tif (unlikely(SlabDebug(c->page)))\n\t\tgoto debug;\n\tc->freelist = object[c->offset];\n\tc->page->inuse = c->page->objects;\n\tc->page->freelist = NULL;\n\tc->node = page_to_nid(c->page);\nunlock_out:\n\tslab_unlock(c->page);\n\tstat(c, ALLOC_SLOWPATH);\n\treturn object;\nanother_slab:\n\tdeactivate_slab(s, c);\nnew_slab:\n\tnew = get_partial(s, gfpflags, node);\n\tif (new) {\n\t\tc->page = new;\n\t\tstat(c, ALLOC_FROM_PARTIAL);\n\t\tgoto load_freelist;\n\t}\n\tif (gfpflags & __GFP_WAIT)\n\t\tlocal_irq_enable();\n\tnew = new_slab(s, gfpflags, node);\n\tif (gfpflags & __GFP_WAIT)\n\t\tlocal_irq_disable();\n\tif (new) {\n\t\tc = get_cpu_slab(s, smp_processor_id());\n\t\tstat(c, ALLOC_SLAB);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\t\tslab_lock(new);\n\t\tSetSlabFrozen(new);\n\t\tc->page = new;\n\t\tgoto load_freelist;\n\t}\n\treturn NULL;\ndebug:\n\tif (!alloc_debug_processing(s, c->page, object, addr))\n\t\tgoto another_slab;\n\tc->page->inuse++;\n\tc->page->freelist = object[c->offset];\n\tc->node = -1;\n\tgoto unlock_out;\n}", "target": 0}
{"code": "void __init key_init(void)\n{\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}", "target": 0}
{"code": "njs_string_prototype_from_bytes(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    u_char             *p, *s, *start, *end;\n    size_t             size;\n    njs_int_t          ret;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n    njs_deprecated(vm, \"String.prototype.fromBytes()\");\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_string_slice_prop(vm, &string, &slice, args, nargs);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    if (string.length != 0) {\n        return njs_string_slice(vm, &vm->retval, &string, &slice);\n    }\n    size = 0;\n    string.start += slice.start;\n    end = string.start + slice.length;\n    for (p = string.start; p < end; p++) {\n        size += (*p < 0x80) ? 1 : 2;\n    }\n    start = njs_string_alloc(vm, &vm->retval, size, slice.length);\n    if (njs_fast_path(start != NULL)) {\n        if (size == slice.length) {\n            memcpy(start, string.start, size);\n        } else {\n            s = start;\n            end = string.start + slice.length;\n            for (p = string.start; p < end; p++) {\n                s = njs_utf8_encode(s, *p);\n            }\n        }\n        return NJS_OK;\n    }\n    return NJS_ERROR;\n}", "target": 0}
{"code": "void NetworkActionPredictor::Shutdown() {\n  db_->OnPredictorDestroyed();\n}", "target": 0}
{"code": "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)\n{\n\tif ((unsigned)size <= sysctl_optmem_max &&\n\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {\n\t\tvoid *mem;\n\t\tatomic_add(size, &sk->sk_omem_alloc);\n\t\tmem = kmalloc(size, priority);\n\t\tif (mem)\n\t\t\treturn mem;\n\t\tatomic_sub(size, &sk->sk_omem_alloc);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor) {\n\t\treturn;\n\t}\n\tif (from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t};\n\tfor (y = 0; y < (to->sy); y++) {\n\t\tfor (x = 0; x < (to->sx); x++) {\n\t\t\tp = to->pixels[y][x];\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] =\n\t\t\t\t    gdImageColorClosestAlpha (from, to->red[p], to->green[p],\n\t\t\t\t                              to->blue[p], to->alpha[p]);\n\t\t\t};\n\t\t\tto->pixels[y][x] = xlate[p];\n\t\t};\n\t};\n\tfor (i = 0; (i < (from->colorsTotal)); i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t};\n\tfor (i = from->colorsTotal; (i < to->colorsTotal); i++) {\n\t\tto->open[i] = 1;\n\t};\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "GF_Err gf_fs_get_filter_stats(GF_FilterSession *session, u32 idx, GF_FilterStats *stats)\n{\n\tif (!stats || !session) return GF_BAD_PARAM;\n\treturn gf_filter_get_stats(gf_list_get(session->filters, idx), stats);\n}", "target": 0}
{"code": "blkid_loff_t blkid_partition_get_start(blkid_partition par)\n{\n\treturn (blkid_loff_t)par->start;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, InCantUseHashedIndexWithRegex) {\n    addIndex(BSON(\"a\"\n                  << \"hashed\"));\n    runQuery(fromjson(\"{a: {$in: [/abc/]}}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n}", "target": 0}
{"code": "static inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;", "target": 0}
{"code": "bool RenderViewTest::ExecuteJavaScriptAndReturnIntValue(\n    const base::string16& script,\n    int* int_result) {\n  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());\n  v8::Local<v8::Value> result = GetMainFrame()->ExecuteScriptAndReturnValue(\n      WebScriptSource(blink::WebString::FromUTF16(script)));\n  if (result.IsEmpty() || !result->IsInt32())\n    return false;\n  if (int_result)\n    *int_result = result->Int32Value();\n  return true;\n}", "target": 0}
{"code": "HttpStateData::httpTimeout(const CommTimeoutCbParams &)\n{\n    debugs(11, 4, serverConnection << \": '\" << entry->url() << \"'\");\n    if (entry->store_status == STORE_PENDING) {\n        fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, fwd->request));\n    }\n    closeServer();\n    mustStop(\"HttpStateData::httpTimeout\");\n}", "target": 0}
{"code": "bool IsElementAutocompletable(const blink::WebInputElement& element) {\n  return IsElementEditable(element);\n}", "target": 0}
{"code": "\tShared() : m_refCount(0)\n\t{\n\t}", "target": 0}
{"code": "static int decode_attr_maxfilesize(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXFILESIZE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXFILESIZE)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXFILESIZE;\n\t}\n\tdprintk(\"%s: maxfilesize=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "void ParamTraits<gfx::Point>::Log(const gfx::Point& p, std::string* l) {\n  l->append(base::StringPrintf(\"(%d, %d)\", p.x(), p.y()));\n}", "target": 0}
{"code": "XkbSendIndicatorMap(\tClientPtr\t\t\tclient,\n\t\t\tXkbIndicatorPtr\t\t\tindicators,\n\t\t\txkbGetIndicatorMapReply *\trep)\n{\nint \t\t\tlength;\nCARD8 *\t\t\tmap;\nregister int\t\ti;\nregister unsigned\tbit;\n    length = rep->length*4;\n    if (length>0) {\n\tCARD8 *to;\n\tto= map= (CARD8 *)xalloc(length);\n\tif (map) {\n\t    xkbIndicatorMapWireDesc  *wire = (xkbIndicatorMapWireDesc *)to;\n\t    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {\n\t\tif (rep->which&bit) {\n\t\t    wire->flags= indicators->maps[i].flags;\n\t\t    wire->whichGroups= indicators->maps[i].which_groups;\n\t\t    wire->groups= indicators->maps[i].groups;\n\t\t    wire->whichMods= indicators->maps[i].which_mods;\n\t\t    wire->mods= indicators->maps[i].mods.mask;\n\t\t    wire->realMods= indicators->maps[i].mods.real_mods;\n\t\t    wire->virtualMods= indicators->maps[i].mods.vmods;\n\t\t    wire->ctrls= indicators->maps[i].ctrls;\n\t\t    if (client->swapped) {\n\t\t\tregister int n;\n\t\t\tswaps(&wire->virtualMods,n);\n\t\t\tswapl(&wire->ctrls,n);\n\t\t    }\n\t\t    wire++;\n\t\t}\n\t    }\n\t    to = (CARD8 *)wire;\n\t    if ((to-map)!=length) {\n\t\tclient->errorValue = _XkbErrCode2(0xff,length);\n\t\treturn BadLength;\n\t    }\n\t}\n\telse return BadAlloc;\n    }\n    else map = NULL;\n    if (client->swapped) {\n\tswaps(&rep->sequenceNumber,i);\n\tswapl(&rep->length,i);\n\tswapl(&rep->which,i);\n\tswapl(&rep->realIndicators,i);\n    }\n    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), (char *)rep);\n    if (map) {\n\tWriteToClient(client, length, (char *)map);\n\txfree((char *)map);\n    }\n    return client->noClientException;\n}", "target": 0}
{"code": "static void red_sasl_handle_auth_mechname(void *opaque)\n{\n    RedSASLAuth *auth = (RedSASLAuth*) opaque;\n    auth->mechname[auth->len] = '\\0';\n    spice_debug(\"Got client mechname '%s' check against '%s'\",\n                auth->mechname, auth->mechlist);\n    char quoted_mechname[SASL_MAX_MECHNAME_LEN + 4];\n    sprintf(quoted_mechname, \",%s,\", auth->mechname);\n    if (strchr(auth->mechname, ',') || strstr(auth->mechlist, quoted_mechname) == NULL) {\n        return red_sasl_async_result(auth, RED_SASL_ERROR_INVALID_DATA);\n    }\n    spice_debug(\"Validated mechname '%s'\", auth->mechname);\n    red_stream_async_read(auth->stream, (uint8_t *)&auth->len, sizeof(uint32_t),\n                          red_sasl_handle_auth_steplen, auth);\n}", "target": 0}
{"code": "R_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}", "target": 0}
{"code": "void ExtensionPrefs::AddToExtensionPrefStringSet(\n    const std::string& extension_id,\n    const std::string& pref_key,\n    const std::set<std::string>& added_value) {\n  std::set<std::string> old_value;\n  std::set<std::string> new_value;\n  ReadExtensionPrefStringSet(extension_id, pref_key, &old_value);\n  std::set_union(old_value.begin(), old_value.end(),\n                 added_value.begin(), added_value.end(),\n                 std::inserter(new_value, new_value.begin()));\n  ListValue* value = new ListValue();\n  for (std::set<std::string>::const_iterator iter = new_value.begin();\n       iter != new_value.end(); ++iter)\n    value->Append(Value::CreateStringValue(*iter));\n  UpdateExtensionPref(extension_id, pref_key, value);\n}", "target": 0}
{"code": "void RGWPutObjRetention_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s);\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "static void red_sasl_handle_auth_steplen(void *opaque)\n{\n    RedSASLAuth *auth = (RedSASLAuth*) opaque;\n    auth->len = GUINT32_FROM_LE(auth->len);\n    uint32_t len = auth->len;\n    spice_debug(\"Got steplen %d\", len);\n    if (len > SASL_DATA_MAX_LEN) {\n        spice_warning(\"Too much SASL data %d\", len);\n        return red_sasl_async_result((RedSASLAuth*) opaque, auth->mechname ? RED_SASL_ERROR_INVALID_DATA : RED_SASL_ERROR_GENERIC);\n    }\n    auth->data = (char*) g_realloc(auth->data, len);\n    red_stream_async_read(auth->stream, (uint8_t *)auth->data, len,\n                          red_sasl_handle_auth_step, auth);\n}", "target": 0}
{"code": "match_subject(CERTCertificate *cert, void *cbdatap)\n{\n\tif (!cert->subjectName)\n\t\treturn 0;\n\tif (!strcmp(cert->subjectName, (char *)cbdatap))\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "const OSSL_PARAM *rc4_hmac_md5_settable_ctx_params(ossl_unused void *cctx,\n                                                   ossl_unused void *provctx)\n{\n    return rc4_hmac_md5_known_settable_ctx_params;\n}", "target": 0}
{"code": "static void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tp->cached_mount = seq_list_next(v, &p->ns->list, pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}", "target": 0}
{"code": "bool OverscrollControllerAndroid::WillHandleGestureEvent(\n    const blink::WebGestureEvent& event) {\n  if (!enabled_)\n    return false;\n  if (!refresh_effect_)\n    return false;\n  if (is_fullscreen_)\n    return false;\n  if (glow_effect_ && glow_effect_->IsActive()) {\n    if (glow_effect_->GetVisibleAlpha() > MinGlowAlphaToDisableRefresh())\n      return false;\n  }\n  bool handled = false;\n  switch (event.type) {\n    case blink::WebInputEvent::GestureScrollBegin:\n      refresh_effect_->OnScrollBegin();\n      break;\n    case blink::WebInputEvent::GestureScrollUpdate: {\n      gfx::Vector2dF scroll_delta(event.data.scrollUpdate.deltaX,\n                                  event.data.scrollUpdate.deltaY);\n      scroll_delta.Scale(dpi_scale_);\n      handled = refresh_effect_->WillHandleScrollUpdate(scroll_delta);\n    } break;\n    case blink::WebInputEvent::GestureScrollEnd:\n      refresh_effect_->OnScrollEnd(gfx::Vector2dF());\n      break;\n    case blink::WebInputEvent::GestureFlingStart: {\n      if (refresh_effect_->IsActive()) {\n        gfx::Vector2dF scroll_velocity(event.data.flingStart.velocityX,\n                                       event.data.flingStart.velocityY);\n        scroll_velocity.Scale(dpi_scale_);\n        refresh_effect_->OnScrollEnd(scroll_velocity);\n        blink::WebGestureEvent& modified_event =\n            const_cast<blink::WebGestureEvent&>(event);\n        modified_event.data.flingStart.velocityX = .01f;\n        modified_event.data.flingStart.velocityY = .01f;\n      }\n    } break;\n    case blink::WebInputEvent::GesturePinchBegin:\n      refresh_effect_->ReleaseWithoutActivation();\n      break;\n    default:\n      break;\n  }\n  return handled;\n}", "target": 0}
{"code": "static void _php_curl_close(zend_resource *rsrc)\n{\n\tphp_curl *ch = (php_curl *) rsrc->ptr;\n\t_php_curl_close_ex(ch);\n}", "target": 0}
{"code": "void WebContentsImpl::SystemDragEnded() {\n  if (GetRenderViewHost())\n    GetRenderViewHostImpl()->DragSourceSystemDragEnded();\n  if (delegate_)\n    delegate_->DragEnded();\n  if (browser_plugin_embedder_.get())\n    browser_plugin_embedder_->SystemDragEnded();\n}", "target": 0}
{"code": "ProcSetFontPath(ClientPtr client)\n{\n    unsigned char *ptr;\n    unsigned long nbytes, total;\n    long nfonts;\n    int n;\n    REQUEST(xSetFontPathReq);\n    REQUEST_AT_LEAST_SIZE(xSetFontPathReq);\n    nbytes = (client->req_len << 2) - sizeof(xSetFontPathReq);\n    total = nbytes;\n    ptr = (unsigned char *) &stuff[1];\n    nfonts = stuff->nFonts;\n    while (--nfonts >= 0) {\n        if ((total == 0) || (total < (n = (*ptr + 1))))\n            return BadLength;\n        total -= n;\n        ptr += n;\n    }\n    if (total >= 4)\n        return BadLength;\n    return SetFontPath(client, stuff->nFonts, (unsigned char *) &stuff[1]);\n}", "target": 0}
{"code": "  void GetGlobalUsage(StorageType type) {\n    type_ = kStorageTypeUnknown;\n    usage_ = -1;\n    unlimited_usage_ = -1;\n    quota_manager_->GetGlobalUsage(type,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::DidGetGlobalUsage));\n  }", "target": 0}
{"code": "void PngImg::Insert(const PngImg& img, png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    if(info_.pxlsize == img.info_.pxlsize) {\n        CopyRows_(img.rowPtrs_, img.info_.height, img.info_.rowbytes, offsetX, offsetY);\n    } else {\n        CopyPxlByPxl_(img, offsetX, offsetY);\n    }\n}", "target": 0}
{"code": "static void remove_inode_hugepages(struct inode *inode, loff_t lstart,\n\t\t\t\t   loff_t lend)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct address_space *mapping = &inode->i_data;\n\tconst pgoff_t start = lstart >> huge_page_shift(h);\n\tconst pgoff_t end = lend >> huge_page_shift(h);\n\tstruct vm_area_struct pseudo_vma;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i, freed = 0;\n\tlong lookup_nr = PAGEVEC_SIZE;\n\tbool truncate_op = (lend == LLONG_MAX);\n\tmemset(&pseudo_vma, 0, sizeof(struct vm_area_struct));\n\tpseudo_vma.vm_flags = (VM_HUGETLB | VM_MAYSHARE | VM_SHARED);\n\tpagevec_init(&pvec, 0);\n\tnext = start;\n\twhile (next < end) {\n\t\tif (end - next < lookup_nr)\n\t\t\tlookup_nr = end - next;\n\t\tif (!pagevec_lookup(&pvec, mapping, next, lookup_nr))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); ++i) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tu32 hash;\n\t\t\tnext = page->index;\n\t\t\tif (next >= end)\n\t\t\t\tbreak;\n\t\t\thash = hugetlb_fault_mutex_hash(h, current->mm,\n\t\t\t\t\t\t\t&pseudo_vma,\n\t\t\t\t\t\t\tmapping, next, 0);\n\t\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tlock_page(page);\n\t\t\tif (likely(!page_mapped(page))) {\n\t\t\t\tbool rsv_on_error = !PagePrivate(page);\n\t\t\t\tremove_huge_page(page);\n\t\t\t\tfreed++;\n\t\t\t\tif (!truncate_op) {\n\t\t\t\t\tif (unlikely(hugetlb_unreserve_pages(\n\t\t\t\t\t\t\tinode, next,\n\t\t\t\t\t\t\tnext + 1, 1)))\n\t\t\t\t\t\thugetlb_fix_reserve_counts(\n\t\t\t\t\t\t\tinode, rsv_on_error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tBUG_ON(truncate_op);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t}\n\t\t++next;\n\t\thuge_pagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (truncate_op)\n\t\t(void)hugetlb_unreserve_pages(inode, start, LONG_MAX, freed);\n}", "target": 0}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tif (!plen)\n\t\tfrom = NULL;\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tkvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void FrameLoader::finishedParsing()\n{\n    if (m_creatingInitialEmptyDocument)\n        return;\n    m_frame->injectUserScripts(InjectAtDocumentEnd);\n    RefPtr<Frame> protector = m_frame->view() ? m_frame : 0;\n    m_client->dispatchDidFinishDocumentLoad();\n    checkCompleted();\n    if (!m_frame->view())\n        return; \n    m_frame->view()->restoreScrollbar();\n    m_frame->view()->scrollToFragment(m_URL);\n}", "target": 0}
{"code": "static int sqfs_get_regfile_info(struct squashfs_reg_inode *reg,\n\t\t\t\t struct squashfs_file_info *finfo,\n\t\t\t\t struct squashfs_fragment_block_entry *fentry,\n\t\t\t\t __le32 blksz)\n{\n\tint datablk_count = 0, ret;\n\tfinfo->size = get_unaligned_le32(&reg->file_size);\n\tfinfo->offset = get_unaligned_le32(&reg->offset);\n\tfinfo->start = get_unaligned_le32(&reg->start_block);\n\tfinfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&reg->fragment));\n\tif (finfo->frag && finfo->offset == 0xFFFFFFFF)\n\t\treturn -EINVAL;\n\tif (finfo->size < 1 || finfo->start == 0xFFFFFFFF)\n\t\treturn -EINVAL;\n\tif (finfo->frag) {\n\t\tdatablk_count = finfo->size / le32_to_cpu(blksz);\n\t\tret = sqfs_frag_lookup(get_unaligned_le32(&reg->fragment),\n\t\t\t\t       fentry);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tfinfo->comp = ret;\n\t\tif (fentry->size < 1 || fentry->start == 0x7FFFFFFF)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdatablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));\n\t}\n\tfinfo->blk_sizes = malloc(datablk_count * sizeof(u32));\n\tif (!finfo->blk_sizes)\n\t\treturn -ENOMEM;\n\treturn datablk_count;\n}", "target": 0}
{"code": "input_utf8_add(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\tutf8_append(&ictx->utf8data, ictx->ch);\n\treturn (0);\n}", "target": 0}
{"code": "int spl_build_class_list_string(zval **entry, char **list TSRMLS_DC) \n{\n\tchar *res;\n\tspprintf(&res, 0, \"%s, %s\", *list, Z_STRVAL_PP(entry));\n\tefree(*list);\n\t*list = res;\n\treturn ZEND_HASH_APPLY_KEEP;", "target": 0}
{"code": "void afGetPCMMapping (AFfilehandle file, int trackid,\n\tdouble *slope, double *intercept, double *minClip, double *maxClip)\n{\n\t_Track\t*track;\n\tif (!_af_filehandle_ok(file))\n\t\treturn;\n\tif ((track = _af_filehandle_get_track(file, trackid)) == NULL)\n\t\treturn;\n\tif (slope)\n\t\t*slope = track->f.pcm.slope;\n\tif (intercept)\n\t\t*intercept = track->f.pcm.intercept;\n\tif (minClip)\n\t\t*minClip = track->f.pcm.minClip;\n\tif (maxClip)\n\t\t*maxClip = track->f.pcm.maxClip;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantUseCompound) {\n    addIndex(BSON(\"x\" << 1 << \"y\" << 1));\n    runQuery(fromjson(\"{ y: 10}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {y: 10}}}\");\n}", "target": 0}
{"code": "static void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\tkey = nla_nest_start(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(cookie->msg, NL80211_ATTR_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(cookie->msg, key);\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}", "target": 0}
{"code": "static void test_prepare_insert_update()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  int        i;\n  const char *testcase[]= {\n    \"CREATE TABLE t1 (a INT, b INT, c INT, UNIQUE (A), UNIQUE(B))\",\n    \"INSERT t1 VALUES (1,2,10), (3,4,20)\",\n    \"INSERT t1 VALUES (5,6,30), (7,4,40), (8,9,60) ON DUPLICATE KEY UPDATE c=c+100\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 SET a=5 ON DUPLICATE KEY UPDATE b=0\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 VALUES (2,1,11), (7,4,40) ON DUPLICATE KEY UPDATE c=c+VALUES(a)\",\n    NULL};\n  const char **cur_query;\n  myheader(\"test_prepare_insert_update\");\n  for (cur_query= testcase; *cur_query; cur_query++)\n  {\n    char query[MAX_TEST_QUERY_LENGTH];\n    printf(\"\\nRunning query: %s\", *cur_query);\n    strmov(query, *cur_query);\n    stmt= mysql_simple_prepare(mysql, query);\n    check_stmt(stmt);\n    verify_param_count(stmt, 0);\n    rc= mysql_stmt_execute(stmt);\n    check_execute(stmt, rc);\n    if (!cur_query[1])\n    {\n      for (i=0; i < 3;i++)\n      {\n        printf(\"\\nExecuting last statement again\");\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n      }\n    }\n    mysql_stmt_close(stmt);\n  }\n  rc= mysql_commit(mysql);\n  myquery(rc);\n}", "target": 0}
{"code": "void Item_param::reset()\n{\n  DBUG_ENTER(\"Item_param::reset\");\n  if (str_value.alloced_length() > MAX_CHAR_WIDTH)\n    str_value.free();\n  else\n    str_value.length(0);\n  str_value_ptr.length(0);\n  str_value.set_charset(&my_charset_bin);\n  collation.set(&my_charset_bin, DERIVATION_COERCIBLE);\n  state= NO_VALUE;\n  maybe_null= 1;\n  null_value= 0;\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}", "target": 0}
{"code": "_write_directory_descriptors(struct archive_write *a, struct vdd *vdd,\n    struct isoent *isoent, int depth)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tstruct isoent **enttbl;\n\tunsigned char *p, *wb;\n\tint i, r;\n\tint dr_l;\n\tp = wb = wb_buffptr(a);\n#define WD_REMAINING\t(LOGICAL_BLOCK_SIZE - (p - wb))\n\tp += set_directory_record(p, WD_REMAINING, isoent,\n\t    iso9660, DIR_REC_SELF, vdd->vdd_type);\n\tp += set_directory_record(p, WD_REMAINING, isoent,\n\t    iso9660, DIR_REC_PARENT, vdd->vdd_type);\n\tif (isoent->children.cnt <= 0 || (vdd->vdd_type != VDD_JOLIET &&\n\t    !iso9660->opt.rr && depth + 1 >= vdd->max_depth)) {\n\t\tmemset(p, 0, WD_REMAINING);\n\t\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n\t}\n\tenttbl = isoent->children_sorted;\n\tfor (i = 0; i < isoent->children.cnt; i++) {\n\t\tstruct isoent *np = enttbl[i];\n\t\tstruct isofile *file = np->file;\n\t\tif (file->hardlink_target != NULL)\n\t\t\tfile = file->hardlink_target;\n\t\tfile->cur_content = &(file->content);\n\t\tdo {\n\t\t\tdr_l = set_directory_record(p, WD_REMAINING,\n\t\t\t    np, iso9660, DIR_REC_NORMAL,\n\t\t\t    vdd->vdd_type);\n\t\t\tif (dr_l == 0) {\n\t\t\t\tmemset(p, 0, WD_REMAINING);\n\t\t\t\tr = wb_consume(a, LOGICAL_BLOCK_SIZE);\n\t\t\t\tif (r < 0)\n\t\t\t\t\treturn (r);\n\t\t\t\tp = wb = wb_buffptr(a);\n\t\t\t\tdr_l = set_directory_record(p,\n\t\t\t\t    WD_REMAINING, np, iso9660,\n\t\t\t\t    DIR_REC_NORMAL, vdd->vdd_type);\n\t\t\t}\n\t\t\tp += dr_l;\n\t\t\tfile->cur_content = file->cur_content->next;\n\t\t} while (file->cur_content != NULL);\n\t}\n\tmemset(p, 0, WD_REMAINING);\n\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"code": "static jboolean Region_isRect(JNIEnv* env, jobject region) {\n bool result = GetSkRegion(env, region)->isRect();\n return boolTojboolean(result);\n}", "target": 0}
{"code": "static int traversethread (global_State *g, lua_State *th) {\n  UpVal *uv;\n  StkId o = th->stack;\n  if (o == NULL)\n    return 1;  \n  lua_assert(g->gcstate == GCSatomic ||\n             th->openupval == NULL || isintwups(th));\n  for (; o < th->top; o++)  \n    markvalue(g, s2v(o));\n  for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)\n    markobject(g, uv);  \n  if (g->gcstate == GCSatomic) {  \n    StkId lim = th->stack + th->stacksize;  \n    for (; o < lim; o++)  \n      setnilvalue(s2v(o));\n    if (!isintwups(th) && th->openupval != NULL) {\n      th->twups = g->twups;  \n      g->twups = th;\n    }\n  }\n  else if (!g->gcemergency)\n    luaD_shrinkstack(th); \n  return 1 + th->stacksize;\n}", "target": 0}
{"code": "    ~FailedProvisionalLoadInfo() {}", "target": 0}
{"code": "u32 bnx2x_dmae_opcode_clr_src_reset(u32 opcode)\n{\n\treturn opcode & ~DMAE_CMD_SRC_RESET;\n}", "target": 0}
{"code": "chvt_rndsetup(const void *bp, size_t sz)\n{\n\tregister uint32_t h;\n\th = lcg_state;\n\t(void)rndget();\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &rndsetupstate, sizeof(rndsetupstate));\n\tBAFHUpdateMem_reg(h, bp, sz);\n\tBAFHFinish_reg(h);\n\treturn (h);\n}", "target": 0}
{"code": "check_LEARN(const struct ofpact_learn *a,\n            const struct ofpact_check_params *cp)\n{\n    return learn_check(a, cp->match);\n}", "target": 0}
{"code": "void LibRaw::unpacked_load_raw_FujiDBP()\n{\n  int scan_line, tile_n;\n  int nTiles;\n  nTiles = 8;\n  tile_width = raw_width / nTiles;\n  ushort *tile;\n  tile = (ushort *)calloc(raw_height, tile_width * 2);\n  for (tile_n = 0; tile_n < nTiles; tile_n++)\n  {\n    read_shorts(tile, tile_width * raw_height);\n    for (scan_line = 0; scan_line < raw_height; scan_line++)\n    {\n      memcpy(&raw_image[scan_line * raw_width + tile_n * tile_width],\n             &tile[scan_line * tile_width], tile_width * 2);\n    }\n  }\n  free(tile);\n  fseek(ifp, -2, SEEK_CUR); \n}", "target": 0}
{"code": "static int check_ptr_to_btf_access(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *regs,\n\t\t\t\t   int regno, int off, int size,\n\t\t\t\t   enum bpf_access_type atype,\n\t\t\t\t   int value_regno)\n{\n\tstruct bpf_reg_state *reg = regs + regno;\n\tconst struct btf_type *t = btf_type_by_id(reg->btf, reg->btf_id);\n\tconst char *tname = btf_name_by_offset(reg->btf, t->name_off);\n\tu32 btf_id;\n\tint ret;\n\tif (off < 0) {\n\t\tverbose(env,\n\t\t\t\"R%d is ptr_%s invalid negative access: off=%d\\n\",\n\t\t\tregno, tname, off);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env,\n\t\t\t\"R%d is ptr_%s invalid variable offset: off=%d, var_off=%s\\n\",\n\t\t\tregno, tname, off, tn_buf);\n\t\treturn -EACCES;\n\t}\n\tif (env->ops->btf_struct_access) {\n\t\tret = env->ops->btf_struct_access(&env->log, reg->btf, t,\n\t\t\t\t\t\t  off, size, atype, &btf_id);\n\t} else {\n\t\tif (atype != BPF_READ) {\n\t\t\tverbose(env, \"only read is supported\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tret = btf_struct_access(&env->log, reg->btf, t, off, size,\n\t\t\t\t\tatype, &btf_id);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\tif (atype == BPF_READ && value_regno >= 0)\n\t\tmark_btf_ld_reg(env, regs, value_regno, ret, reg->btf, btf_id);\n\treturn 0;\n}", "target": 0}
{"code": "irc_server_get_tags_to_send (const char *tags)\n{\n    int length;\n    char *buf;\n    if (!tags && !irc_server_send_default_tags)\n        return NULL;\n    if (!tags)\n        return strdup (irc_server_send_default_tags);\n    if (!irc_server_send_default_tags)\n        return strdup (tags);\n    length = strlen (tags) + 1 + strlen (irc_server_send_default_tags) + 1;\n    buf = malloc (length);\n    if (buf)\n        snprintf (buf, length, \"%s,%s\", tags, irc_server_send_default_tags);\n    return buf;\n}", "target": 0}
{"code": "  void InstallOnIOThread(const base::Closure& done,\n                        ServiceWorkerStatusCode* result) {\n    ASSERT_TRUE(BrowserThread::CurrentlyOn(BrowserThread::IO));\n    version_->DispatchInstallEvent(\n        -1, CreateReceiver(BrowserThread::UI, done, result));\n  }", "target": 0}
{"code": "String HTMLInputElement::selectionDirectionForBinding(ExceptionState& exceptionState) const\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return String();\n    }\n    return HTMLTextFormControlElement::selectionDirection();\n}", "target": 0}
{"code": "Item_bin_string::Item_bin_string(const char *str, uint str_length)\n{\n  const char *end= str + str_length - 1;\n  uchar bits= 0;\n  uint power= 1;\n  max_length= (str_length + 7) >> 3;\n  char *ptr= (char*) sql_alloc(max_length + 1);\n  if (!ptr)\n    return;\n  str_value.set(ptr, max_length, &my_charset_bin);\n  if (max_length > 0)\n  {\n    ptr+= max_length - 1;\n    ptr[1]= 0;                     \n    for (; end >= str; end--)\n    {\n      if (power == 256)\n      {\n        power= 1;\n        *ptr--= bits;\n        bits= 0;\n      }\n      if (*end == '1')\n        bits|= power;\n      power<<= 1;\n    }\n    *ptr= (char) bits;\n  }\n  else\n    ptr[0]= 0;\n  collation.set(&my_charset_bin, DERIVATION_COERCIBLE);\n  fixed= 1;\n}", "target": 0}
{"code": "static inline void skb_reset_mac_len(struct sk_buff *skb)\n{\n\tskb->mac_len = skb->network_header - skb->mac_header;\n}", "target": 0}
{"code": "__archive_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n\treturn (__archive_read_filter_ahead(a->filter, min, avail));\n}", "target": 0}
{"code": "static void virtio_net_tx_timer(void *opaque)\n{\n    VirtIONetQueue *q = opaque;\n    VirtIONet *n = q->n;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    if (!vdev->vm_running) {\n        assert(q->tx_waiting);\n        return;\n    }\n    q->tx_waiting = 0;\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        return;\n    }\n    virtio_queue_set_notification(q->tx_vq, 1);\n    virtio_net_flush_tx(q);\n}", "target": 0}
{"code": "unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}", "target": 0}
{"code": "static bool range_within(struct bpf_reg_state *old,\n\t\t\t struct bpf_reg_state *cur)\n{\n\treturn old->umin_value <= cur->umin_value &&\n\t       old->umax_value >= cur->umax_value &&\n\t       old->smin_value <= cur->smin_value &&\n\t       old->smax_value >= cur->smax_value &&\n\t       old->u32_min_value <= cur->u32_min_value &&\n\t       old->u32_max_value >= cur->u32_max_value &&\n\t       old->s32_min_value <= cur->s32_min_value &&\n\t       old->s32_max_value >= cur->s32_max_value;\n}", "target": 0}
{"code": "void AAHD::make_ahd_rb_hv(int i)\n{\n  int iwidth = libraw.imgdata.sizes.iwidth;\n  int js = libraw.COLOR(i, 0) & 1;\n  int kc = libraw.COLOR(i, js);\n  js ^= 1; \n  int hvdir[2] = {Pe, Ps};\n  for (int j = js; j < iwidth; j += 2)\n  {\n    int x = j + nr_margin;\n    int y = i + nr_margin;\n    int moff = nr_offset(y, x);\n    for (int d = 0; d < 2; ++d)\n    {\n      ushort3 *cnr;\n      cnr = &rgb_ahd[d][moff];\n      int c = kc ^ (d << 1); \n      int h1 = cnr[-hvdir[d]][c] - cnr[-hvdir[d]][1];\n      int h2 = cnr[+hvdir[d]][c] - cnr[+hvdir[d]][1];\n      int h0 = (h1 + h2) / 2;\n      int eg = cnr[0][1] + h0;\n      if (eg > channel_maximum[c])\n        eg = channel_maximum[c];\n      else if (eg < channel_minimum[c])\n        eg = channel_minimum[c];\n      cnr[0][c] = eg;\n    }\n  }\n}", "target": 0}
{"code": "void help(void)\n{\n\tprintf(_(\"%s %s -- get file access control lists\\n\"),\n\t       progname, VERSION);\n\tprintf(_(\"Usage: %s [-%s] file ...\\n\"),\n\t         progname, cmd_line_options);\n#if !POSIXLY_CORRECT\n\tif (posixly_correct) {\n#endif\n\t\tprintf(_(\n\"  -d, --default           display the default access control list\\n\"));\n#if !POSIXLY_CORRECT\n\t} else {\n\t\tprintf(_(\n\"  -a,  --access           display the file access control list only\\n\"\n\"  -d, --default           display the default access control list only\\n\"\n\"  -c, --omit-header       do not display the comment header\\n\"\n\"  -e, --all-effective     print all effective rights\\n\"\n\"  -E, --no-effective      print no effective rights\\n\"\n\"  -s, --skip-base         skip files that only have the base entries\\n\"\n\"  -R, --recursive         recurse into subdirectories\\n\"\n\"  -L, --logical           logical walk, follow symbolic links\\n\"\n\"  -P, --physical          physical walk, do not follow symbolic links\\n\"\n\"  -t, --tabular           use tabular output format\\n\"\n\"  -n, --numeric           print numeric user/group identifiers\\n\"\n\"  -p, --absolute-names    don't strip leading '/' in pathnames\\n\"));\n\t}\n#endif\n\tprintf(_(\n\"  -v, --version           print version and exit\\n\"\n\"  -h, --help              this help text\\n\"));\n}", "target": 0}
{"code": "static int get_capture_buffer(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = file->private_data;\n\tint pos, ret;\n\tint timeout_happened;\n\tif ((file->f_flags & O_NONBLOCK) &&\n\t    (dev->write_position <= opener->read_position &&\n\t     dev->reread_count <= opener->reread_count && !dev->timeout_happened))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(dev->read_event, can_read(dev, opener));\n\tspin_lock_bh(&dev->lock);\n\tif (dev->write_position == opener->read_position) {\n\t\tif (dev->reread_count > opener->reread_count + 2)\n\t\t\topener->reread_count = dev->reread_count - 1;\n\t\t++opener->reread_count;\n\t\tpos = (opener->read_position + dev->used_buffers - 1) % dev->used_buffers;\n\t} else {\n\t\topener->reread_count = 0;\n\t\tif (dev->write_position > opener->read_position + 2)\n\t\t\topener->read_position = dev->write_position - 1;\n\t\tpos = opener->read_position % dev->used_buffers;\n\t\t++opener->read_position;\n\t}\n\ttimeout_happened = dev->timeout_happened;\n\tdev->timeout_happened = 0;\n\tspin_unlock_bh(&dev->lock);\n\tret = dev->bufpos2index[pos];\n\tif (timeout_happened) {\n\t\tmemcpy(dev->image + dev->buffers[ret].buffer.m.offset,\n\t\t       dev->timeout_image, dev->buffer_size);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "DLLEXPORT int DLLCALL tjDecompressHeader2(tjhandle handle,\n\tunsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height,\n\tint *jpegSubsamp)\n{\n\tint jpegColorspace;\n\treturn tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,\n\t\tjpegSubsamp, &jpegColorspace);\n}", "target": 0}
{"code": "mm_answer_sessid(int socket, Buffer *m)\n{\n\tint i;\n\tdebug3(\"%s entering\", __func__);\n\tif (buffer_len(m) != 16)\n\t\tfatal(\"%s: bad ssh1 session id\", __func__);\n\tfor (i = 0; i < 16; i++)\n\t\tsession_id[i] = buffer_get_char(m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "Item_bool_func2::remove_eq_conds(THD *thd, Item::cond_result *cond_value,\n                                 bool top_level_arg)\n{\n  if (const_item() && !is_expensive())\n  {\n    *cond_value= eval_const_cond() ? Item::COND_TRUE : Item::COND_FALSE;\n    return (COND*) 0;\n  }\n  if ((*cond_value= eq_cmp_result()) != Item::COND_OK)\n  {\n    if (args[0]->eq(args[1], true))\n    {\n      if (!args[0]->maybe_null || functype() == Item_func::EQUAL_FUNC)\n        return (COND*) 0;                       \n    }\n  }\n  *cond_value= Item::COND_OK;\n  return this;                                  \n}", "target": 0}
{"code": "storagePoolListAllVolumes(virStoragePoolPtr pool,\n                          virStorageVolPtr **vols,\n                          unsigned int flags)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    int ret = -1;\n    virCheckFlags(0, -1);\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n    if (virStoragePoolListAllVolumesEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n    ret = virStoragePoolObjVolumeListExport(pool->conn, obj, vols,\n                                            virStoragePoolListAllVolumesCheckACL);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "void kvm_flush_remote_tlbs(struct kvm *kvm)\n{\n\tlong dirty_count = smp_load_acquire(&kvm->tlbs_dirty);\n\tif (kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH))\n\t\t++kvm->stat.remote_tlb_flush;\n\tcmpxchg(&kvm->tlbs_dirty, dirty_count, 0);\n}", "target": 0}
{"code": "    inline unsigned int& exception_mode(const unsigned int mode) {\n      return _exception_mode(mode,true);\n    }", "target": 0}
{"code": "static int fts3ExprPhraseCount(Fts3Expr *pExpr){\n  int nPhrase = 0;\n  (void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);\n  return nPhrase;\n}", "target": 0}
{"code": "static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    static const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n    memset(buf, 0, 640);\n    memcpy(buf, header_prefix, 5);\n    buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01;\n    buf[6] = 0x80; \n    buf[7] = 0xa0; \n    AV_WB16(buf + 0x18, avctx->height>>ctx->interlaced); \n    AV_WB16(buf + 0x1a, avctx->width);  \n    AV_WB16(buf + 0x1d, avctx->height>>ctx->interlaced); \n    buf[0x21] = ctx->cid_table->bit_depth == 10 ? 0x58 : 0x38;\n    buf[0x22] = 0x88 + (ctx->interlaced<<2);\n    AV_WB32(buf + 0x28, ctx->cid); \n    buf[0x2c] = ctx->interlaced ? 0 : 0x80;\n    buf[0x5f] = 0x01; \n    buf[0x167] = 0x02; \n    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); \n    buf[0x16d] = ctx->m.mb_height; \n    buf[0x16f] = 0x10; \n    ctx->msip = buf + 0x170;\n    return 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(snmpget)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_GET, SNMP_VERSION_1);\n}", "target": 0}
{"code": "SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct SMB2_sess_data *sess_data;\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tsess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\trc = SMB2_select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\tsess_data->previous_session = ses->Suid;\n\tmemcpy(ses->preauth_sha_hash, ses->server->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\tif ((ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST) && (ses->sign))\n\t\tcifs_dbg(VFS, \"signing requested but authenticated as guest\\n\");\n\trc = sess_data->result;\nout:\n\tkfree(sess_data);\n\treturn rc;\n}", "target": 0}
{"code": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}", "target": 0}
{"code": "void Browser::RunFileChooser(content::RenderFrameHost* render_frame_host,\n                             const content::FileChooserParams& params) {\n  FileSelectHelper::RunFileChooser(render_frame_host, params);\n}", "target": 0}
{"code": "static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_ud(ctxt);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\tctxt->regs[VCPU_REGS_RSP] = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "add_multi_byte_cclass(BBuf* mbuf, regex_t* reg)\n{\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n  add_length(reg, mbuf->used);\n  return add_bytes(reg, mbuf->p, mbuf->used);\n#else\n  int r, pad_size;\n  UChar* p = BBUF_GET_ADD_ADDRESS(reg) + SIZE_LENGTH;\n  GET_ALIGNMENT_PAD_SIZE(p, pad_size);\n  add_length(reg, mbuf->used + (WORD_ALIGNMENT_SIZE - 1));\n  if (pad_size != 0) add_bytes(reg, PadBuf, pad_size);\n  r = add_bytes(reg, mbuf->p, mbuf->used);\n  pad_size = (WORD_ALIGNMENT_SIZE - 1) - pad_size;\n  if (pad_size != 0) add_bytes(reg, PadBuf, pad_size);\n  return r;\n#endif\n}", "target": 0}
{"code": "static int cmm_suspend(void)\n{\n\tcmm_suspended = 1;\n\tcmm_free_pages(cmm_pages, &cmm_pages, &cmm_page_list);\n\tcmm_free_pages(cmm_timed_pages, &cmm_timed_pages, &cmm_timed_page_list);\n\treturn 0;\n}", "target": 0}
{"code": "int x509_raw_crt_to_raw_pubkey(const gnutls_datum_t * cert,\n\t\t\t   gnutls_datum_t * rpubkey)\n{\n\tgnutls_x509_crt_t crt = NULL;\n\tint ret;\n\tret = gnutls_x509_crt_init(&crt);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = gnutls_x509_crt_import(crt, cert, GNUTLS_X509_FMT_DER);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = x509_crt_to_raw_pubkey(crt, rpubkey);\n cleanup:\n\tgnutls_x509_crt_deinit(crt);\n\treturn ret;\n}", "target": 0}
{"code": "static int ct_release_key(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_release(player);\n}", "target": 0}
{"code": "crm_ipc_prepare(uint32_t request, xmlNode * message, struct iovec ** result)\n{\n    static int biggest = 0;\n    struct iovec *iov;\n    unsigned int total = 0;\n    char *compressed = NULL;\n    char *buffer = dump_xml_unformatted(message);\n    struct crm_ipc_response_header *header = calloc(1, sizeof(struct crm_ipc_response_header));\n    CRM_ASSERT(result != NULL);\n    iov = calloc(2, sizeof(struct iovec));\n    crm_ipc_init();\n    iov[0].iov_len = hdr_offset;\n    iov[0].iov_base = header;\n    header->size_uncompressed = 1 + strlen(buffer);\n    total = hdr_offset + header->size_uncompressed;\n    if (total < ipc_buffer_max) {\n        iov[1].iov_base = buffer;\n        iov[1].iov_len = header->size_uncompressed;\n    } else {\n        unsigned int new_size = 0;\n        if (total > biggest) {\n            biggest = 2 * QB_MAX(total, biggest);\n            crm_notice(\"Message exceeds the configured ipc limit (%d bytes), \"\n                       \"consider configuring PCMK_ipc_buffer to %d or higher \"\n                       \"to avoid compression overheads\", ipc_buffer_max, biggest);\n        }\n        if (crm_compress_string\n            (buffer, header->size_uncompressed, ipc_buffer_max, &compressed, &new_size)) {\n            header->flags |= crm_ipc_compressed;\n            header->size_compressed = new_size;\n            iov[1].iov_len = header->size_compressed;\n            iov[1].iov_base = compressed;\n            free(buffer);\n        } else {\n            ssize_t rc = -EMSGSIZE;\n            crm_log_xml_trace(message, \"EMSGSIZE\");\n            crm_err\n                (\"Could not compress the message into less than the configured ipc limit (%d bytes).\"\n                 \"Set PCMK_ipc_buffer to a higher value (%d bytes suggested)\", ipc_buffer_max,\n                 biggest);\n            free(compressed);\n            free(buffer);\n            free(header);\n            free(iov);\n            return rc;\n        }\n    }\n    header->qb.size = iov[0].iov_len + iov[1].iov_len;\n    header->qb.id = request;    \n    *result = iov;\n    return header->qb.size;\n}", "target": 0}
{"code": "void LibRaw::sony_arq_load_raw()\n{\n  int row, col;\n  read_shorts(imgdata.rawdata.raw_image,\n              imgdata.sizes.raw_width * imgdata.sizes.raw_height * 4);\n  libraw_internal_data.internal_data.input->seek(\n      -2, SEEK_CUR); \n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    unsigned short(*rowp)[4] =\n        (unsigned short(*)[4]) &\n        imgdata.rawdata.raw_image[row * imgdata.sizes.raw_width * 4];\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      unsigned short g2 = rowp[col][2];\n      rowp[col][2] = rowp[col][3];\n      rowp[col][3] = g2;\n      if (((unsigned)(row - imgdata.sizes.top_margin) < imgdata.sizes.height) &&\n          ((unsigned)(col - imgdata.sizes.left_margin) < imgdata.sizes.width) &&\n          (MAX(MAX(rowp[col][0], rowp[col][1]),\n               MAX(rowp[col][2], rowp[col][3])) > imgdata.color.maximum))\n        derror();\n    }\n  }\n}", "target": 0}
{"code": "static void spl_heap_it_get_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC) \n{\n\tspl_heap_it *iterator = (spl_heap_it *)iter;\n\tZVAL_LONG(key, iterator->object->heap->count - 1);\n}", "target": 0}
{"code": "char *get_next_file()\n{\n  char *ret;\n  DWORD dwWaitResult;\n  if (!queue)\n    return NULL;\n  if (qptr >= qsize)\n    return NULL;\n  dwWaitResult = WaitForSingleObject(qmutex,    \n                                     INFINITE); \n  switch (dwWaitResult)\n  {\n  case WAIT_OBJECT_0:\n    ret = queue[qptr++];\n    ReleaseMutex(qmutex);\n    break;\n  case WAIT_ABANDONED:\n    return NULL; \n  };\n  return ret;\n}", "target": 0}
{"code": "tor_version_is_obsolete(const char *myversion, const char *versionlist)\n{\n  tor_version_t mine, other;\n  int found_newer = 0, found_older = 0, found_newer_in_series = 0,\n    found_any_in_series = 0, r, same;\n  version_status_t ret = VS_UNRECOMMENDED;\n  smartlist_t *version_sl;\n  log_debug(LD_CONFIG,\"Checking whether version '%s' is in '%s'\",\n            myversion, versionlist);\n  if (tor_version_parse(myversion, &mine)) {\n    log_err(LD_BUG,\"I couldn't parse my own version (%s)\", myversion);\n    tor_assert(0);\n  }\n  version_sl = smartlist_new();\n  smartlist_split_string(version_sl, versionlist, \",\", SPLIT_SKIP_SPACE, 0);\n  if (!strlen(versionlist)) { \n    ret = VS_EMPTY;\n    goto done;\n  }\n  SMARTLIST_FOREACH_BEGIN(version_sl, const char *, cp) {\n    if (!strcmpstart(cp, \"Tor \"))\n      cp += 4;\n    if (tor_version_parse(cp, &other)) {\n    } else {\n      same = tor_version_same_series(&mine, &other);\n      if (same)\n        found_any_in_series = 1;\n      r = tor_version_compare(&mine, &other);\n      if (r==0) {\n        ret = VS_RECOMMENDED;\n        goto done;\n      } else if (r<0) {\n        found_newer = 1;\n        if (same)\n          found_newer_in_series = 1;\n      } else if (r>0) {\n        found_older = 1;\n      }\n    }\n  } SMARTLIST_FOREACH_END(cp);\n  if (found_any_in_series && !found_newer_in_series && found_newer) {\n    ret = VS_NEW_IN_SERIES;\n  } else if (found_newer && !found_older) {\n    ret = VS_OLD;\n  } else if (found_older && !found_newer) {\n    ret = VS_NEW;\n  } else {\n    ret = VS_UNRECOMMENDED;\n  }\n done:\n  SMARTLIST_FOREACH(version_sl, char *, version, tor_free(version));\n  smartlist_free(version_sl);\n  return ret;\n}", "target": 0}
{"code": "static struct page *alloc_gigantic_page(int nid, unsigned int order)\n{\n\tunsigned long nr_pages = 1 << order;\n\tunsigned long ret, pfn, flags;\n\tstruct zone *z;\n\tz = NODE_DATA(nid)->node_zones;\n\tfor (; z - NODE_DATA(nid)->node_zones < MAX_NR_ZONES; z++) {\n\t\tspin_lock_irqsave(&z->lock, flags);\n\t\tpfn = ALIGN(z->zone_start_pfn, nr_pages);\n\t\twhile (zone_spans_last_pfn(z, pfn, nr_pages)) {\n\t\t\tif (pfn_range_valid_gigantic(z, pfn, nr_pages)) {\n\t\t\t\tspin_unlock_irqrestore(&z->lock, flags);\n\t\t\t\tret = __alloc_gigantic_page(pfn, nr_pages);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn pfn_to_page(pfn);\n\t\t\t\tspin_lock_irqsave(&z->lock, flags);\n\t\t\t}\n\t\t\tpfn += nr_pages;\n\t\t}\n\t\tspin_unlock_irqrestore(&z->lock, flags);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "update_string_node_case_fold(regex_t* reg, Node *node)\n{\n  UChar *p, *q, *end, buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *sbuf, *ebuf, *sp;\n  int r, i, len;\n  OnigDistance sbuf_size;\n  StrNode* sn = NSTR(node);\n  end = sn->end;\n  sbuf_size = (end - sn->s) * 2;\n  sbuf = (UChar* )xmalloc(sbuf_size);\n  CHECK_NULL_RETURN_MEMERR(sbuf);\n  ebuf = sbuf + sbuf_size;\n  sp = sbuf;\n  p = sn->s;\n  while (p < end) {\n    len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag, &p, end, buf);\n    q = buf;\n    for (i = 0; i < len; i++) {\n      if (sp >= ebuf) {\n\tsbuf = (UChar* )xrealloc(sbuf, sbuf_size * 2);\n\tCHECK_NULL_RETURN_MEMERR(sbuf);\n\tsp = sbuf + sbuf_size;\n\tsbuf_size *= 2;\n\tebuf = sbuf + sbuf_size;\n      }\n      *sp++ = buf[i];\n    }\n  }\n  r = onig_node_str_set(node, sbuf, sp);\n  if (r != 0) {\n    xfree(sbuf);\n    return r;\n  }\n  xfree(sbuf);\n  return 0;\n}", "target": 0}
{"code": "int is_bare_repository(void)\n{\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}", "target": 0}
{"code": "apprentice_compile(struct magic_set *ms, struct magic_map *map, const char *fn)\n{\n\tstatic const size_t nm = sizeof(*map->nmagic) * MAGIC_SETS;\n\tstatic const size_t m = sizeof(**map->magic);\n\tint fd = -1;\n\tsize_t len;\n\tchar *dbname;\n\tint rv = -1;\n\tuint32_t i;\n\tphp_stream *stream;\n\tTSRMLS_FETCH();\n\tdbname = mkdbname(ms, fn, 0);\n\tif (dbname == NULL) \n\t\tgoto out;\n#if PHP_API_VERSION < 20100412\n\tstream = php_stream_open_wrapper((char *)fn, \"wb+\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tstream = php_stream_open_wrapper((char *)fn, \"wb+\", REPORT_ERRORS, NULL);\n#endif\n\tif (!stream) {\n\t\tfile_error(ms, errno, \"cannot open `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tif (write(fd, ar, sizeof(ar)) != (ssize_t)sizeof(ar)) {\n\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tif (php_stream_write(stream, (const char *)map->nmagic, nm) != (ssize_t)nm) {\n\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tassert(nm + sizeof(ar) < m);\n\tif (php_stream_seek(stream,(off_t)sizeof(struct magic), SEEK_SET) != sizeof(struct magic)) {\n\t\tfile_error(ms, errno, \"error seeking `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tlen = m * map->nmagic[i];\n\t\tif (php_stream_write(stream, (const char *)map->magic[i], len) != (ssize_t)len) {\n\t\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (stream) {\n\t\tphp_stream_close(stream);\n\t}\n\trv = 0;\nout:\n\tefree(dbname);\n\treturn rv;\n}", "target": 0}
{"code": "update_info_linux_lvm2_lv (Device *device)\n{\n  const gchar *lv_name;\n  const gchar *vg_name;\n  const gchar *uuid;\n  gchar *lv_uuid;\n  gchar *vg_uuid;\n  gboolean is_lv;\n  is_lv = FALSE;\n  lv_uuid = NULL;\n  vg_uuid = NULL;\n  lv_name = g_udev_device_get_property (device->priv->d, \"DM_LV_NAME\");\n  vg_name = g_udev_device_get_property (device->priv->d, \"DM_VG_NAME\");\n  if (lv_name == NULL || vg_name == NULL)\n    goto out;\n  uuid = g_udev_device_get_sysfs_attr (device->priv->d, \"dm/uuid\");\n  if (uuid == NULL || !g_str_has_prefix (uuid, \"LVM-\"))\n    goto out;\n  vg_uuid = extract_lvm_uuid (uuid + 4);\n  if (vg_uuid == NULL)\n    goto out;\n  lv_uuid = extract_lvm_uuid (uuid + 4 + 32);\n  if (lv_uuid == NULL)\n    goto out;\n  is_lv = TRUE;\n  device_set_linux_lvm2_lv_name (device, lv_name);\n  device_set_linux_lvm2_lv_uuid (device, lv_uuid);\n  device_set_linux_lvm2_lv_group_name (device, vg_name);\n  device_set_linux_lvm2_lv_group_uuid (device, vg_uuid);\n  device_set_device_is_drive (device, FALSE);\n  device_set_device_is_partition (device, FALSE);\n out:\n  device_set_device_is_linux_lvm2_lv (device, is_lv);\n  g_free (vg_uuid);\n  g_free (lv_uuid);\n  return TRUE;\n}", "target": 0}
{"code": "xfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_bmbt_irec\t*irec)\n{\n\tunion xfs_btree_rec\trec;\n\txfs_bmbt_disk_set_all(&rec.bmbt, irec);\n\treturn xfs_btree_update(cur, &rec);\n}", "target": 0}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 0}
{"code": "static inline unsigned char *skb_network_header(const struct sk_buff *skb)\n{\n\treturn skb->head + skb->network_header;\n}", "target": 0}
{"code": "ProcChangeHosts(ClientPtr client)\n{\n    REQUEST(xChangeHostsReq);\n    REQUEST_FIXED_SIZE(xChangeHostsReq, stuff->hostLength);\n    if (stuff->mode == HostInsert)\n        return AddHost(client, (int) stuff->hostFamily,\n                       stuff->hostLength, (void *) &stuff[1]);\n    if (stuff->mode == HostDelete)\n        return RemoveHost(client, (int) stuff->hostFamily,\n                          stuff->hostLength, (void *) &stuff[1]);\n    client->errorValue = stuff->mode;\n    return BadValue;\n}", "target": 0}
{"code": "Item::Item():\n  is_expensive_cache(-1), rsize(0), name(0), orig_name(0), name_length(0),\n  fixed(0), is_autogenerated_name(TRUE),\n  collation(&my_charset_bin, DERIVATION_COERCIBLE)\n{\n  marker= 0;\n  maybe_null=null_value=with_sum_func=with_field=unsigned_flag=0;\n  in_rollup= 0;\n  decimals= 0; max_length= 0;\n  with_subselect= 0;\n  cmp_context= IMPOSSIBLE_RESULT;\n  join_tab_idx= MAX_TABLES;\n  THD *thd= current_thd;\n  next= thd->free_list;\n  thd->free_list= this;\n  if (thd->lex->current_select)\n  {\n    enum_parsing_place place= \n      thd->lex->current_select->parsing_place;\n    if (place == SELECT_LIST ||\n\tplace == IN_HAVING)\n      thd->lex->current_select->select_n_having_items++;\n  }\n}", "target": 0}
{"code": "static int oceanserver_send(int fd, const char *fmt, ...)\n{\n    int status;\n    char buf[BUFSIZ];\n    va_list ap;\n    va_start(ap, fmt);\n    (void)vsnprintf(buf, sizeof(buf) - 5, fmt, ap);\n    va_end(ap);\n    (void)strlcat(buf, \"\u001b\", BUFSIZ);\n    status = (int)write(fd, buf, strlen(buf));\n    (void)tcdrain(fd);\n    if (status == (int)strlen(buf)) {\n\tgpsd_report(LOG_IO, \"=> GPS: %s\\n\", buf);\n\treturn status;\n    } else {\n\tgpsd_report(LOG_WARN, \"=> GPS: %s FAILED\\n\", buf);\n\treturn -1;\n    }\n}", "target": 0}
{"code": "usr1_handler(int sig)\n{\nint fd;\nos_restarting_signal(sig, usr1_handler);\nif ((fd = Uopen(process_log_path, O_APPEND|O_WRONLY, LOG_MODE)) < 0)\n  {\n  int euid = geteuid();\n  if (euid == exim_uid)\n    fd = Uopen(process_log_path, O_CREAT|O_APPEND|O_WRONLY, LOG_MODE);\n  else if (euid == root_uid)\n    fd = log_create_as_exim(process_log_path);\n  }\nif (fd < 0) return;\n(void)write(fd, process_info, process_info_len);\n(void)close(fd);\n}", "target": 0}
{"code": "static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int sleep)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se;\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tdequeue_entity(cfs_rq, se, sleep);\n\t\tif (cfs_rq->load.weight)\n\t\t\tbreak;\n\t\tsleep = 1;\n\t}\n\thrtick_start_fair(rq, rq->curr);\n}", "target": 0}
{"code": "slhc_free(struct slcompress *comp)\n{\n\tif ( comp == NULLSLCOMPR )\n\t\treturn;\n\tif ( comp->tstate != NULLSLSTATE )\n\t\tkfree( comp->tstate );\n\tif ( comp->rstate != NULLSLSTATE )\n\t\tkfree( comp->rstate );\n\tkfree( comp );\n}", "target": 0}
{"code": "    constexpr uint32_t PentaxDngMnHeader::sizeOfSignature()\n    {\n        return sizeof(signature_);\n    }", "target": 0}
{"code": "unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)\n{\n  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);\n}", "target": 0}
{"code": "HttpStateData::handle1xx(HttpReply *reply)\n{\n    HttpReply::Pointer msg(reply); \n    Must(!flags.handling1xx);\n    flags.handling1xx = true;\n    if (!request->canHandle1xx() || request->forcedBodyContinuation) {\n        debugs(11, 2, \"ignoring 1xx because it is \" << (request->forcedBodyContinuation ? \"already sent\" : \"not supported by client\"));\n        proceedAfter1xx();\n        return;\n    }\n#if USE_HTTP_VIOLATIONS\n    if (Config.accessList.reply) {\n        ACLFilledChecklist ch(Config.accessList.reply, originalRequest(), NULL);\n        ch.al = fwd->al;\n        ch.reply = reply;\n        ch.syncAle(originalRequest(), nullptr);\n        HTTPMSGLOCK(ch.reply);\n        if (!ch.fastCheck().allowed()) { \n            debugs(11, 3, HERE << \"ignoring denied 1xx\");\n            proceedAfter1xx();\n            return;\n        }\n    }\n#endif \n    debugs(11, 2, HERE << \"forwarding 1xx to client\");\n    typedef NullaryMemFunT<HttpStateData> CbDialer;\n    const AsyncCall::Pointer cb = JobCallback(11, 3, CbDialer, this,\n                                  HttpStateData::proceedAfter1xx);\n    CallJobHere1(11, 4, request->clientConnectionManager, ConnStateData,\n                 ConnStateData::sendControlMsg, HttpControlMsg(msg, cb));\n}", "target": 0}
{"code": "static inline void reply_err(fuse_req_t req, int err)\n#endif \n{\n    fuse_reply_err(req, -err);\n}", "target": 0}
{"code": "genjmp(codegen_scope *s, mrb_code i, uint32_t pc)\n{\n  uint32_t pos;\n  genop_0(s, i);\n  pos = s->pc;\n  gen_jmpdst(s, pc);\n  return pos;\n}", "target": 0}
{"code": "static void mark_verifier_state_clean(struct bpf_verifier_env *env)\n{\n\tenv->scratched_regs = 0U;\n\tenv->scratched_stack_slots = 0UL;\n}", "target": 0}
{"code": "DLLIMPORT cfg_opt_t *cfg_getnopt(cfg_t *cfg, unsigned int index)\n{\n\tunsigned int i;\n\tif (!cfg)\n\t\treturn NULL;\n\tfor (i = 0; cfg->opts && cfg->opts[i].name; i++) {\n\t\tif (i == index)\n\t\t\treturn &cfg->opts[i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_FIXED_1;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\tkvmclock_reset(vcpu);\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\tkvm_pmu_reset(vcpu);\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}", "target": 0}
{"code": "static bool has_same_uncharge_info(struct file_region *rg,\n\t\t\t\t   struct file_region *org)\n{\n#ifdef CONFIG_CGROUP_HUGETLB\n\treturn rg->reservation_counter == org->reservation_counter &&\n\t       rg->css == org->css;\n#else\n\treturn true;\n#endif\n}", "target": 0}
{"code": "remote_post_process(address_item *addr, int logflags, uschar *msg,\n  BOOL fallback)\n{\nhost_item *h;\nfor (h = addr->host_list; h; h = h->next)\n  if (h->address)\n    if (h->status >= hstatus_unusable) tree_add_unusable(h);\nwhile (addr)\n  {\n  address_item *next = addr->next;\n  if (  addr->transport_return == DEFER\n     && addr->fallback_hosts\n     && !fallback\n     && !msg\n     )\n    {\n    addr->host_list = addr->fallback_hosts;\n    addr->next = addr_fallback;\n    addr_fallback = addr;\n    DEBUG(D_deliver) debug_printf(\"%s queued for fallback host(s)\\n\", addr->address);\n    }\n  else\n    {\n    if (msg)\n      {\n      addr->message = msg;\n      addr->transport_return = DEFER;\n      }\n    (void)post_process_one(addr, addr->transport_return, logflags,\n      EXIM_DTYPE_TRANSPORT, addr->special_action);\n    }\n  addr = next;\n  }\nif (!continue_transport) continue_sequence = 1;\n}", "target": 0}
{"code": "bool Clipboard::IsFormatAvailable(const Clipboard::FormatType& format,\n                                  Clipboard::Buffer buffer) const {\n  GtkClipboard* clipboard = LookupBackingClipboard(buffer);\n  if (clipboard == NULL)\n    return false;\n  bool format_is_plain_text = GetPlainTextFormatType() == format;\n  if (format_is_plain_text) {\n    if (gtk_clipboard_wait_is_text_available(clipboard))\n      return true;\n  }\n  bool retval = false;\n  GdkAtom* targets = NULL;\n  GtkSelectionData* data =\n      gtk_clipboard_wait_for_contents(clipboard,\n                                      gdk_atom_intern(\"TARGETS\", false));\n  if (!data)\n    return false;\n  int num = 0;\n  gtk_selection_data_get_targets(data, &targets, &num);\n  if (num <= 0) {\n    if (format_is_plain_text) {\n      gchar* text = gtk_clipboard_wait_for_text(clipboard);\n      if (text) {\n        g_free(text);\n        retval = true;\n      }\n    }\n  }\n  GdkAtom format_atom = StringToGdkAtom(format);\n  for (int i = 0; i < num; i++) {\n    if (targets[i] == format_atom) {\n      retval = true;\n      break;\n    }\n  }\n  g_free(targets);\n  gtk_selection_data_free(data);\n  return retval;\n}", "target": 0}
{"code": "void PluginInfoMessageFilter::Context::DecidePluginStatus(\n    const GetPluginInfo_Params& params,\n    const WebPluginInfo& plugin,\n    PluginFinder* plugin_finder,\n    ChromeViewHostMsg_GetPluginInfo_Status* status,\n    std::string* group_identifier,\n    string16* group_name) const {\n  PluginInstaller* installer = plugin_finder->GetPluginInstaller(plugin);\n  *group_name = installer->name();\n  *group_identifier = installer->identifier();\n  ContentSetting plugin_setting = CONTENT_SETTING_DEFAULT;\n  bool uses_default_content_setting = true;\n  GetPluginContentSetting(plugin, params.top_origin_url, params.url,\n                          *group_identifier, &plugin_setting,\n                          &uses_default_content_setting);\n  DCHECK(plugin_setting != CONTENT_SETTING_DEFAULT);\n#if defined(ENABLE_PLUGIN_INSTALLATION)\n  PluginInstaller::SecurityStatus plugin_status =\n      installer->GetSecurityStatus(plugin);\n  if (plugin_status == PluginInstaller::SECURITY_STATUS_OUT_OF_DATE &&\n      !allow_outdated_plugins_.GetValue()) {\n    if (allow_outdated_plugins_.IsManaged()) {\n      status->value =\n          ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedDisallowed;\n    } else {\n      status->value = ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedBlocked;\n    }\n    return;\n   }\n  if (plugin_status ==\n          PluginInstaller::SECURITY_STATUS_REQUIRES_AUTHORIZATION &&\n       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_IN_PROCESS &&\n       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_OUT_OF_PROCESS &&\n       !always_authorize_plugins_.GetValue() &&\n      plugin_setting != CONTENT_SETTING_BLOCK &&\n      uses_default_content_setting) {\n     status->value = ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized;\n     return;\n   }\n  if (PluginService::GetInstance()->IsPluginUnstable(plugin.path) &&\n      !always_authorize_plugins_.GetValue() &&\n      plugin_setting != CONTENT_SETTING_BLOCK &&\n      uses_default_content_setting) {\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized;\n    return;\n  }\n #endif\n   if (plugin_setting == CONTENT_SETTING_ASK)\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay;\n  else if (plugin_setting == CONTENT_SETTING_BLOCK)\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kBlocked;\n}", "target": 0}
{"code": "static inline u64 nsec_to_cycles(u64 nsec)\n{\n\tu64 ret;\n\tWARN_ON(preemptible());\n\tif (kvm_tsc_changes_freq())\n\t\tprintk_once(KERN_WARNING\n\t\t \"kvm: unreliable cycle conversion on adjustable rate TSC\\n\");\n\tret = nsec * __get_cpu_var(cpu_tsc_khz);\n\tdo_div(ret, USEC_PER_SEC);\n\treturn ret;\n}", "target": 0}
{"code": "GF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}", "target": 0}
{"code": "datetime_s_weeknum(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vw, vd, vf, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;\n    int w, d, f, h, min, s, rof;\n    double sg;\n    rb_scan_args(argc, argv, \"09\", &vy, &vw, &vd, &vf,\n\t\t &vh, &vmin, &vs, &vof, &vsg);\n    y = INT2FIX(-4712);\n    w = 0;\n    d = 1;\n    f = 0;\n    h = min = s = 0;\n    fr2 = INT2FIX(0);\n    rof = 0;\n    sg = DEFAULT_SG;\n    switch (argc) {\n      case 9:\n\tval2sg(vsg, sg);\n      case 8:\n\tval2off(vof, rof);\n      case 7:\n\tnum2int_with_frac(s, positive_inf);\n      case 6:\n\tnum2int_with_frac(min, 6);\n      case 5:\n\tnum2int_with_frac(h, 5);\n      case 4:\n\tf = NUM2INT(vf);\n      case 3:\n\tnum2int_with_frac(d, 4);\n      case 2:\n\tw = NUM2INT(vw);\n      case 1:\n\ty = vy;\n    }\n    {\n\tVALUE nth;\n\tint ry, rw, rd, rh, rmin, rs, rjd, rjd2, ns;\n\tif (!valid_weeknum_p(y, w, d, f, sg,\n\t\t\t     &nth, &ry,\n\t\t\t     &rw, &rd, &rjd,\n\t\t\t     &ns))\n\t    rb_raise(eDateError, \"invalid date\");\n\tif (!c_valid_time_p(h, min, s, &rh, &rmin, &rs))\n\t    rb_raise(eDateError, \"invalid date\");\n\tcanon24oc();\n\trjd2 = jd_local_to_utc(rjd,\n\t\t\t       time_to_df(rh, rmin, rs),\n\t\t\t       rof);\n\tret = d_complex_new_internal(klass,\n\t\t\t\t     nth, rjd2,\n\t\t\t\t     0, INT2FIX(0),\n\t\t\t\t     rof, sg,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     rh, rmin, rs,\n\t\t\t\t     HAVE_JD | HAVE_TIME);\n    }\n    add_frac();\n    return ret;\n}", "target": 0}
{"code": "    uint32_t TiffImageEntry::doWriteData(IoWrapper& ioWrapper,\n                                         ByteOrder byteOrder,\n                                         int32_t   ,\n                                         uint32_t  ,\n                                         uint32_t& ) const\n    {\n        uint32_t len = 0;\n        if (group() > mnId) { \n            len = writeImage(ioWrapper, byteOrder);\n        }\n        return len;\n    } ", "target": 0}
{"code": "XML_GetAttributeInfo(XML_Parser parser) {\n  if (parser == NULL)\n    return NULL;\n  return parser->m_attInfo;\n}", "target": 0}
{"code": "Field *Item::create_field_for_schema(THD *thd, TABLE *table)\n{\n  if (field_type() == MYSQL_TYPE_VARCHAR)\n  {\n    Field *field;\n    if (max_length > MAX_FIELD_VARCHARLENGTH)\n      field= new Field_blob(max_length, maybe_null, name, collation.collation);\n    else\n      field= new Field_varstring(max_length, maybe_null, name,\n                                 table->s, collation.collation);\n    if (field)\n      field->init(table);\n    return field;\n  }\n  return tmp_table_field_from_field_type(table, false, false);\n}", "target": 0}
{"code": "static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortOrder[i] = pOrderBy->a[i].sortOrder;\n    }\n  }\n  return pRet;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetNeedsBeginFrame(bool needs_begin_frames) {\n  if (needs_begin_frames_ == needs_begin_frames)\n    return;\n  needs_begin_frames_ = needs_begin_frames;\n  if (view_)\n    view_->SetNeedsBeginFrames(needs_begin_frames);\n}", "target": 0}
{"code": "int ida_get_new(struct ida *ida, int *p_id)\n{\n\treturn ida_get_new_above(ida, 0, p_id);\n}", "target": 0}
{"code": "attach_to_red_agent(RedsState *reds, SpiceCharDeviceInstance *sin)\n{\n    RedCharDeviceVDIPort *dev = reds->agent_dev.get();\n    SpiceCharDeviceInterface *sif;\n    dev->priv->agent_attached = true;\n    dev->reset_dev_instance(sin);\n    reds->vdagent = sin;\n    reds_update_mouse_mode(reds);\n    sif = spice_char_device_get_interface(sin);\n    if (sif->state) {\n        sif->state(sin, 1);\n    }\n    if (!reds_main_channel_connected(reds)) {\n        return reds->agent_dev;\n    }\n    dev->priv->read_filter.discard_all = FALSE;\n    dev->priv->plug_generation++;\n    if (dev->priv->mig_data ||\n        reds->main_channel->is_waiting_for_migrate_data()) {\n        RedCharDeviceClientOpaque *client_opaque =\n            (RedCharDeviceClientOpaque *) reds_get_client(reds);\n        if (!dev->client_exists(client_opaque)) {\n            int client_added;\n            client_added = dev->client_add(client_opaque, TRUE,\n                                           REDS_VDI_PORT_NUM_RECEIVE_BUFFS,\n                                           REDS_AGENT_WINDOW_SIZE, ~0, TRUE);\n            if (!client_added) {\n                spice_warning(\"failed to add client to agent\");\n                reds_disconnect(reds);\n            }\n        }\n        if (dev->priv->mig_data) {\n            spice_debug(\"restoring dev from stored migration data\");\n            spice_assert(dev->priv->plug_generation == 1);\n            reds_agent_state_restore(reds, dev->priv->mig_data);\n            g_free(dev->priv->mig_data);\n            dev->priv->mig_data = NULL;\n        }\n        else {\n            spice_debug(\"waiting for migration data\");\n        }\n    } else {\n        reds->main_channel->push_agent_connected();\n    }\n    return reds->agent_dev;\n}", "target": 0}
{"code": "ex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_emptybuf));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    \n\t}\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n    ex_no_reprint = TRUE;\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE int spice_server_set_video_codecs(SpiceServer *reds, const char *video_codecs)\n{\n    unsigned int installed = 0;\n    reds_set_video_codecs_from_string(reds, video_codecs, &installed);\n    if (!installed) {\n        return -1;\n    }\n    reds_on_vc_change(reds);\n    return 0;\n}", "target": 0}
{"code": "    Value::UniquePtr Exifdatum::getValue() const\n    {\n        return value_.get() == 0 ? nullptr : value_->clone();\n    }", "target": 0}
{"code": "void RGWDeleteMultiObj_ObjStore_S3::send_partial_response(rgw_obj_key& key,\n\t\t\t\t\t\t\t  bool delete_marker,\n\t\t\t\t\t\t\t  const string& marker_version_id, int ret)\n{\n  if (!key.empty()) {\n    if (op_ret == 0 && !quiet) {\n      s->formatter->open_object_section(\"Deleted\");\n      s->formatter->dump_string(\"Key\", key.name);\n      if (!key.instance.empty()) {\n\ts->formatter->dump_string(\"VersionId\", key.instance);\n      }\n      if (delete_marker) {\n\ts->formatter->dump_bool(\"DeleteMarker\", true);\n\ts->formatter->dump_string(\"DeleteMarkerVersionId\", marker_version_id);\n      }\n      s->formatter->close_section();\n    } else if (op_ret < 0) {\n      struct rgw_http_error r;\n      int err_no;\n      s->formatter->open_object_section(\"Error\");\n      err_no = -op_ret;\n      rgw_get_errno_s3(&r, err_no);\n      s->formatter->dump_string(\"Key\", key.name);\n      s->formatter->dump_string(\"VersionId\", key.instance);\n      s->formatter->dump_string(\"Code\", r.s3_code);\n      s->formatter->dump_string(\"Message\", r.s3_code);\n      s->formatter->close_section();\n    }\n    rgw_flush_formatter(s, s->formatter);\n  }\n}", "target": 0}
{"code": "static ssize_t intel_iommu_show_cap(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct intel_iommu *iommu = dev_to_intel_iommu(dev);\n\treturn sprintf(buf, \"%llx\\n\", iommu->cap);\n}", "target": 0}
{"code": "long keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\tif (capable(CAP_SYS_ADMIN) || key->uid == current_fsuid()) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n} ", "target": 0}
{"code": "static void mmtimer_setup_int_1(int cpu, u64 expires)\n{\n\tu64 val;\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_ENABLE), 0UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPC), -1L);\n\tmmtimer_clr_int_pending(1);\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC2_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC2_INT_CONFIG_PID_SHFT);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_CONFIG), val);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_ENABLE), 1UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPC), expires);\n}", "target": 0}
{"code": "void ContainerNode::disconnectDescendantFrames()\n{\n    ChildFrameDisconnector(*this).disconnect();\n}", "target": 0}
{"code": "static inline int perf_cgroup_connect(int fd, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct cgroup_subsys_state *css;\n\tstruct fd f = fdget(fd);\n\tint ret = 0;\n\tif (!f.file)\n\t\treturn -EBADF;\n\tcss = cgroup_css_from_dir(f.file, perf_subsys_id);\n\tif (IS_ERR(css)) {\n\t\tret = PTR_ERR(css);\n\t\tgoto out;\n\t}\n\tcgrp = container_of(css, struct perf_cgroup, css);\n\tevent->cgrp = cgrp;\n\tif (!perf_tryget_cgroup(event)) {\n\t\tevent->cgrp = NULL;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (group_leader && group_leader->cgrp != cgrp) {\n\t\tperf_detach_cgroup(event);\n\t\tret = -EINVAL;\n\t}\nout:\n\tfdput(f);\n\treturn ret;\n}", "target": 0}
{"code": "sync_create_sync_done_control(LDAPControl **ctrlp, int refresh, char *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    if (ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = NULL;\n    if (cookie) {\n        if ((rc = ber_printf(ber, \"{s\", cookie)) != -1) {\n            if (refresh) {\n                rc = ber_printf(ber, \"b}\", refresh);\n            } else {\n                rc = ber_printf(ber, \"}\");\n            }\n        }\n    } else {\n        if (refresh) {\n            rc = ber_printf(ber, \"{b}\", refresh);\n        } else {\n            rc = ber_printf(ber, \"{}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_DONE);\n    (*ctrlp)->ldctl_value = *bvp; \n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n    return (LDAP_SUCCESS);\n}", "target": 0}
{"code": "static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    Jpeg2000QuantStyle tmp;\n    int compno, ret;\n    memset(&tmp, 0, sizeof(tmp));\n    if ((ret = get_qcx(s, n, &tmp)) < 0)\n        return ret;\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_QCC))\n            memcpy(q + compno, &tmp, sizeof(tmp));\n    return 0;\n}", "target": 0}
{"code": "static void MaybeHandleDebugURL(const GURL& url) {\n  if (!url.SchemeIs(chrome::kChromeUIScheme))\n    return;\n  if (url == GURL(chrome::kChromeUICrashURL)) {\n    CrashIntentionally();\n  } else if (url == GURL(chrome::kChromeUIKillURL)) {\n    base::KillProcess(base::GetCurrentProcessHandle(), 1, false);\n  } else if (url == GURL(chrome::kChromeUIHangURL)) {\n    for (;;) {\n      base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(1));\n    }\n  } else if (url == GURL(kChromeUIShorthangURL)) {\n    base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(20));\n  }\n}", "target": 0}
{"code": "as_printf(netdissect_options *ndo,\n          char *str, int size, u_int asnum)\n{\n\tif (!ndo->ndo_bflag || asnum <= 0xFFFF) {\n\t\tsnprintf(str, size, \"%u\", asnum);\n\t} else {\n\t\tsnprintf(str, size, \"%u.%u\", asnum >> 16, asnum & 0xFFFF);\n\t}\n\treturn str;\n}", "target": 0}
{"code": "GF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, fiin_on_child_box);", "target": 0}
{"code": "int tipc_node_xmit_skb(struct net *net, struct sk_buff *skb, u32 dnode,\n\t\t       u32 selector)\n{\n\tstruct sk_buff_head head;\n\t__skb_queue_head_init(&head);\n\t__skb_queue_tail(&head, skb);\n\ttipc_node_xmit(net, &head, dnode, selector);\n\treturn 0;\n}", "target": 0}
{"code": "static int fdc_configure(void)\n{\n\toutput_byte(FD_CONFIGURE);\n\tif (need_more_output() != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(0);\n\toutput_byte(0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(0);\t\t\n\treturn 1;\n}", "target": 0}
{"code": "get_scaled_rgb_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr) sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR * bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  if (! ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[UCH(*bufferptr++)];\n    *ptr++ = rescale[UCH(*bufferptr++)];\n    *ptr++ = rescale[UCH(*bufferptr++)];\n  }\n  return 1;\n}", "target": 0}
{"code": "sg_add_sfp(Sg_device * sdp)\n{\n\tSg_fd *sfp;\n\tunsigned long iflags;\n\tint bufflen;\n\tsfp = kzalloc(sizeof(*sfp), GFP_ATOMIC | __GFP_NOWARN);\n\tif (!sfp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_waitqueue_head(&sfp->read_wait);\n\trwlock_init(&sfp->rq_list_lock);\n\tINIT_LIST_HEAD(&sfp->rq_list);\n\tkref_init(&sfp->f_ref);\n\tmutex_init(&sfp->f_mutex);\n\tsfp->timeout = SG_DEFAULT_TIMEOUT;\n\tsfp->timeout_user = SG_DEFAULT_TIMEOUT_USER;\n\tsfp->force_packid = SG_DEF_FORCE_PACK_ID;\n\tsfp->cmd_q = SG_DEF_COMMAND_Q;\n\tsfp->keep_orphan = SG_DEF_KEEP_ORPHAN;\n\tsfp->parentdp = sdp;\n\twrite_lock_irqsave(&sdp->sfd_lock, iflags);\n\tif (atomic_read(&sdp->detaching)) {\n\t\twrite_unlock_irqrestore(&sdp->sfd_lock, iflags);\n\t\tkfree(sfp);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tlist_add_tail(&sfp->sfd_siblings, &sdp->sfds);\n\twrite_unlock_irqrestore(&sdp->sfd_lock, iflags);\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_add_sfp: sfp=0x%p\\n\", sfp));\n\tif (unlikely(sg_big_buff != def_reserved_size))\n\t\tsg_big_buff = def_reserved_size;\n\tbufflen = min_t(int, sg_big_buff,\n\t\t\tmax_sectors_bytes(sdp->device->request_queue));\n\tsg_build_reserve(sfp, bufflen);\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_add_sfp: bufflen=%d, k_use_sg=%d\\n\",\n\t\t\t\t      sfp->reserve.bufflen,\n\t\t\t\t      sfp->reserve.k_use_sg));\n\tkref_get(&sdp->d_ref);\n\t__module_get(THIS_MODULE);\n\treturn sfp;\n}", "target": 0}
{"code": "OriginIdentifierValueMap* ContentSettingsStore::GetValueMap(\n    const std::string& ext_id,\n    ExtensionPrefsScope scope) {\n  ExtensionEntryMap::const_iterator i = FindEntry(ext_id);\n  if (i != entries_.end()) {\n    switch (scope) {\n      case kExtensionPrefsScopeRegular:\n        return &(i->second->settings);\n      case kExtensionPrefsScopeRegularOnly:\n        NOTREACHED();\n        return NULL;\n      case kExtensionPrefsScopeIncognitoPersistent:\n        return &(i->second->incognito_persistent_settings);\n      case kExtensionPrefsScopeIncognitoSessionOnly:\n        return &(i->second->incognito_session_only_settings);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "value_topo_info<valtype>::propagate_effects ()\n{\n  ipcp_value<valtype> *base;\n  for (base = values_topo; base; base = base->topo_next)\n    {\n      ipcp_value_source<valtype> *src;\n      ipcp_value<valtype> *val;\n      int time = 0, size = 0;\n      for (val = base; val; val = val->scc_next)\n\t{\n\t  time = safe_add (time,\n\t\t\t   val->local_time_benefit + val->prop_time_benefit);\n\t  size = safe_add (size, val->local_size_cost + val->prop_size_cost);\n\t}\n      for (val = base; val; val = val->scc_next)\n\tfor (src = val->sources; src; src = src->next)\n\t  if (src->val\n\t      && src->cs->maybe_hot_p ())\n\t    {\n\t      src->val->prop_time_benefit = safe_add (time,\n\t\t\t\t\t\tsrc->val->prop_time_benefit);\n\t      src->val->prop_size_cost = safe_add (size,\n\t\t\t\t\t\t   src->val->prop_size_cost);\n\t    }\n    }\n}", "target": 0}
{"code": "static int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}", "target": 0}
{"code": "static int smac_nparam(enum pp_token_type toktype)\n{\n    return toktype - TOK_SMAC_START_PARAMS;\n}", "target": 0}
{"code": "static int set_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tkvm->arch.hv_guest_os_id = data;\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tkvm->arch.hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\tkvm->arch.hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; \n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\tkvm->arch.hv_hypercall = data;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "xsltRestoreDocumentNamespaces(xsltNsMapPtr ns, xmlDocPtr doc)\n{\n    if (doc == NULL)\n\treturn(-1);\n    while (ns != NULL) {\n\tif ((ns->doc == doc) && (ns->ns != NULL)) {\n\t    ns->ns->href = ns->origNsName;\n\t    ns->origNsName = NULL;\n\t    ns->ns = NULL;\t    \n\t}\n\tns = ns->next;\n    }\n    return(0);\n}", "target": 0}
{"code": "static int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\targv_free(re);\n\treturn ret;\n}", "target": 0}
{"code": "static int check_stack_access(struct bpf_verifier_env *env,\n\t\t\t      const struct bpf_reg_state *reg,\n\t\t\t      int off, int size)\n{\n\tif (!tnum_is_const(reg->var_off)) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\\n\",\n\t\t\ttn_buf, off, size);\n\t\treturn -EACCES;\n\t}\n\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static js_Function *newfun(js_State *J, js_Ast *name, js_Ast *params, js_Ast *body, int script)\n{\n\tjs_Function *F = js_malloc(J, sizeof *F);\n\tmemset(F, 0, sizeof *F);\n\tF->gcmark = 0;\n\tF->gcnext = J->gcfun;\n\tJ->gcfun = F;\n\t++J->gccounter;\n\tF->filename = js_intern(J, J->filename);\n\tF->line = name ? name->line : params ? params->line : body ? body->line : 1;\n\tF->script = script;\n\tF->name = name ? name->string : \"\";\n\tcfunbody(J, F, name, params, body);\n\treturn F;\n}", "target": 0}
{"code": "static int _clua_loadfile(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n    const int err = CLua::loadfile(ls, file, !CLua::is_managed_vm(ls));\n    if (err)\n    {\n        const int place = lua_gettop(ls);\n        lua_pushnil(ls);\n        lua_insert(ls, place);\n        return 2;\n    }\n    return 1;\n}", "target": 0}
{"code": "sg_poll(struct file *filp, poll_table * wait)\n{\n\tunsigned int res = 0;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint count = 0;\n\tunsigned long iflags;\n\tsfp = filp->private_data;\n\tif (!sfp)\n\t\treturn POLLERR;\n\tsdp = sfp->parentdp;\n\tif (!sdp)\n\t\treturn POLLERR;\n\tpoll_wait(filp, &sfp->read_wait, wait);\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tfor (srp = sfp->headrp; srp; srp = srp->nextrp) {\n\t\tif ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))\n\t\t\tres = POLLIN | POLLRDNORM;\n\t\t++count;\n\t}\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\tif (atomic_read(&sdp->detaching))\n\t\tres |= POLLHUP;\n\telse if (!sfp->cmd_q) {\n\t\tif (0 == count)\n\t\t\tres |= POLLOUT | POLLWRNORM;\n\t} else if (count < SG_MAX_QUEUE)\n\t\tres |= POLLOUT | POLLWRNORM;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_poll: res=0x%x\\n\", (int) res));\n\treturn res;\n}", "target": 0}
{"code": "static int pptp_write(struct triton_md_handler_t *h)\n{\n\tstruct pptp_conn_t *conn = container_of(h, typeof(*conn), hnd);\n\tint n;\n\twhile (1) {\n\t\tn = write(h->fd, conn->out_buf+conn->out_pos, conn->out_size-conn->out_pos);\n\t\tif (n < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tn = 0;\n\t\t\telse {\n\t\t\t\tif (errno != EPIPE) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_ppp_info2(\"pptp: post_msg: %s\\n\", strerror(errno));\n\t\t\t\t}\n\t\t\t\tdisconnect(conn);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tconn->out_pos += n;\n\t\tif (conn->out_pos == conn->out_size) {\n\t\t\tconn->out_pos = 0;\n\t\t\tconn->out_size = 0;\n\t\t\ttriton_md_disable_handler(h, MD_MODE_WRITE);\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void record_subpages_vmas(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t int refs, struct page **pages,\n\t\t\t\t struct vm_area_struct **vmas)\n{\n\tint nr;\n\tfor (nr = 0; nr < refs; nr++) {\n\t\tif (likely(pages))\n\t\t\tpages[nr] = mem_map_offset(page, nr);\n\t\tif (vmas)\n\t\t\tvmas[nr] = vma;\n\t}\n}", "target": 0}
{"code": "\tnamespace { bool numeric(char c) { return c >= '0' && c <= '9'; } }", "target": 0}
{"code": "AP_DECLARE(int) ap_if_walk(request_rec *r)\n{\n    core_dir_config *dconf = ap_get_core_module_config(r->per_dir_config);\n    int status = ap_if_walk_sub(r, dconf);\n    return status;\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoDrawArrays(\n    GLenum mode, GLint first, GLsizei count) {\n  if (first < 0) {\n    SetGLError(GL_INVALID_ENUM, \"glDrawArrays: first < 0\");\n    return;\n  }\n  if (IsDrawValid(first + count - 1)) {\n    bool simulated_attrib_0 = SimulateAttrib0(first + count - 1);\n    bool textures_set = SetBlackTextureForNonRenderableTextures();\n    glDrawArrays(mode, first, count);\n    if (textures_set) {\n      RestoreStateForNonRenderableTextures();\n    }\n    if (simulated_attrib_0) {\n      RestoreStateForSimulatedAttrib0();\n    }\n  }\n}", "target": 0}
{"code": "static jas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}", "target": 0}
{"code": "void RenderView::CapturePageInfo(int load_id, bool preliminary_capture) {\n  if (load_id != page_id_)\n    return;  \n  if (load_id == last_indexed_page_id_)\n    return;  \n  if (!webview())\n    return;\n  WebFrame* main_frame = webview()->mainFrame();\n  if (!main_frame)\n    return;\n  if (main_frame->isViewSourceModeEnabled())\n    return;\n  WebDataSource* ds = main_frame->dataSource();\n  if (ds && ds->hasUnreachableURL())\n    return;\n  if (!preliminary_capture)\n    last_indexed_page_id_ = load_id;\n  GURL url(main_frame->url());\n  if (url.is_empty())\n    return;\n  string16 contents;\n  CaptureText(main_frame, &contents);\n  if (contents.size()) {\n    base::TimeTicks begin_time = base::TimeTicks::Now();\n    std::string language = DetermineTextLanguage(contents);\n    UMA_HISTOGRAM_MEDIUM_TIMES(\"Renderer4.LanguageDetection\",\n                               base::TimeTicks::Now() - begin_time);\n    WebKit::WebDocument document = main_frame->document();\n    Send(new ViewHostMsg_PageContents(routing_id_, url, load_id, contents,\n                                      language, IsPageTranslatable(&document)));\n  }\n  OnCaptureThumbnail();\n}", "target": 0}
{"code": "    **/\n    CImg<T>& sinc() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=2048))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)cimg::sinc((double)*ptrd);\n      return *this;", "target": 0}
{"code": "static void fuse_prepare_interrupt(struct fuse *f, fuse_req_t req,\n                                          struct fuse_intr_data *d)\n{\n    if (f->conf.intr)\n        fuse_do_prepare_interrupt(req, d);\n}", "target": 0}
{"code": "static unsigned long stack_maxrandom_size(void)\n{\n\tunsigned long max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 0}
{"code": "static ssize_t demote_size_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint nid;\n\tstruct hstate *h = kobj_to_hstate(kobj, &nid);\n\tunsigned long demote_size = (PAGE_SIZE << h->demote_order) / SZ_1K;\n\treturn sysfs_emit(buf, \"%lukB\\n\", demote_size);\n}", "target": 0}
{"code": "copyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  size_t charsRequired = 0;\n  XML_Char *result;\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  charsRequired++;\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n  if (result == NULL)\n    return NULL;\n  memcpy(result, s, charsRequired * sizeof(XML_Char));\n  return result;\n}", "target": 0}
{"code": "void BrowserTitlebar::Throbber::Reset() {\n  current_frame_ = 0;\n  current_waiting_frame_ = 0;\n}", "target": 0}
{"code": "static int ldapsrv_mod_with_controls(struct ldapsrv_call *call,\n\t\t\t\t     const struct ldb_message *message,\n\t\t\t\t     struct ldb_control **controls,\n\t\t\t\t     struct ldb_result *res)\n{\n\tstruct ldb_context *ldb = call->conn->ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\tret = ldb_msg_sanity_check(ldb, message);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = ldb_build_mod_req(&req, ldb, ldb,\n\t\t\t\t\tmessage,\n\t\t\t\t\tcontrols,\n\t\t\t\t\tres,\n\t\t\t\t\tldb_modify_default_callback,\n\t\t\t\t\tNULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (call->conn->global_catalog) {\n\t\treturn ldb_error(ldb, LDB_ERR_UNWILLING_TO_PERFORM, \"modify forbidden on global catalog port\");\n\t}\n\tldb_request_add_control(req, DSDB_CONTROL_NO_GLOBAL_CATALOG, false, NULL);\n\tret = ldb_transaction_start(ldb);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (!call->conn->is_privileged) {\n\t\tldb_req_mark_untrusted(req);\n\t}\n\tLDB_REQ_SET_LOCATION(req);\n\tret = ldb_request(ldb, req);\n\tif (ret == LDB_SUCCESS) {\n\t\tret = ldb_wait(req->handle, LDB_WAIT_ALL);\n\t}\n\tif (ret == LDB_SUCCESS) {\n\t\tret = ldb_transaction_commit(ldb);\n\t}\n\telse {\n\t\tldb_transaction_cancel(ldb);\n\t}\n\ttalloc_free(req);\n\treturn ret;\n}", "target": 0}
{"code": "xb_mysql_query(MYSQL *connection, const char *query, bool use_result,\n\t\tbool die_on_error)\n{\n\tMYSQL_RES *mysql_result = NULL;\n\tif (mysql_query(connection, query)) {\n\t\tmsg(\"Error: failed to execute query '%s': %u (%s) %s\\n\", query,\n\t\t    mysql_errno(connection),\n\t\t    mysql_errno_to_sqlstate(mysql_errno(connection)),\n\t\t    mysql_error(connection));\n\t\tif (die_on_error) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn(NULL);\n\t}\n\tif (mysql_field_count(connection) > 0) {\n\t\tif ((mysql_result = mysql_store_result(connection)) == NULL) {\n\t\t\tmsg(\"Error: failed to fetch query result %s: %s\\n\",\n\t\t\t    query, mysql_error(connection));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (!use_result) {\n\t\t\tmysql_free_result(mysql_result);\n\t\t}\n\t}\n\treturn mysql_result;\n}", "target": 0}
{"code": "double LibRaw::getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n  switch (type)\n  {\n  case 3: \n    return (unsigned short)get2();\n  case 4: \n    return (unsigned int)get4();\n  case 5: \n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8: \n    return (signed short)get2();\n  case 9: \n    return (signed int)get4();\n  case 10: \n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11: \n    return int_to_float(get4());\n  case 12: \n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}", "target": 0}
{"code": "list_smacro_def(enum preproc_token op, const Context *ctx, const SMacro *m)\n{\n    Token *t;\n    size_t namelen, size;\n    char *def, *p;\n    char *context_prefix = NULL;\n    size_t context_len;\n    namelen = strlen(m->name);\n    size = namelen + 2;  \n    if (ctx) {\n        int context_depth = cstk->depth - ctx->depth + 1;\n        context_prefix =\n            nasm_asprintf(\"[%s::%\"PRIu64\"] %%%-*s\",\n                          ctx->name ? ctx->name : \"\",\n                          ctx->number, context_depth, \"\");\n        context_len = nasm_last_string_len();\n        memset(context_prefix + context_len - context_depth,\n               '$', context_depth);\n        size += context_len;\n    }\n    list_for_each(t, m->expansion)\n        size += t->len;\n    if (m->nparam) {\n        int i;\n        size += 1 + 4 * m->nparam;\n        for (i = 0; i < m->nparam; i++)\n            size += m->params[i].name.len;\n    }\n    def = nasm_malloc(size);\n    p = def+size;\n    *--p = '\\0';\n    list_for_each(t, m->expansion) {\n\tp -= t->len;\n\tmemcpy(p, tok_text(t), t->len);\n    }\n    *--p = ' ';\n    if (m->nparam) {\n        int i;\n        *--p = ')';\n        for (i = m->nparam-1; i >= 0; i--) {\n            enum sparmflags flags = m->params[i].flags;\n            if (flags & SPARM_GREEDY)\n                *--p = '+';\n\t    p -= m->params[i].name.len;\n\t    memcpy(p, tok_text(&m->params[i].name), m->params[i].name.len);\n            if (flags & SPARM_NOSTRIP)\n                *--p = '!';\n            if (flags & SPARM_STR)\n                *--p = '&';\n            if (flags & SPARM_EVAL)\n                *--p = '=';\n            *--p = ',';\n        }\n        *p = '(';               \n    }\n    p -= namelen;\n    memcpy(p, m->name, namelen);\n    if (context_prefix) {\n        p -= context_len;\n        memcpy(p, context_prefix, context_len);\n        nasm_free(context_prefix);\n    }\n    nasm_listmsg(\"%s %s\", pp_directives[op], p);\n    nasm_free(def);\n}", "target": 0}
{"code": "\tbool operator !() const { return !m_ptr; }", "target": 0}
{"code": "static void imap_client_destroy(struct client *client)\n{\n\tstruct imap_client *imap_client = (struct imap_client *)client;\n\ti_free_and_null(imap_client->proxy_backend_capability);\n\timap_parser_unref(&imap_client->parser);\n}", "target": 0}
{"code": "bool cond_is_datetime_is_null(Item *cond)\n{\n  if (cond->type() == Item::FUNC_ITEM &&\n      ((Item_func*) cond)->functype() == Item_func::ISNULL_FUNC)\n  {\n    return ((Item_func_isnull*) cond)->arg_is_datetime_notnull_field();\n  }\n  return false;\n}", "target": 0}
{"code": "HttpStateData::doneSendingRequestBody()\n{\n    Client::doneSendingRequestBody();\n    debugs(11,5, HERE << serverConnection);\n    if (flags.chunked_request && finishingChunkedRequest())\n        return;\n    if (!flags.chunked_request && finishingBrokenPost())\n        return;\n    sendComplete();\n}", "target": 0}
{"code": "void RenderFrameHostImpl::ExecuteCustomContextMenuCommand(\n    int action, const CustomContextMenuContext& context) {\n  Send(new FrameMsg_CustomContextMenuAction(routing_id_, context, action));\n}", "target": 0}
{"code": "void PDFiumEngine::PaintUnavailablePage(int page_index,\n                                        const pp::Rect& dirty,\n                                        pp::ImageData* image_data) {\n  int start_x, start_y, size_x, size_y;\n  GetPDFiumRect(page_index, dirty, &start_x, &start_y, &size_x, &size_y);\n  FPDF_BITMAP bitmap = CreateBitmap(dirty, image_data);\n  FPDFBitmap_FillRect(bitmap, start_x, start_y, size_x, size_y,\n                      kPendingPageColor);\n  pp::Rect loading_text_in_screen(\n      pages_[page_index]->rect().width() / 2,\n      pages_[page_index]->rect().y() + kLoadingTextVerticalOffset, 0, 0);\n  loading_text_in_screen = GetScreenRect(loading_text_in_screen);\n  FPDFBitmap_Destroy(bitmap);\n}", "target": 0}
{"code": "static inline struct sk_buff *dev_dequeue_skb(struct net_device *dev,\n\t\t\t\t\t      struct Qdisc *q)\n{\n\tstruct sk_buff *skb;\n\tif ((skb = dev->gso_skb))\n\t\tdev->gso_skb = NULL;\n\telse\n\t\tskb = q->dequeue(q);\n\treturn skb;\n}", "target": 0}
{"code": "static blkid_partlist partitions_init_data(struct blkid_chain *chn)\n{\n\tblkid_partlist ls;\n\tif (chn->data)\n\t\tls = (blkid_partlist) chn->data;\n\telse {\n\t\tls = calloc(1, sizeof(struct blkid_struct_partlist));\n\t\tif (!ls)\n\t\t\treturn NULL;\n\t\tchn->data = (void *) ls;\n\t}\n\treset_partlist(ls);\n\tDBG(LOWPROBE, ul_debug(\"parts: initialized partitions list (%p, size=%d)\",\n\t\tls, ls->nparts_max));\n\treturn ls;\n}", "target": 0}
{"code": "void LinkResolver::resolve_handle_call(CallInfo& result,\n                                       const LinkInfo& link_info,\n                                       TRAPS) {\n  Klass* resolved_klass = link_info.resolved_klass();\n  assert(resolved_klass == vmClasses::MethodHandle_klass() ||\n         resolved_klass == vmClasses::VarHandle_klass(), \"\");\n  assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), \"\");\n  Handle resolved_appendix;\n  Method* m = lookup_polymorphic_method(link_info, &resolved_appendix, CHECK);\n  methodHandle resolved_method(THREAD, m);\n  if (link_info.check_access()) {\n    Symbol* name = link_info.name();\n    vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);\n    if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {\n      assert(iid == vmIntrinsicID::_invokeBasic, \"%s\", vmIntrinsics::name_at(iid));\n      Klass* current_klass = link_info.current_klass();\n      assert(current_klass != NULL , \"current_klass should not be null\");\n      check_method_accessability(current_klass,\n                                 resolved_klass,\n                                 resolved_method->method_holder(),\n                                 resolved_method,\n                                 CHECK);\n    } else {\n      assert(iid == vmIntrinsics::_invokeGeneric, \"not an invoker: %s\", vmIntrinsics::name_at(iid));\n      assert(MethodHandles::is_signature_polymorphic_public_name(resolved_klass, name), \"not public\");\n    }\n  }\n  result.set_handle(resolved_klass, resolved_method, resolved_appendix, CHECK);\n}", "target": 0}
{"code": "irc_server_msgq_add_msg (struct t_irc_server *server, const char *msg)\n{\n    struct t_irc_message *message;\n    if (!server->unterminated_message && !msg[0])\n        return;\n    message = malloc (sizeof (*message));\n    if (!message)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: not enough memory for received message\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return;\n    }\n    message->server = server;\n    if (server->unterminated_message)\n    {\n        message->data = malloc (strlen (server->unterminated_message) +\n                                strlen (msg) + 1);\n        if (!message->data)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n        else\n        {\n            strcpy (message->data, server->unterminated_message);\n            strcat (message->data, msg);\n        }\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    else\n        message->data = strdup (msg);\n    message->next_message = NULL;\n    if (irc_msgq_last_msg)\n    {\n        irc_msgq_last_msg->next_message = message;\n        irc_msgq_last_msg = message;\n    }\n    else\n    {\n        irc_recv_msgq = message;\n        irc_msgq_last_msg = message;\n    }\n}", "target": 0}
{"code": "assert_curl_state(const CurlObject *self)\n{\n    assert(self != NULL);\n    assert(Py_TYPE(self) == p_Curl_Type);\n#ifdef WITH_THREAD\n    (void) pycurl_get_thread_state(self);\n#endif\n}", "target": 0}
{"code": "RecordSwapRanges(xRecordRange * pRanges, int nRanges)\n{\n    int i;\n    for (i = 0; i < nRanges; i++, pRanges++) {\n        swaps(&pRanges->extRequestsMinorFirst);\n        swaps(&pRanges->extRequestsMinorLast);\n        swaps(&pRanges->extRepliesMinorFirst);\n        swaps(&pRanges->extRepliesMinorLast);\n    }\n}                               ", "target": 0}
{"code": "  void MaybeCopyDisableWebRtcEncryptionSwitch(version_info::Channel channel) {\n    ChromeContentBrowserClient::MaybeCopyDisableWebRtcEncryptionSwitch(\n        &to_command_line_,\n        from_command_line_,\n        channel);\n  }", "target": 0}
{"code": "int lcc_network_buffer_add_value (lcc_network_buffer_t *nb, \n    const lcc_value_list_t *vl)\n{\n  int status;\n  if ((nb == NULL) || (vl == NULL))\n    return (EINVAL);\n  status = nb_add_value_list (nb, vl);\n  return (status);\n} ", "target": 0}
{"code": "unsigned char* lodepng_chunk_data(unsigned char* chunk)\n{\n  return &chunk[8];\n}", "target": 0}
{"code": "int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(\n    SiteInstance* instance) {\n  if (!opener_)\n    return MSG_ROUTING_NONE;\n  return opener_->CreateOpenerRenderViews(instance);\n}", "target": 0}
{"code": "void BaseAudioContext::ScheduleMainThreadCleanup() {\n  if (has_posted_cleanup_task_)\n    return;\n  PostCrossThreadTask(\n      *task_runner_, FROM_HERE,\n      CrossThreadBind(&BaseAudioContext::PerformCleanupOnMainThread,\n                      WrapCrossThreadPersistent(this)));\n  has_posted_cleanup_task_ = true;\n}", "target": 0}
{"code": "PHP_FUNCTION(pow)\n{\n\tzval *zbase, *zexp;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z/z/\", &zbase, &zexp) == FAILURE) {\n\t\treturn;\n\t}\n\tpow_function(return_value, zbase, zexp TSRMLS_CC);\n}", "target": 0}
{"code": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}", "target": 0}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\t\t\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "static inline void ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n}", "target": 0}
{"code": "mrb_generate_code(mrb_state *mrb, parser_state *p)\n{\n  return generate_code(mrb, p, VAL);\n}", "target": 0}
{"code": "static int mark_reg_read(struct bpf_verifier_env *env,\n\t\t\t const struct bpf_verifier_state *state,\n\t\t\t struct bpf_verifier_state *parent,\n\t\t\t u32 regno)\n{\n\tbool writes = parent == state->parent; \n\tif (regno == BPF_REG_FP)\n\t\treturn 0;\n\twhile (parent) {\n\t\tif (writes && state->frame[state->curframe]->regs[regno].live & REG_LIVE_WRITTEN)\n\t\t\tbreak;\n\t\tparent = skip_callee(env, state, parent, regno);\n\t\tif (!parent)\n\t\t\treturn -EFAULT;\n\t\tparent->frame[parent->curframe]->regs[regno].live |= REG_LIVE_READ;\n\t\tstate = parent;\n\t\tparent = state->parent;\n\t\twrites = true;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "uint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\thval ^= (uint64_t)*bp;\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\treturn hval;\n}", "target": 0}
{"code": "intel_engine_in_execlists_submission_mode(const struct intel_engine_cs *engine)\n{\n\treturn engine->set_default_submission ==\n\t       intel_execlists_set_default_submission;\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE5(preadv, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\treturn __compat_sys_preadv64(fd, vec, vlen, pos);\n}", "target": 0}
{"code": "bool HTMLInputElement::sizeShouldIncludeDecoration(int& preferredSize) const\n{\n    return m_inputTypeView->sizeShouldIncludeDecoration(defaultSize, preferredSize);\n}", "target": 0}
{"code": "static void *mntns_get(struct task_struct *task)\n{\n\tstruct mnt_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->mnt_ns;\n\t\tget_mnt_ns(ns);\n\t}\n\ttask_unlock(task);\n\treturn ns;\n}", "target": 0}
{"code": "static void cma_cancel_listens(struct rdma_id_private *id_priv)\n{\n\tmutex_lock(&lock);\n\t_cma_cancel_listens(id_priv);\n\tmutex_unlock(&lock);\n}", "target": 0}
{"code": "Item_result Item_type_holder::result_type() const\n{\n  return Field::result_merge_type(fld_type);\n}", "target": 0}
{"code": "MenuCache* menu_cache_lookup( const char* menu_name )\n{\n    MenuCache* cache;\n    MENU_CACHE_LOCK;\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    if(!sync_run_mutex)\n        sync_run_mutex = g_mutex_new();\n    if(!sync_run_cond)\n        sync_run_cond = g_cond_new();\n#endif\n    if( G_UNLIKELY( ! hash ) )\n        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL );\n    else\n    {\n        cache = (MenuCache*)g_hash_table_lookup(hash, menu_name);\n        if( cache )\n        {\n            menu_cache_ref(cache);\n            MENU_CACHE_UNLOCK;\n            return cache;\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    cache = menu_cache_create(menu_name);\n    cache->cancellable = g_cancellable_new();\n#if GLIB_CHECK_VERSION(2, 32, 0)\n    cache->thr = g_thread_new(menu_name, menu_cache_loader_thread, cache);\n#else\n    cache->thr = g_thread_create(menu_cache_loader_thread, cache, TRUE, NULL);\n#endif\n    return cache;\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfaceless::PendingFrame::ScheduleOverlayPlanes(\n    gfx::AcceleratedWidget widget) {\n  for (const auto& overlay : overlays)\n    if (!overlay.ScheduleOverlayPlane(widget))\n      return false;\n  return true;\n}", "target": 0}
{"code": "char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tstruct buf *link;\n\tsize_t link_len, rewind;\n\tif (!rndr->cb.autolink || rndr->in_link_body)\n\t\treturn 0;\n\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\tif ((link_len = sd_autolink__email(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tob->size -= rewind;\n\t\trndr->cb.autolink(ob, link, MKDA_EMAIL, rndr->opaque);\n\t}\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\treturn link_len;\n}", "target": 0}
{"code": "int EditorClientBlackBerry::spellCheckerDocumentTag()\n{\n    notImplemented();\n    return 0;\n}", "target": 0}
{"code": "  HeaderMap::GetResult getAll(const LowerCaseString& key) const override {\n    return HeaderMapImpl::getAll(key);\n  }", "target": 0}
{"code": "ff_layout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs4_flexfile_layout *ffl = FF_LAYOUT_FROM_HDR(lo);\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\tlist_for_each_entry_safe(err, n, &ffl->error_list, list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\tkfree_rcu(ffl, generic_hdr.plh_rcu);\n}", "target": 0}
{"code": "Field *Item::create_tmp_field_int(TABLE *table, uint convert_int_length)\n{\n  const Type_handler *h= &type_handler_long;\n  if (max_char_length() > convert_int_length)\n    h= &type_handler_longlong;\n  return h->make_and_init_table_field(&name, Record_addr(maybe_null),\n                                      *this, table);\n}", "target": 0}
{"code": "static void openssl_thread_setup(void)\n{\n    int i;\n    if (CRYPTO_get_locking_callback() != NULL) {\n        red_dump_openssl_errors();\n        return;\n    }\n    lock_cs = (pthread_mutex_t*) OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n        pthread_mutex_init(&(lock_cs[i]), NULL);\n    }\n    CRYPTO_THREADID_set_callback(pthreads_thread_id);\n    CRYPTO_set_locking_callback(pthreads_locking_callback);\n}", "target": 0}
{"code": "static inline void SetSlabDebug(struct page *page)\n{\n\tpage->flags |= SLABDEBUG;\n}", "target": 0}
{"code": "int LibRaw::find_ifd_by_offset(int o)\n{\n    for(int i = 0; i < libraw_internal_data.identify_data.tiff_nifds && i < LIBRAW_IFD_MAXCOUNT; i++)\n        if(tiff_ifd[i].offset == o)\n            return i;\n    return -1;\n}", "target": 0}
{"code": "process_new_pointer_pdu(STREAM s)\n{\n\tint xor_bpp;\n\tin_uint16_le(s, xor_bpp);\n\tprocess_colour_pointer_common(s, xor_bpp);\n}", "target": 0}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 0}
{"code": "acpi_parse_lapic(acpi_table_entry_header * header, const unsigned long end)\n{\n\tstruct acpi_table_lapic *processor = NULL;\n\tprocessor = (struct acpi_table_lapic *)header;\n\tif (BAD_MADT_ENTRY(processor, end))\n\t\treturn -EINVAL;\n\tacpi_table_print_madt_entry(header);\n\tif (processor->flags.enabled)\n\t\tx86_acpiid_to_apicid[processor->acpi_id] = processor->id;\n\tmp_register_lapic(processor->id,\t\n\t\t\t  processor->flags.enabled);\t\n\treturn 0;\n}", "target": 0}
{"code": "TEST(SegmentSumOpModelTest, Float32Test_Simple) {\n  SegmentSumOpModel<float> model({TensorType_FLOAT32, {3, 4}},\n                                 {TensorType_INT32, {3}});\n  model.PopulateTensor<float>(model.data(),\n                              {1, 2, 3, 4, 4, 3, 2, 1, 5, 6, 7, 8});\n  model.PopulateTensor<int>(model.segment_ids(), {0, 0, 1});\n  model.Invoke();\n  EXPECT_THAT(model.GetOutput(), ElementsAreArray({5.0f, 5.0f, 5.0f, 5.0f, 5.0f,\n                                                   6.0f, 7.0f, 8.0f}));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAreArray({2, 4}));\n}", "target": 0}
{"code": "DECLAREcpFunc(cpContigTiles2SeparateStrips)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToSeparateStrips,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "   Returns the results of the C system call localtime as an associative array if the associative_array argument is set to 1 other wise it is a regular array */\nPHP_FUNCTION(localtime)\n{\n\tlong timestamp = (long)time(NULL);\n\tzend_bool associative = 0;\n\ttimelib_tzinfo *tzi;\n\ttimelib_time   *ts;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|lb\", &timestamp, &associative) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\ttzi = get_timezone_info(TSRMLS_C);\n\tts = timelib_time_ctor();\n\tts->tz_info = tzi;\n\tts->zone_type = TIMELIB_ZONETYPE_ID;\n\ttimelib_unixtime2local(ts, (timelib_sll) timestamp);\n\tarray_init(return_value);\n\tif (associative) {\n\t\tadd_assoc_long(return_value, \"tm_sec\",   ts->s);\n\t\tadd_assoc_long(return_value, \"tm_min\",   ts->i);\n\t\tadd_assoc_long(return_value, \"tm_hour\",  ts->h);\n\t\tadd_assoc_long(return_value, \"tm_mday\",  ts->d);\n\t\tadd_assoc_long(return_value, \"tm_mon\",   ts->m - 1);\n\t\tadd_assoc_long(return_value, \"tm_year\",  ts->y - 1900);\n\t\tadd_assoc_long(return_value, \"tm_wday\",  timelib_day_of_week(ts->y, ts->m, ts->d));\n\t\tadd_assoc_long(return_value, \"tm_yday\",  timelib_day_of_year(ts->y, ts->m, ts->d));\n\t\tadd_assoc_long(return_value, \"tm_isdst\", ts->dst);\n\t} else {\n\t\tadd_next_index_long(return_value, ts->s);\n\t\tadd_next_index_long(return_value, ts->i);\n\t\tadd_next_index_long(return_value, ts->h);\n\t\tadd_next_index_long(return_value, ts->d);\n\t\tadd_next_index_long(return_value, ts->m - 1);\n\t\tadd_next_index_long(return_value, ts->y- 1900);\n\t\tadd_next_index_long(return_value, timelib_day_of_week(ts->y, ts->m, ts->d));\n\t\tadd_next_index_long(return_value, timelib_day_of_year(ts->y, ts->m, ts->d));\n\t\tadd_next_index_long(return_value, ts->dst);\n\t}\n\ttimelib_time_dtor(ts);", "target": 0}
{"code": "HttpStateData::checkDateSkew(HttpReply *reply)\n{\n    if (reply->date > -1 && !_peer) {\n        int skew = abs((int)(reply->date - squid_curtime));\n        if (skew > 86400)\n            debugs(11, 3, \"\" << request->url.host() << \"'s clock is skewed by \" << skew << \" seconds!\");\n    }\n}", "target": 0}
{"code": "void tcp_valid_rtt_meas(struct sock *sk, u32 seq_rtt)\n{\n\ttcp_rtt_estimator(sk, seq_rtt);\n\ttcp_set_rto(sk);\n\tinet_csk(sk)->icsk_backoff = 0;\n}", "target": 0}
{"code": "static void vmxnet3_pci_realize(PCIDevice *pci_dev, Error **errp)\n{\n    VMXNET3State *s = VMXNET3(pci_dev);\n    int ret;\n    VMW_CBPRN(\"Starting init...\");\n    memory_region_init_io(&s->bar0, OBJECT(s), &b0_ops, s,\n                          \"vmxnet3-b0\", VMXNET3_PT_REG_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_BAR0_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar0);\n    memory_region_init_io(&s->bar1, OBJECT(s), &b1_ops, s,\n                          \"vmxnet3-b1\", VMXNET3_VD_REG_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_BAR1_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar1);\n    memory_region_init(&s->msix_bar, OBJECT(s), \"vmxnet3-msix-bar\",\n                       VMXNET3_MSIX_BAR_SIZE);\n    pci_register_bar(pci_dev, VMXNET3_MSIX_BAR_IDX,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->msix_bar);\n    vmxnet3_reset_interrupt_states(s);\n    pci_dev->config[PCI_INTERRUPT_PIN] = 0x01;\n    ret = msi_init(pci_dev, VMXNET3_MSI_OFFSET(s), VMXNET3_MAX_NMSIX_INTRS,\n                   VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK, NULL);\n    assert(!ret || ret == -ENOTSUP);\n    if (!vmxnet3_init_msix(s)) {\n        VMW_WRPRN(\"Failed to initialize MSI-X, configuration is inconsistent.\");\n    }\n    vmxnet3_net_init(s);\n    if (pci_is_express(pci_dev)) {\n        if (pci_bus_is_express(pci_get_bus(pci_dev))) {\n            pcie_endpoint_cap_init(pci_dev, VMXNET3_EXP_EP_OFFSET);\n        }\n        pcie_dev_ser_num_init(pci_dev, VMXNET3_DSN_OFFSET,\n                              vmxnet3_device_serial_num(s));\n    }\n}", "target": 0}
{"code": "void ThreadWatcher::OnPingMessage(const BrowserThread::ID& thread_id,\n                                  const base::Closure& callback_task) {\n  DCHECK(BrowserThread::CurrentlyOn(thread_id));\n  WatchDogThread::PostTask(FROM_HERE, callback_task);\n}", "target": 0}
{"code": "decode_NXAST_RAW_CT(const struct nx_action_conntrack *nac,\n                    enum ofp_version ofp_version,\n                    const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n                    struct ofpbuf *out)\n{\n    const size_t ct_offset = ofpacts_pull(out);\n    struct ofpact_conntrack *conntrack = ofpact_put_CT(out);\n    int error;\n    conntrack->flags = ntohs(nac->flags);\n    if (conntrack->flags & NX_CT_F_FORCE &&\n        !(conntrack->flags & NX_CT_F_COMMIT)) {\n        error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        goto out;\n    }\n    error = decode_ct_zone(nac, conntrack, vl_mff_map, tlv_bitmap);\n    if (error) {\n        goto out;\n    }\n    conntrack->recirc_table = nac->recirc_table;\n    conntrack->alg = ntohs(nac->alg);\n    ofpbuf_pull(out, sizeof(*conntrack));\n    struct ofpbuf openflow = ofpbuf_const_initializer(\n        nac + 1, ntohs(nac->len) - sizeof(*nac));\n    error = ofpacts_pull_openflow_actions__(&openflow, openflow.size,\n                                            ofp_version,\n                                            1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                            out, OFPACT_CT, vl_mff_map,\n                                            tlv_bitmap);\n    if (error) {\n        return error;\n    }\n    conntrack = ofpbuf_push_uninit(out, sizeof(*conntrack));\n    out->header = &conntrack->ofpact;\n    ofpact_finish_CT(out, &conntrack);\n    if (conntrack->ofpact.len > sizeof(*conntrack)\n        && !(conntrack->flags & NX_CT_F_COMMIT)) {\n        const struct ofpact *a;\n        size_t ofpacts_len = conntrack->ofpact.len - sizeof(*conntrack);\n        OFPACT_FOR_EACH (a, conntrack->actions, ofpacts_len) {\n            if (a->type != OFPACT_NAT || ofpact_get_NAT(a)->flags\n                || ofpact_get_NAT(a)->range_af != AF_UNSPEC) {\n                VLOG_WARN_RL(&rl, \"CT action requires commit flag if actions \"\n                             \"other than NAT without arguments are specified.\");\n                error = OFPERR_OFPBAC_BAD_ARGUMENT;\n                goto out;\n            }\n        }\n    }\nout:\n    ofpbuf_push_uninit(out, ct_offset);\n    return error;\n}", "target": 0}
{"code": "void SVGDocumentExtensions::markPendingResourcesForRemoval(const AtomicString& id)\n{\n    if (id.isEmpty())\n        return;\n    ASSERT(!m_pendingResourcesForRemoval.contains(id));\n    OwnPtr<SVGPendingElements> existing = m_pendingResources.take(id);\n    if (existing && !existing->isEmpty())\n        m_pendingResourcesForRemoval.add(id, existing.release());\n}", "target": 0}
{"code": "bool PpapiPluginProcessHost::Init(const content::PepperPluginInfo& info) {\n  plugin_path_ = info.path;\n  if (info.name.empty()) {\n    process_->SetName(plugin_path_.BaseName().LossyDisplayName());\n  } else {\n    process_->SetName(UTF8ToUTF16(info.name));\n  }\n  std::string channel_id = process_->GetHost()->CreateChannel();\n  if (channel_id.empty())\n    return false;\n  const CommandLine& browser_command_line = *CommandLine::ForCurrentProcess();\n  CommandLine::StringType plugin_launcher =\n      browser_command_line.GetSwitchValueNative(switches::kPpapiPluginLauncher);\n#if defined(OS_LINUX)\n  int flags = plugin_launcher.empty() ? ChildProcessHost::CHILD_ALLOW_SELF :\n                                        ChildProcessHost::CHILD_NORMAL;\n#else\n  int flags = ChildProcessHost::CHILD_NORMAL;\n#endif\n  FilePath exe_path = ChildProcessHost::GetChildPath(flags);\n  if (exe_path.empty())\n    return false;\n  CommandLine* cmd_line = new CommandLine(exe_path);\n  cmd_line->AppendSwitchASCII(switches::kProcessType,\n                              is_broker_ ? switches::kPpapiBrokerProcess\n                                         : switches::kPpapiPluginProcess);\n  cmd_line->AppendSwitchASCII(switches::kProcessChannelID, channel_id);\n  static const char* kCommonForwardSwitches[] = {\n    switches::kVModule\n  };\n  cmd_line->CopySwitchesFrom(browser_command_line, kCommonForwardSwitches,\n                             arraysize(kCommonForwardSwitches));\n  if (!is_broker_) {\n    static const char* kPluginForwardSwitches[] = {\n      switches::kNoSandbox,\n      switches::kDisableSeccompFilterSandbox,\n      switches::kPpapiFlashArgs,\n      switches::kPpapiStartupDialog\n    };\n    cmd_line->CopySwitchesFrom(browser_command_line, kPluginForwardSwitches,\n                               arraysize(kPluginForwardSwitches));\n  }\n  std::string locale =\n      content::GetContentClient()->browser()->GetApplicationLocale();\n  if (!locale.empty()) {\n    cmd_line->AppendSwitchASCII(switches::kLang, locale);\n  }\n  if (!plugin_launcher.empty())\n    cmd_line->PrependWrapper(plugin_launcher);\n#if defined(OS_POSIX)\n  bool use_zygote = !is_broker_ && plugin_launcher.empty() && info.is_sandboxed;\n  if (!info.is_sandboxed)\n    cmd_line->AppendSwitchASCII(switches::kNoSandbox, \"\");\n#endif  \n  process_->Launch(\n#if defined(OS_WIN)\n      FilePath(),\n#elif defined(OS_POSIX)\n      use_zygote,\n      base::EnvironmentVector(),\n#endif\n      cmd_line);\n  return true;\n}", "target": 0}
{"code": "static int find_large_solid_color_rect(VncState *vs, int x, int y,\n                                       int w, int h, int max_rows)\n{\n    int dx, dy, dw, dh;\n    int n = 0;\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n        if (dy - y >= max_rows) {\n            n += send_rect_simple(vs, x, y, w, max_rows, true);\n            y += max_rows;\n            h -= max_rows;\n        }\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, (y + h - dy));\n        for (dx = x; dx < x + w; dx += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n            uint32_t color_value;\n            int x_best, y_best, w_best, h_best;\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, (x + w - dx));\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color_value, false)) {\n                continue ;\n            }\n            find_best_solid_area(vs, dx, dy, w - (dx - x), h - (dy - y),\n                                 color_value, &w_best, &h_best);\n            if (w_best * h_best != w * h &&\n                w_best * h_best < VNC_TIGHT_MIN_SOLID_SUBRECT_SIZE) {\n                continue;\n            }\n            x_best = dx; y_best = dy;\n            extend_solid_area(vs, x, y, w, h, color_value,\n                              &x_best, &y_best, &w_best, &h_best);\n            if (y_best != y) {\n                n += send_rect_simple(vs, x, y, w, y_best-y, true);\n            }\n            if (x_best != x) {\n                n += tight_send_framebuffer_update(vs, x, y_best,\n                                                   x_best-x, h_best);\n            }\n            n += send_sub_rect_solid(vs, x_best, y_best, w_best, h_best);\n            if (x_best + w_best != x + w) {\n                n += tight_send_framebuffer_update(vs, x_best+w_best,\n                                                   y_best,\n                                                   w-(x_best-x)-w_best,\n                                                   h_best);\n            }\n            if (y_best + h_best != y + h) {\n                n += tight_send_framebuffer_update(vs, x, y_best+h_best,\n                                                   w, h-(y_best-y)-h_best);\n            }\n            return n;\n        }\n    }\n    return n + send_rect_simple(vs, x, y, w, h, true);\n}", "target": 0}
{"code": "static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct net_device *dev = idev->dev;\n\tstruct ifinfomsg *hdr;\n\tstruct nlmsghdr *nlh;\n\tvoid *protoinfo;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*hdr), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\thdr = nlmsg_data(nlh);\n\thdr->ifi_family = AF_INET6;\n\thdr->__ifi_pad = 0;\n\thdr->ifi_type = dev->type;\n\thdr->ifi_index = dev->ifindex;\n\thdr->ifi_flags = dev_get_flags(dev);\n\thdr->ifi_change = 0;\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)))\n\t\tgoto nla_put_failure;\n\tprotoinfo = nla_nest_start(skb, IFLA_PROTINFO);\n\tif (protoinfo == NULL)\n\t\tgoto nla_put_failure;\n\tif (inet6_fill_ifla6_attrs(skb, idev) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, protoinfo);\n\treturn nlmsg_end(skb, nlh);\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "void smp_link_encrypted(const RawAddress& bda, uint8_t encr_enable) {\n  tSMP_CB* p_cb = &smp_cb;\n  SMP_TRACE_DEBUG(\"%s: encr_enable=%d\", __func__, encr_enable);\n if (smp_cb.pairing_bda == bda) {\n if (p_cb->loc_enc_size != 0 && encr_enable) {\n      btm_ble_update_sec_key_size(bda, p_cb->loc_enc_size);\n }\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = encr_enable;\n    smp_sm_event(&smp_cb, SMP_ENCRYPTED_EVT, &smp_int_data);\n }\n}", "target": 0}
{"code": "vte_sequence_handler_ts (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->status_line = TRUE;\n\tterminal->pvt->screen->status_line_changed = TRUE;\n\tg_string_truncate(terminal->pvt->screen->status_line_contents, 0);\n}", "target": 0}
{"code": "static int ext4_try_to_expand_extra_isize(struct inode *inode,\n\t\t\t\t\t  unsigned int new_extra_isize,\n\t\t\t\t\t  struct ext4_iloc iloc,\n\t\t\t\t\t  handle_t *handle)\n{\n\tint no_expand;\n\tint error;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND))\n\t\treturn -EOVERFLOW;\n\tif (ext4_handle_valid(handle) &&\n\t    jbd2_journal_extend(handle,\n\t\t\t\tEXT4_DATA_TRANS_BLOCKS(inode->i_sb)) != 0)\n\t\treturn -ENOSPC;\n\tif (ext4_write_trylock_xattr(inode, &no_expand) == 0)\n\t\treturn -EBUSY;\n\terror = __ext4_expand_extra_isize(inode, new_extra_isize, &iloc,\n\t\t\t\t\t  handle, &no_expand);\n\text4_write_unlock_xattr(inode, &no_expand);\n\treturn error;\n}", "target": 0}
{"code": "static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,\n                              LodePNGCompressSettings* zlibsettings)\n{\n  ucvector zlibdata;\n  unsigned error = 0;\n  ucvector_init(&zlibdata);\n  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);\n  if(!error) error = addChunk(out, \"IDAT\", zlibdata.data, zlibdata.size);\n  ucvector_cleanup(&zlibdata);\n  return error;\n}", "target": 0}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "static void scalar_min_max_lsh(struct bpf_reg_state *dst_reg,\n\t\t\t       struct bpf_reg_state *src_reg)\n{\n\tu64 umax_val = src_reg->umax_value;\n\tu64 umin_val = src_reg->umin_value;\n\t__scalar64_min_max_lsh(dst_reg, umin_val, umax_val);\n\t__scalar32_min_max_lsh(dst_reg, umin_val, umax_val);\n\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t__update_reg_bounds(dst_reg);\n}", "target": 0}
{"code": "void kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "static void vvc_compute_poc(VVCSliceInfo *si, Bool poc_reset)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\tif (si->poc_msb_cycle_present_flag) {\n\t\tsi->poc_msb = si->poc_msb_cycle * max_poc_lsb;\n\t} else if (poc_reset) {\n\t\tsi->poc_msb = 0;\n\t} else {\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) && (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\t}\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}", "target": 0}
{"code": "long hugetlb_unreserve_pages(struct inode *inode, long start, long end,\n\t\t\t\t\t\t\t\tlong freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct resv_map *resv_map = inode_resv_map(inode);\n\tlong chg = 0;\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong gbl_reserve;\n\tif (resv_map) {\n\t\tchg = region_del(resv_map, start, end);\n\t\tif (chg < 0)\n\t\t\treturn chg;\n\t}\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\tgbl_reserve = hugepage_subpool_put_pages(spool, (chg - freed));\n\thugetlb_acct_memory(h, -gbl_reserve);\n\treturn 0;\n}", "target": 0}
{"code": "cdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = MAX(h->h_min_size_standard_stream, len);\n\tscn->sst_ss = ss;\n\tif (sid == CDF_SECID_END_OF_CHAIN || len == 0)\n\t\treturn cdf_zero_stream(scn);\n\tif (scn->sst_len == (size_t)-1)\n\t\tgoto out;\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != (ssize_t)ss) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}", "target": 0}
{"code": "    CImg<T>& XYZtoxyY() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"XYZtoxyY(): Instance is not a XYZ image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=4096))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          X = (Tfloat)p1[N],\n          Y = (Tfloat)p2[N],\n          Z = (Tfloat)p3[N],\n          sum = X + Y + Z,\n          nsum = sum>0?sum:1;\n        p1[N] = (T)(X/nsum);\n        p2[N] = (T)(Y/nsum);\n        p3[N] = (T)Y;\n      }\n      return *this;", "target": 0}
{"code": "static inline void GetNonpeakPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n  size_t\n    color,\n    next,\n    previous;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  next=p->nodes[color].next[0];\n  count=0;\n  do\n  {\n    previous=color;\n    color=next;\n    next=p->nodes[color].next[0];\n    count+=p->nodes[color].count;\n  } while (count <= (ssize_t) (pixel_list->length >> 1));\n  if ((previous == 65536UL) && (next != 65536UL))\n    color=next;\n  else\n    if ((previous != 65536UL) && (next == 65536UL))\n      color=previous;\n  *pixel=ScaleShortToQuantum((unsigned short) color);\n}", "target": 0}
{"code": "struct kvm_vcpu *preempt_notifier_to_vcpu(struct preempt_notifier *pn)\n{\n\treturn container_of(pn, struct kvm_vcpu, preempt_notifier);\n}", "target": 0}
{"code": "count_field_types(SELECT_LEX *select_lex, TMP_TABLE_PARAM *param, \n                  List<Item> &fields, bool reset_with_sum_func)\n{\n  List_iterator<Item> li(fields);\n  Item *field;\n  param->field_count=param->sum_func_count=param->func_count=\n    param->hidden_field_count=0;\n  param->quick_group=1;\n  while ((field=li++))\n  {\n    Item::Type real_type= field->real_item()->type();\n    if (real_type == Item::FIELD_ITEM)\n      param->field_count++;\n    else if (real_type == Item::SUM_FUNC_ITEM)\n    {\n      if (! field->const_item())\n      {\n\tItem_sum *sum_item=(Item_sum*) field->real_item();\n        if (!sum_item->depended_from() ||\n            sum_item->depended_from() == select_lex)\n        {\n          if (!sum_item->quick_group)\n            param->quick_group=0;\t\t\t\n          param->sum_func_count++;\n          for (uint i=0 ; i < sum_item->get_arg_count() ; i++)\n          {\n            if (sum_item->get_arg(i)->real_item()->type() == Item::FIELD_ITEM)\n              param->field_count++;\n            else\n              param->func_count++;\n          }\n        }\n        param->func_count++;\n      }\n    }\n    else\n    {\n      With_sum_func_cache *cache= field->get_with_sum_func_cache();\n      param->func_count++;\n      if (reset_with_sum_func && cache)\n        cache->reset_with_sum_func();\n    }\n  }\n}", "target": 0}
{"code": "static int bnx2x_set_storm_rx_mode(struct bnx2x *bp)\n{\n\tunsigned long rx_mode_flags = 0, ramrod_flags = 0;\n\tunsigned long rx_accept_flags = 0, tx_accept_flags = 0;\n\tint rc;\n\tif (!NO_FCOE(bp))\n\t\t__set_bit(BNX2X_RX_MODE_FCOE_ETH, &rx_mode_flags);\n\trc = bnx2x_fill_accept_flags(bp, bp->rx_mode, &rx_accept_flags,\n\t\t\t\t     &tx_accept_flags);\n\tif (rc)\n\t\treturn rc;\n\t__set_bit(RAMROD_RX, &ramrod_flags);\n\t__set_bit(RAMROD_TX, &ramrod_flags);\n\treturn bnx2x_set_q_rx_mode(bp, bp->fp->cl_id, rx_mode_flags,\n\t\t\t\t   rx_accept_flags, tx_accept_flags,\n\t\t\t\t   ramrod_flags);\n}", "target": 0}
{"code": "find_slot_for_token(cms_context *cms, PK11SlotInfo **slot)\n{\n\tif (!cms->tokenname) {\n\t\tcms->log(cms, LOG_ERR, \"no token name specified\");\n\t\treturn -1;\n\t}\n\tPK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);\n\tPK11SlotList *slots = NULL;\n\tslots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);\n\tif (!slots)\n\t\tcmsreterr(-1, cms, \"could not get pk11 token list\");\n\tPK11SlotListElement *psle = NULL;\n\tpsle = PK11_GetFirstSafe(slots);\n\tif (!psle) {\n\t\tsave_port_err() {\n\t\t\tPK11_FreeSlotList(slots);\n\t\t}\n\t\tcmsreterr(-1, cms, \"could not get pk11 safe\");\n\t}\n\twhile (psle) {\n\t\tif (!strcmp(cms->tokenname, PK11_GetTokenName(psle->slot)))\n\t\t\tbreak;\n\t\tpsle = PK11_GetNextSafe(slots, psle, PR_FALSE);\n\t}\n\tif (!psle) {\n\t\tsave_port_err() {\n\t\t\tPK11_FreeSlotList(slots);\n\t\t}\n\t\tnssreterr(-1, \"Could not find token \\\"%s\\\"\", cms->tokenname);\n\t}\n\tSECStatus status;\n\tif (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {\n\t\tstatus = PK11_Authenticate(psle->slot, PR_TRUE, cms);\n\t\tif (status != SECSuccess) {\n\t\t\tsave_port_err() {\n\t\t\t\tPK11_DestroySlotListElement(slots, &psle);\n\t\t\t\tPK11_FreeSlotList(slots);\n\t\t\t\tcms->log(cms, LOG_ERR,\n\t\t\t\t\t \"authentication failed for token \\\"%s\\\"\",\n\t\t\t\t\t cms->tokenname);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\t*slot = psle->slot;\n\treturn 0;\n}", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFBooleanRef boolean)\n{\n    encoder->encodeBool(CFBooleanGetValue(boolean));\n}", "target": 0}
{"code": "static u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\tu64 ipat = 0;\n\tif (is_mmio) {\n\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm)) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tcache = MTRR_TYPE_WRBACK;\n\t\tgoto exit;\n\t}\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\tcache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);\nexit:\n\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;\n}", "target": 0}
{"code": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tr = true;\n\t\tbreak;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "BOOL CSoundFile::CanPackSample(LPSTR pSample, UINT nLen, UINT nPacking, BYTE *result)\n{\n\tint pos, old, oldpos, besttable = 0;\n\tDWORD dwErr, dwTotal, dwResult;\n\tint i,j;\n\tif (result) *result = 0;\n\tif ((!pSample) || (nLen < 1024)) return FALSE;\n\tdwResult = 0;\n\tfor (j=1; j<MAX_PACK_TABLES; j++)\n\t{\n\t\tmemcpy(CompressionTable, UnpackTable[j], 16);\n\t\tdwErr = 0;\n\t\tdwTotal = 1;\n\t\told = pos = oldpos = 0;\n\t\tfor (i=0; i<(int)nLen; i++)\n\t\t{\n\t\t\tint s = (int)pSample[i];\n\t\t\tPackSample(pos, s);\n\t\t\tdwErr += abs(pos - oldpos);\n\t\t\tdwTotal += abs(s - old);\n\t\t\told = s;\n\t\t\toldpos = pos;\n\t\t}\n\t\tdwErr = _muldiv(dwErr, 100, dwTotal);\n\t\tif (dwErr >= dwResult)\n\t\t{\n\t\t\tdwResult = dwErr;\n\t\t\tbesttable = j;\n\t\t}\n\t}\n\tmemcpy(CompressionTable, UnpackTable[besttable], 16);\n\tif (result)\n\t{\n\t\tif (dwResult > 100) *result\t= 100; else *result = (BYTE)dwResult;\n\t}\n\treturn (dwResult >= nPacking) ? TRUE : FALSE;\n}", "target": 0}
{"code": "static inline void get_termios(struct tty_struct *tty,\n\t\t\t       struct ktermios *out_termios)\n{\n\tdown_read(&tty->termios_rwsem);\n\t*out_termios = tty->termios;\n\tup_read(&tty->termios_rwsem);\n}", "target": 0}
{"code": "static void remove_full(struct kmem_cache *s, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\tn = get_node(s, page_to_nid(page));\n\tspin_lock(&n->list_lock);\n\tlist_del(&page->lru);\n\tspin_unlock(&n->list_lock);\n}", "target": 0}
{"code": "    static bool is4ByteType(uint16_t type)\n    {\n        return isLongType(type)\n            || isRationalType(type)\n            ;\n    }", "target": 0}
{"code": "XML_SetXmlDeclHandler(XML_Parser parser, XML_XmlDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_xmlDeclHandler = handler;\n}", "target": 0}
{"code": "void pm_restore_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&pm_mutex));\n\tif (saved_gfp_mask) {\n\t\tgfp_allowed_mask = saved_gfp_mask;\n\t\tsaved_gfp_mask = 0;\n\t}\n}", "target": 0}
{"code": "xsltNewKeyDef(const xmlChar *name, const xmlChar *nameURI) {\n    xsltKeyDefPtr cur;\n    cur = (xsltKeyDefPtr) xmlMalloc(sizeof(xsltKeyDef));\n    if (cur == NULL) {\n\txsltTransformError(NULL, NULL, NULL,\n\t\t\"xsltNewKeyDef : malloc failed\\n\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xsltKeyDef));\n    if (name != NULL)\n\tcur->name = xmlStrdup(name);\n    if (nameURI != NULL)\n\tcur->nameURI = xmlStrdup(nameURI);\n    cur->nsList = NULL;\n    return(cur);\n}", "target": 0}
{"code": "ospf_packet_new (size_t size)\n{\n  struct ospf_packet *new;\n  new = XCALLOC (MTYPE_OSPF_PACKET, sizeof (struct ospf_packet));\n  new->s = stream_new (size);\n  return new;\n}", "target": 0}
{"code": "    std::ostream& TimeValue::write(std::ostream& os) const\n    {\n        char plusMinus = '+';\n        if (time_.tzHour < 0 || time_.tzMinute < 0) plusMinus = '-';\n        std::ios::fmtflags f( os.flags() );\n        os << std::right\n           << std::setw(2) << std::setfill('0') << time_.hour << ':'\n           << std::setw(2) << std::setfill('0') << time_.minute << ':'\n           << std::setw(2) << std::setfill('0') << time_.second << plusMinus\n           << std::setw(2) << std::setfill('0') << abs(time_.tzHour) << ':'\n           << std::setw(2) << std::setfill('0') << abs(time_.tzMinute);\n        os.flags(f);\n        return os;\n    }", "target": 0}
{"code": "    XmpData& Image::xmpData()\n    {\n        return xmpData_;\n    }", "target": 0}
{"code": "static void cexit(JF, enum js_AstType T, js_Ast *node, js_Ast *target)\n{\n\tjs_Ast *prev;\n\tdo {\n\t\tprev = node, node = node->parent;\n\t\tswitch (node->type) {\n\t\tdefault:  break;\n\t\tcase STM_WITH:\n\t\t\temit(J, F, OP_ENDWITH);\n\t\t\tbreak;\n\t\tcase STM_FOR_IN:\n\t\tcase STM_FOR_IN_VAR:\n\t\t\tif (F->script) {\n\t\t\t\tif (T == STM_RETURN || T == STM_BREAK || (T == STM_CONTINUE && target != node)) {\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_CONTINUE)\n\t\t\t\t\temit(J, F, OP_ROT2); \n\t\t\t} else {\n\t\t\t\tif (T == STM_RETURN) {\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_BREAK || (T == STM_CONTINUE && target != node))\n\t\t\t\t\temit(J, F, OP_POP); \n\t\t\t}\n\t\t\tbreak;\n\t\tcase STM_TRY:\n\t\t\tif (prev == node->a) {\n\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\tif (node->d) cstm(J, F, node->d); \n\t\t\t}\n\t\t\tif (prev == node->c) {\n\t\t\t\tif (node->d) {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\t\tcstm(J, F, node->d); \n\t\t\t\t} else {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (node != target);\n}", "target": 0}
{"code": "get_arg(void __user *b, void *val, int len)\n{\n\tif (len <= 0)\n\t\tlen = sizeof(void *);\n\tif (copy_from_user(val, b, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "vmxnet3_pci_dma_write_rxcd(PCIDevice *pcidev, dma_addr_t pa,\n                           struct Vmxnet3_RxCompDesc *rxcd)\n{\n    rxcd->val1 = cpu_to_le32(rxcd->val1);\n    rxcd->val2 = cpu_to_le32(rxcd->val2);\n    rxcd->val3 = cpu_to_le32(rxcd->val3);\n    pci_dma_write(pcidev, pa, rxcd, sizeof(*rxcd));\n}", "target": 0}
{"code": "static ssize_t vmci_transport_stream_dequeue(\n\tstruct vsock_sock *vsk,\n\tstruct iovec *iov,\n\tsize_t len,\n\tint flags)\n{\n\tif (flags & MSG_PEEK)\n\t\treturn vmci_qpair_peekv(vmci_trans(vsk)->qpair, iov, len, 0);\n\telse\n\t\treturn vmci_qpair_dequev(vmci_trans(vsk)->qpair, iov, len, 0);\n}", "target": 0}
{"code": "static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\n{\n\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = (uint8_t) err;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) /\n\t\t\t     sizeof(uint64_t));\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "bool IsComponentCoveredByLang(const icu::UnicodeSet& component_characters,\n                              const std::string& lang) {\n  static const icu::UnicodeSet kASCIILetters(0x61, 0x7a);  \n  icu::UnicodeSet* lang_set;\n  {\n    AutoLock lock(lang_set_lock);\n    if (!GetExemplarSetForLang(lang, &lang_set)) {\n      UErrorCode status = U_ZERO_ERROR;\n      ULocaleData* uld = ulocdata_open(lang.c_str(), &status);\n      if (U_SUCCESS(status) && status != U_USING_DEFAULT_WARNING) {\n        lang_set = reinterpret_cast<icu::UnicodeSet *>(\n            ulocdata_getExemplarSet(uld, NULL, 0,\n                                    ULOCDATA_ES_STANDARD, &status));\n        if (IsCompatibleWithASCIILetters(lang))\n          lang_set->addAll(kASCIILetters);\n      } else {\n        lang_set = new icu::UnicodeSet(1, 0);\n      }\n      lang_set->freeze();\n      SetExemplarSetForLang(lang, lang_set);\n      ulocdata_close(uld);\n    }\n  }\n  return !lang_set->isEmpty() && lang_set->containsAll(component_characters);\n}", "target": 0}
{"code": "bool PasswordAutofillAgent::FindPasswordInfoForElement(\n    const blink::WebInputElement& element,\n    blink::WebInputElement* username_element,\n    blink::WebInputElement* password_element,\n    PasswordInfo** password_info) {\n  DCHECK(username_element && password_element && password_info);\n  username_element->reset();\n  password_element->reset();\n  if (!element.isPasswordField()) {\n    *username_element = element;\n  } else {\n    WebInputToPasswordInfoMap::iterator iter =\n        web_input_to_password_info_.find(element);\n    if (iter != web_input_to_password_info_.end()) {\n      *password_element = element;\n      *password_info = &iter->second;\n      return true;\n    }\n    PasswordToLoginMap::const_iterator password_iter =\n        password_to_username_.find(element);\n    if (password_iter == password_to_username_.end()) {\n      if (web_input_to_password_info_.empty())\n        return false;\n      *password_element = element;\n      *password_info = &web_input_to_password_info_.begin()->second;\n      return true;\n    }\n    *username_element = password_iter->second;\n    *password_element = element;\n  }\n  WebInputToPasswordInfoMap::iterator iter =\n      web_input_to_password_info_.find(*username_element);\n  if (iter == web_input_to_password_info_.end())\n    return false;\n  *password_info = &iter->second;\n  if (password_element->isNull())\n    *password_element = (*password_info)->password_field;\n  return true;\n}", "target": 0}
{"code": "    uint16_t Image::byteSwap(uint16_t value,bool bSwap) const\n    {\n        uint16_t result = 0;\n        result |= (value & 0x00FF) << 8;\n        result |= (value & 0xFF00) >> 8;\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "SProcRecordRegisterClients(ClientPtr client)\n{\n    REQUEST(xRecordRegisterClientsReq);\n    int status;\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);\n    if ((status = SwapCreateRegister(client, (void *) stuff)) != Success)\n        return status;\n    return ProcRecordRegisterClients(client);\n}                               ", "target": 0}
{"code": "static int orinoco_ioctl_getibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     void *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\t*val = priv->ibss_port;\n\treturn 0;\n}", "target": 0}
{"code": "void bio_copy_data(struct bio *dst, struct bio *src)\n{\n\tstruct bvec_iter src_iter, dst_iter;\n\tstruct bio_vec src_bv, dst_bv;\n\tvoid *src_p, *dst_p;\n\tunsigned bytes;\n\tsrc_iter = src->bi_iter;\n\tdst_iter = dst->bi_iter;\n\twhile (1) {\n\t\tif (!src_iter.bi_size) {\n\t\t\tsrc = src->bi_next;\n\t\t\tif (!src)\n\t\t\t\tbreak;\n\t\t\tsrc_iter = src->bi_iter;\n\t\t}\n\t\tif (!dst_iter.bi_size) {\n\t\t\tdst = dst->bi_next;\n\t\t\tif (!dst)\n\t\t\t\tbreak;\n\t\t\tdst_iter = dst->bi_iter;\n\t\t}\n\t\tsrc_bv = bio_iter_iovec(src, src_iter);\n\t\tdst_bv = bio_iter_iovec(dst, dst_iter);\n\t\tbytes = min(src_bv.bv_len, dst_bv.bv_len);\n\t\tsrc_p = kmap_atomic(src_bv.bv_page);\n\t\tdst_p = kmap_atomic(dst_bv.bv_page);\n\t\tmemcpy(dst_p + dst_bv.bv_offset,\n\t\t       src_p + src_bv.bv_offset,\n\t\t       bytes);\n\t\tkunmap_atomic(dst_p);\n\t\tkunmap_atomic(src_p);\n\t\tbio_advance_iter(src, &src_iter, bytes);\n\t\tbio_advance_iter(dst, &dst_iter, bytes);\n\t}\n}", "target": 0}
{"code": "void DefaultAudioDestinationHandler::StartRendering() {\n  DCHECK(IsMainThread());\n  StartPlatformDestination();\n}", "target": 0}
{"code": "coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)\n{\n\tint r;\n\tconst u8 *val;\n\tsize_t val_len;\n\tr = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\treturn 0;\n\t}\n\tif ((val_len == 1) && (*val == 1)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void WebProcessProxy::pageVisibilityChanged(WebKit::WebPageProxy *page)\n{\n#if PLATFORM(MAC)\n    if (pageIsProcessSuppressible(page))\n        m_processSuppressiblePages.add(page->pageID());\n    else\n        m_processSuppressiblePages.remove(page->pageID());\n    updateProcessSuppressionState();\n#else\n    UNUSED_PARAM(page);\n#endif\n}", "target": 0}
{"code": "ZEND_API int zend_update_static_property_stringl(zend_class_entry *scope, const char *name, int name_length, const char *value, int value_len TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_STRINGL(tmp, value, value_len, 1);\n\treturn zend_update_static_property(scope, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "int RGWListBucket_ObjStore_S3v2::get_params()\n{\nint ret = get_common_params();\nif (ret < 0) {\n  return ret;\n}\ns->info.args.get_bool(\"fetch-owner\", &fetchOwner, false);\nstartAfter = s->info.args.get(\"start-after\", &start_after_exist);\ncontinuation_token = s->info.args.get(\"continuation-token\", &continuation_token_exist);\nif(!continuation_token_exist) {\n  marker = startAfter;\n} else {\n  marker = continuation_token;\n}\nreturn 0;\n}", "target": 0}
{"code": "void Browser::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    const content::MediaResponseCallback& callback) {\n  ::RequestMediaAccessPermission(web_contents, profile_, request, callback);\n}", "target": 0}
{"code": "WebLocalFrame* RenderViewTest::GetMainFrame() {\n  return view_->GetWebView()->MainFrame()->ToWebLocalFrame();\n}", "target": 0}
{"code": "static int nsim_map_delete_elem(struct bpf_offloaded_map *offmap, void *key)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx;\n\tif (offmap->map.map_type == BPF_MAP_TYPE_ARRAY)\n\t\treturn -EINVAL;\n\tmutex_lock(&nmap->mutex);\n\tidx = nsim_map_key_find(offmap, key);\n\tif (idx >= 0) {\n\t\tkfree(nmap->entry[idx].key);\n\t\tkfree(nmap->entry[idx].value);\n\t\tmemset(&nmap->entry[idx], 0, sizeof(nmap->entry[idx]));\n\t}\n\tmutex_unlock(&nmap->mutex);\n\treturn idx < 0 ? idx : 0;\n}", "target": 0}
{"code": "  bool AppendEntry(const TableEntry& entry) {\n    entries_.push_back(entry);\n    return true;\n  }", "target": 0}
{"code": "static inline pte_t pte_mknonnuma(pte_t pte)\n{\n\tpte = pte_clear_flags(pte, _PAGE_NUMA);\n\treturn pte_set_flags(pte, _PAGE_PRESENT|_PAGE_ACCESSED);\n}", "target": 0}
{"code": "void php_gd_error(const char *format, ...)\n{\n\tva_list args;\n\tTSRMLS_FETCH();\n\tva_start(args, format);\n\tphp_verror(NULL, \"\", E_WARNING, format, args TSRMLS_CC);\n\tva_end(args);\n}", "target": 0}
{"code": "void AudioOutputController::DoSetVolume(double volume) {\n  DCHECK_EQ(message_loop_, MessageLoop::current());\n  volume_ = volume;\n  if (state_ != kPlaying && state_ != kPaused && state_ != kCreated)\n    return;\n  stream_->SetVolume(volume_);\n}", "target": 0}
{"code": "oop InstanceKlass::protection_domain() const {\n  return java_lang_Class::protection_domain(java_mirror());\n}", "target": 0}
{"code": "dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tfor ( ; num; num--) {\n\t\tif (FINFO_LSEEK_FUNC(fd, off, SEEK_SET) == (off_t)-1) {\n\t\t\tfile_badseek(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tif (FINFO_READ_FUNC(fd, xph_addr, xph_sizeof) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\t\tif (xph_offset > fsize) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tif (FINFO_LSEEK_FUNC(fd, xph_offset, SEEK_SET) == (off_t)-1) {\n\t\t\tfile_badseek(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tbufsize = FINFO_READ_FUNC(fd, nbuf,\n\t\t    ((xph_filesz < sizeof(nbuf)) ? xph_filesz : sizeof(nbuf)));\n\t\tif (bufsize == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "generate_runningrouters(void)\n{\n  char *s=NULL;\n  char digest[DIGEST_LEN];\n  char published[ISO_TIME_LEN+1];\n  size_t len;\n  crypto_pk_env_t *private_key = get_server_identity_key();\n  char *identity_pkey; \n  size_t identity_pkey_len;\n  if (crypto_pk_write_public_key_to_string(private_key,&identity_pkey,\n                                           &identity_pkey_len)<0) {\n    log_warn(LD_BUG,\"write identity_pkey to string failed!\");\n    goto err;\n  }\n  format_iso_time(published, time(NULL));\n  len = 2048;\n  s = tor_malloc_zero(len);\n  tor_snprintf(s, len,\n               \"network-status\\n\"\n               \"published %s\\n\"\n               \"router-status %s\\n\"\n               \"dir-signing-key\\n%s\"\n               \"directory-signature %s\\n\",\n               published, \"\", identity_pkey,\n               get_options()->Nickname);\n  tor_free(identity_pkey);\n  if (router_get_runningrouters_hash(s,digest)) {\n    log_warn(LD_BUG,\"couldn't compute digest\");\n    goto err;\n  }\n  note_crypto_pk_op(SIGN_DIR);\n  if (router_append_dirobj_signature(s, len, digest, DIGEST_LEN,\n                                     private_key)<0)\n    goto err;\n  set_cached_dir(&the_runningrouters, s, time(NULL));\n  runningrouters_is_dirty = 0;\n  return &the_runningrouters;\n err:\n  tor_free(s);\n  return NULL;\n}", "target": 0}
{"code": "static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif ((tp->retransmit_skb_hint == NULL) ||\n\t    before(TCP_SKB_CB(skb)->seq,\n\t\t   TCP_SKB_CB(tp->retransmit_skb_hint)->seq))\n\t\ttp->retransmit_skb_hint = skb;\n\tif (!tp->lost_out ||\n\t    after(TCP_SKB_CB(skb)->end_seq, tp->retransmit_high))\n\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n}", "target": 0}
{"code": "nfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      void *arg)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}", "target": 0}
{"code": "static void bnx2x_lb_pckt(struct bnx2x *bp)\n{\n\tu32 wb_write[3];\n\twb_write[0] = 0x55555555;\n\twb_write[1] = 0x55555555;\n\twb_write[2] = 0x20;\t\t\n\tREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\n\twb_write[0] = 0x09000000;\n\twb_write[1] = 0x55555555;\n\twb_write[2] = 0x10;\t\t\n\tREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\n}", "target": 0}
{"code": "codegen_error(codegen_scope *s, const char *message)\n{\n  if (!s) return;\n#ifndef MRB_NO_STDIO\n  if (s->filename_sym && s->lineno) {\n    const char *filename = mrb_sym_name_len(s->mrb, s->filename_sym, NULL);\n    fprintf(stderr, \"%s:%d: %s\\n\", filename, s->lineno, message);\n  }\n  else {\n    fprintf(stderr, \"%s\\n\", message);\n  }\n#endif\n  while (s->prev) {\n    codegen_scope *tmp = s->prev;\n    if (s->irep) {\n      mrb_free(s->mrb, s->iseq);\n      for (int i=0; i<s->irep->plen; i++) {\n        mrb_pool_value *pv = &s->pool[i];\n        if ((pv->tt & 0x3) == IREP_TT_STR || pv->tt == IREP_TT_BIGINT) {\n          mrb_free(s->mrb, (void*)pv->u.str);\n        }\n      }\n      mrb_free(s->mrb, s->pool);\n      mrb_free(s->mrb, s->syms);\n      mrb_free(s->mrb, s->catch_table);\n      if (s->reps) {\n        for (int i=0; i<s->irep->rlen; i++) {\n          if (s->reps[i])\n            mrb_irep_decref(s->mrb, (mrb_irep*)s->reps[i]);\n        }\n        mrb_free(s->mrb, s->reps);\n      }\n      mrb_free(s->mrb, s->lines);\n    }\n    mrb_pool_close(s->mpool);\n    s = tmp;\n  }\n  MRB_THROW(s->mrb->jmp);\n}", "target": 0}
{"code": "static int read_quant_tables(RangeCoder *c,\n                             int16_t quant_table[MAX_CONTEXT_INPUTS][256])\n{\n    int i;\n    int context_count = 1;\n    for (i = 0; i < 5; i++) {\n        int ret = read_quant_table(c, quant_table[i], context_count);\n        if (ret < 0)\n            return ret;\n        context_count *= ret;\n        if (context_count > 32768U) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return (context_count + 1) / 2;\n}", "target": 0}
{"code": "static std::string getComment(const std::string &fulltext, int line)\n{\n\tif (line < 1) return \"\";\n\tunsigned int start = 0;\n\tfor (; start<fulltext.length() ; ++start) {\n\t\tif (line <= 1) break;\n\t\tif (fulltext[start] == '\\n') line--;\n\t}\n\tint end = start + 1;\n\twhile (end < fulltext.size() && fulltext[end] != '\\n') end++;\n\tstd::string comment = fulltext.substr(start, end - start);\n\tunsigned int startText = 0;\n\tint noOfSemicolon = 0;\n\tbool inString = false;\n\tfor (; startText < comment.length() - 1; ++startText) {\n\t\tif (inString && comment.compare(startText, 2, \"\\\\\\\"\") == 0) {\n\t\t\tstartText++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (comment[startText] == '\"') inString = !inString;\n\t\tif (!inString) {\n\t\t\tif (comment.compare(startText, 2, \"\n\t\t\tif (comment[startText] == ';' && noOfSemicolon > 0) return \"\";\n\t\t\tif (comment[startText] == ';') noOfSemicolon++;\n\t\t}\n\t}\n\tif (startText + 2 > comment.length()) return \"\";\n\tstd::string result = comment.substr(startText + 2);\n\treturn result;\n}", "target": 0}
{"code": "or_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n\treturn bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n\treturn not_code_range_buf(enc, bbuf2, pbuf, env);\n      }\n    }\n  }\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n  if (not2 == 0 && not1 == 0) { \n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { \n    r = not_code_range_buf(enc, bbuf2, pbuf, env);\n  }\n  if (r != 0) return r;\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, env, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}", "target": 0}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "static void io_wq_exit_workers(struct io_wq *wq)\n{\n\tstruct callback_head *cb;\n\tint node;\n\tif (!wq->task)\n\t\treturn;\n\twhile ((cb = task_work_cancel_match(wq->task, io_task_work_match, wq)) != NULL) {\n\t\tstruct io_worker *worker;\n\t\tworker = container_of(cb, struct io_worker, create_work);\n\t\tatomic_dec(&worker->wqe->acct[worker->create_index].nr_running);\n\t\tio_worker_ref_put(wq);\n\t\tclear_bit_unlock(0, &worker->create_state);\n\t\tio_worker_release(worker);\n\t}\n\trcu_read_lock();\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wq_for_each_worker(wqe, io_wq_worker_wake, NULL);\n\t}\n\trcu_read_unlock();\n\tio_worker_ref_put(wq);\n\twait_for_completion(&wq->worker_done);\n\tfor_each_node(node) {\n\t\tspin_lock_irq(&wq->hash->wait.lock);\n\t\tlist_del_init(&wq->wqes[node]->wait.entry);\n\t\tspin_unlock_irq(&wq->hash->wait.lock);\n\t}\n\tput_task_struct(wq->task);\n\twq->task = NULL;\n}", "target": 0}
{"code": "    WriteMethod TiffParser::encode(\n              BasicIo&  io,\n        const byte*     pData,\n              uint32_t  size,\n              ByteOrder byteOrder,\n        const ExifData& exifData,\n        const IptcData& iptcData,\n        const XmpData&  xmpData\n    )\n    {\n        ExifData ed = exifData;\n        static const IfdId filteredIfds[] = {\n            panaRawId\n        };\n        for (unsigned int i = 0; i < EXV_COUNTOF(filteredIfds); ++i) {\n#ifdef DEBUG\n            std::cerr << \"Warning: Exif IFD \" << filteredIfds[i] << \" not encoded\\n\";\n#endif\n            ed.erase(std::remove_if(ed.begin(),\n                                    ed.end(),\n                                    FindExifdatum(filteredIfds[i])),\n                     ed.end());\n        }\n        std::unique_ptr<TiffHeaderBase> header(new TiffHeader(byteOrder));\n        return TiffParserWorker::encode(io,\n                                        pData,\n                                        size,\n                                        ed,\n                                        iptcData,\n                                        xmpData,\n                                        Tag::root,\n                                        TiffMapping::findEncoder,\n                                        header.get(),\n                                        0);\n    } ", "target": 0}
{"code": "set_tagfunc_option(void)\n{\n#ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n    free_callback(&curbuf->b_tfu_cb);\n    if (*curbuf->b_p_tfu == NUL)\n\treturn OK;\n    if (option_set_callback_func(curbuf->b_p_tfu, &tfu_cb) == FAIL)\n\treturn FAIL;\n    copy_callback(&curbuf->b_tfu_cb, &tfu_cb);\n#endif\n    return OK;\n}", "target": 0}
{"code": "virSecuritySELinuxDriverOpen(virSecurityManager *mgr)\n{\n    return virSecuritySELinuxInitialize(mgr);\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, SymmetricAveragePool) {\n  SymmetricQuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_INT8, {1, 2, 4, 1}, 0, 15.9375},\n      2, 2,\n      {TensorType_INT8, {}, 0, 15.9375});\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({2.75, 5.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({44 - 128, 92 - 128}));\n}", "target": 0}
{"code": "double TabRecordingIndicatorAnimation::GetCurrentValue() const {\n  return current_part_index() % 2 ?\n      1.0 - MultiAnimation::GetCurrentValue() :\n      MultiAnimation::GetCurrentValue();\n}", "target": 0}
{"code": "static int dsa_security_bits(const EVP_PKEY *pkey)\n{\n    return DSA_security_bits(pkey->pkey.dsa);\n}", "target": 0}
{"code": "ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n\t\t\t      signop sgn, enum tree_code code, tree operand)\n{\n  if (other.bottom_p ())\n    return set_to_bottom ();\n  if (bottom_p () || other.top_p ())\n    return false;\n  widest_int adjusted_value, adjusted_mask;\n  if (TREE_CODE_CLASS (code) == tcc_binary)\n    {\n      tree type = TREE_TYPE (operand);\n      widest_int o_value, o_mask;\n      get_value_and_mask (operand, &o_value, &o_mask);\n      bit_value_binop (code, sgn, precision, &adjusted_value, &adjusted_mask,\n\t\t       sgn, precision, other.get_value (), other.get_mask (),\n\t\t       TYPE_SIGN (type), TYPE_PRECISION (type), o_value, o_mask);\n      if (wi::sext (adjusted_mask, precision) == -1)\n\treturn set_to_bottom ();\n    }\n  else if (TREE_CODE_CLASS (code) == tcc_unary)\n    {\n      bit_value_unop (code, sgn, precision, &adjusted_value,\n\t\t      &adjusted_mask, sgn, precision, other.get_value (),\n\t\t      other.get_mask ());\n      if (wi::sext (adjusted_mask, precision) == -1)\n\treturn set_to_bottom ();\n    }\n  else\n    return set_to_bottom ();\n  if (top_p ())\n    {\n      if (wi::sext (adjusted_mask, precision) == -1)\n\treturn set_to_bottom ();\n      return set_to_constant (adjusted_value, adjusted_mask);\n    }\n  else\n    return meet_with_1 (adjusted_value, adjusted_mask, precision);\n}", "target": 0}
{"code": "static ssize_t poison_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\ts->flags &= ~SLAB_POISON;\n\tif (buf[0] == '1') {\n\t\ts->flags |= SLAB_POISON;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}", "target": 0}
{"code": "_XkbWriteAtoms(char *wire,Atom *atoms,int maxAtoms,int swap)\n{\nregister unsigned int i;\nAtom *atm;\n    atm = (Atom *)wire;\n    for (i=0;i<maxAtoms;i++) {\n\tif (atoms[i]!=None) {\n\t    *atm= atoms[i];\n\t    if (swap) {\n\t\tregister int n;\n\t\tswapl(atm,n);\n\t    }\n\t    atm++;\n\t}\n    }\n    return (char *)atm;\n}", "target": 0}
{"code": "static int gen8_emit_flush(struct i915_request *request, u32 mode)\n{\n\tu32 cmd, *cs;\n\tcs = intel_ring_begin(request, 4);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\tcmd = MI_FLUSH_DW + 1;\n\tcmd |= MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;\n\tif (mode & EMIT_INVALIDATE) {\n\t\tcmd |= MI_INVALIDATE_TLB;\n\t\tif (request->engine->class == VIDEO_DECODE_CLASS)\n\t\t\tcmd |= MI_INVALIDATE_BSD;\n\t}\n\t*cs++ = cmd;\n\t*cs++ = LRC_PPHWSP_SCRATCH_ADDR;\n\t*cs++ = 0; \n\t*cs++ = 0; \n\tintel_ring_advance(request, cs);\n\treturn 0;\n}", "target": 0}
{"code": "PassRefPtr<HTMLButtonElement> HTMLButtonElement::create(Document& document, HTMLFormElement* form)\n{\n    return adoptRef(new HTMLButtonElement(document, form));\n}", "target": 0}
{"code": "htmlCheckEncodingDirect(htmlParserCtxtPtr ctxt, const xmlChar *encoding) {\n    if ((ctxt == NULL) || (encoding == NULL) ||\n        (ctxt->options & HTML_PARSE_IGNORE_ENC))\n\treturn;\n    if (ctxt->input->encoding != NULL)\n        return;\n    if (encoding != NULL) {\n\txmlCharEncoding enc;\n\txmlCharEncodingHandlerPtr handler;\n\twhile ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n\tif (ctxt->input->encoding != NULL)\n\t    xmlFree((xmlChar *) ctxt->input->encoding);\n\tctxt->input->encoding = xmlStrdup(encoding);\n\tenc = xmlParseCharEncoding((const char *) encoding);\n\tif (enc != XML_CHAR_ENCODING_ERROR) {\n\t    if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n\t         (enc == XML_CHAR_ENCODING_UTF16BE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4LE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n\t\t(ctxt->input->buf != NULL) &&\n\t\t(ctxt->input->buf->encoder == NULL)) {\n\t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t             \"htmlCheckEncoding: wrong encoding meta\\n\",\n\t\t\t     NULL, NULL);\n\t    } else {\n\t\txmlSwitchEncoding(ctxt, enc);\n\t    }\n\t    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t} else {\n\t    handler = xmlFindCharEncodingHandler((const char *) encoding);\n\t    if (handler != NULL) {\n\t\txmlSwitchToEncoding(ctxt, handler);\n\t\tctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t    } else {\n\t\thtmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n\t\t             \"htmlCheckEncoding: unknown encoding %s\\n\",\n\t\t\t     encoding, NULL);\n\t    }\n\t}\n\tif ((ctxt->input->buf != NULL) &&\n\t    (ctxt->input->buf->encoder != NULL) &&\n\t    (ctxt->input->buf->raw != NULL) &&\n\t    (ctxt->input->buf->buffer != NULL)) {\n\t    int nbchars;\n\t    int processed;\n \t    processed = ctxt->input->cur - ctxt->input->base;\n \t    xmlBufShrink(ctxt->input->buf->buffer, processed);\n \t    nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n            xmlBufResetInput(ctxt->input->buf->buffer, ctxt->input);\n \t    if (nbchars < 0) {\n \t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n \t\t             \"htmlCheckEncoding: encoder error\\n\",\n \t\t\t     NULL, NULL);\n \t    }\n \t}\n     }\n }", "target": 0}
{"code": "MediaStreamAudioDestinationNode* AudioContext::createMediaStreamDestination()\n{\n    return MediaStreamAudioDestinationNode::create(this, 2);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CannotTrimIxisectAndHashWithOrChild) {\n    params.options = QueryPlannerParams::INDEX_INTERSECTION;\n    params.options |= QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    addIndex(BSON(\"c\" << 1));\n    runQuery(fromjson(\"{c: 1, $or: [{a: 1}, {b: 1, d: 1}]}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {c: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {d: 1}, node: {ixscan: {filter: null,\"\n        \"pattern: {b: 1}, bounds: {b: [[1,1,true,true]]}}}}},\"\n        \"{ixscan: {filter: null, pattern: {a: 1},\"\n        \"bounds: {a: [[1,1,true,true]]}}}]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$or:[{b:1,d:1},{a:1}]}, node:\"\n        \"{ixscan: {filter: null, pattern: {c: 1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {c:1,$or:[{a:1},{b:1,d:1}]}, node:{andHash:{nodes:[\"\n        \"{or: {nodes: [\"\n        \"{fetch: {filter: {d:1}, node: {ixscan: {pattern: {b: 1}}}}},\"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}]}},\"\n        \"{ixscan: {filter: null, pattern: {c: 1}}}]}}}}\");\n}", "target": 0}
{"code": "device_linux_md_stop (Device *device,\n                      char **options,\n                      DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_linux_md)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a Linux md drive\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.linux-md\",\n                           \"LinuxMdStop\",\n                           TRUE,\n                           device_linux_md_stop_authorized_cb,\n                           context,\n                           1,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "void IndexedDBDatabase::Count(IndexedDBTransaction* transaction,\n                              int64_t object_store_id,\n                              int64_t index_id,\n                              std::unique_ptr<IndexedDBKeyRange> key_range,\n                              scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Count\", \"txn.id\", transaction->id());\n  if (!ValidateObjectStoreIdAndOptionalIndexId(object_store_id, index_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::CountOperation,\n                                           this, object_store_id, index_id,\n                                           std::move(key_range), callbacks));\n}", "target": 0}
{"code": "void JSArray::setSubclassData(void* d)\n{\n    m_storage->subclassData = d;\n}", "target": 0}
{"code": "int ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\n\t\t  const struct net_device *dev, int strict)\n{\n\tstruct inet6_ifaddr *ifp;\n\tunsigned int hash = inet6_addr_hash(addr);\n\trcu_read_lock_bh();\n\thlist_for_each_entry_rcu(ifp, &inet6_addr_lst[hash], addr_lst) {\n\t\tif (!net_eq(dev_net(ifp->idev->dev), net))\n\t\t\tcontinue;\n\t\tif (ipv6_addr_equal(&ifp->addr, addr) &&\n\t\t    !(ifp->flags&IFA_F_TENTATIVE) &&\n\t\t    (dev == NULL || ifp->idev->dev == dev ||\n\t\t     !(ifp->scope&(IFA_LINK|IFA_HOST) || strict))) {\n\t\t\trcu_read_unlock_bh();\n\t\t\treturn 1;\n\t\t}\n\t}\n\trcu_read_unlock_bh();\n\treturn 0;\n}", "target": 0}
{"code": "strcasehash(st_data_t arg)\n{\n    register const char *string = (const char *)arg;\n    register st_index_t hval = FNV1_32A_INIT;\n    while (*string) {\n\tunsigned int c = (unsigned char)*string++;\n\tif ((unsigned int)(c - 'A') <= ('Z' - 'A')) c += 'a' - 'A';\n\thval ^= c;\n\thval *= FNV_32_PRIME;\n    }\n    return hval;\n}", "target": 0}
{"code": "static int dump_write(struct file *file, const void *addr, int nr)\n{\n\treturn file->f_op->write(file, addr, nr, &file->f_pos) == nr;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, FloatingPointInKeyPattern) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << -0.1));\n    runQuerySortProj(fromjson(\"{a: {$gte: 3, $lte: 5}}\"), fromjson(\"{a: 1}\"), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a: -0.1}, \"\n        \"bounds: {a: [[3, 5, true, true]]}}}}}\");\n}", "target": 0}
{"code": "void ciEnv::validate_compile_task_dependencies(ciMethod* target) {\n  if (failing())  return;  \n  for (Dependencies::DepStream deps(dependencies()); deps.next(); ) {\n    if (deps.is_klass_type())  continue;  \n    Klass* witness = deps.check_dependency();\n    if (witness != NULL) {\n      record_failure(\"invalid non-klass dependency\");\n      return;\n    }\n  }\n  bool counter_changed = system_dictionary_modification_counter_changed();\n  bool verify_deps = trueInDebug;\n  if (!counter_changed && !verify_deps)  return;\n  int klass_violations = 0;\n  for (Dependencies::DepStream deps(dependencies()); deps.next(); ) {\n    if (!deps.is_klass_type())  continue;  \n    Klass* witness = deps.check_dependency();\n    if (witness != NULL) {\n      klass_violations++;\n      if (!counter_changed) {\n        deps.print_dependency(witness);\n      } else if (xtty == NULL) {\n        break;\n      }\n    }\n  }\n  if (klass_violations != 0) {\n#ifdef ASSERT\n    if (!counter_changed && !PrintCompilation) {\n      _task->print_line();\n    }\n#endif\n    assert(counter_changed, \"failed dependencies, but counter didn't change\");\n    record_failure(\"concurrent class loading\");\n  }\n}", "target": 0}
{"code": "static int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm)\n\t\t\tif (v == vcpu)\n\t\t\t\tdata = r;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tdefault:\n\t\tpr_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}", "target": 0}
{"code": "GF_Box *av1c_box_new() {\n\tGF_AV1ConfigurationBox *tmp = (GF_AV1ConfigurationBox *)gf_malloc(sizeof(GF_AV1ConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AV1ConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AV1C;\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_run_javascript_prompt(Ewk_View_Smart_Data* smartData, Evas_Object* frame, const char* message, const char* defaultValue, char** value)\n{\n    *value = strdup(\"test\");\n    Eina_Bool result = true;\n    INF(\"javascript prompt:\\n\"\n        \"\\t      message: %s\\n\"\n        \"\\tdefault value: %s\\n\"\n        \"\\tgiving answer: %s\\n\"\n        \"\\t       button: %s\", message, defaultValue, *value, result ? \"ok\" : \"cancel\");\n    return result;\n}", "target": 0}
